#Reconstruction_PPM_MHD_HelperModule.py
#By Delica Leboe-McGowan, PhD Student, University of Manitoba
#Last Updated: January 1, 2024
#Purpose: Provides functions for second-order primitive variable reconstruction
#         in magnetohydrodynamic simulations. The three functions in this module,
#         respectively, perform the piecewise parabolic method (PPM) [1] in the
#         x-, y-, and z-directions for Cartesian simulation grids.
#
#Additional Information:    The reconstruction functions in this script allow us to improve the effective spatial
#                       resolution of our magnetohydrodynamic simulations. When we don't use a primitive variable
#                       reconstruction algorithm, we calculate the flux between two cells by passing the adjacent
#                       cell-centred gas states to our chosen Riemann solver. For example, in the x-direction, we give
#                       the Riemann solver the state of the gas at the centre of the cell just to the left of an
#                       intercell boundary (i.e., the boundary between two different cells) and the state of the gas
#                       at the centre of the cell just to the right of the same boundary. This approach assumes that
#                       the state of the gas is constant throughout a single cell. In a real gas system that is
#                       evolving over time, it is extremely (extremely!) unlikely that we would ever find a perfect
#                       cube of gas with no internal variations in density, pressure, or velocity. When we don't use
#                       primitive variable reconstruction, we calculate intercell flux values from a pixelated version
#                       of the gas. A preferable approach is to somehow reflect the primitive variable fluctuations
#                       within a single cell when we send gas states to the Riemann solver. Spatial reconstruction
#                       algorithms for CFD (Computational Fluid Dynamics) use the cell-centred gas states to interpolate
#                       the gas states at the boundaries between cells.
#                                              F_1/2                    F_3/2                     F_5/2
#                       |                       |                         |                         |
#                       |                       |                         |                         |
#                       |         W_0    W_1/2,L|W_1/2,R    W_1    W_3/2,L|W_3/2,R    W_2    W_5/2,L|
#                       |                       |                         |                         |
#                       |                       |                         |                         |
#                                Cell 0                     Cell 1                    Cell 2
#                       W = primitive variable vector, F = intercell flux vector
#
#                       The Piecewise Parabolic Method (PPM) is a second-order spatial reconstruction scheme because
#                       it uses parabolas to interpolate the gas states at cell boundaries. In PythonMHD, you have the
#                       option of instead using the Piecewise Linear Method (PLM) for spatial reconstruction, which is
#                       a first-order scheme that uses lines to interpolate the boundary states. To set the type
#                       of reconstruction algorithm that you would like to use (none, first-order, or second-order),
#                       use the "reconstructOrder" parameter in simPar (see PythonMHD user guide for information
#                       on how to properly set up simPar in your initialization file).
#
#                       The second-order/PPM reconstruction functions in this script are designed to generate
#                       interpolated gas states that are numerically identical (within a margin of ~10^()) to those
#                       generated by the PPM algorithm in the 2017 version of Athena [2] by James Stone and colleagues.
#                       In order to achieve this consistency, PythonMHD uses the reconstruction eigenmatrices
#                       (i.e., the matrices that allow us to convert between primitive and characteristic variables
#                       (see [4] for a good explanation of characteristic variables in the context of hydrodynamics))
#                       that are presented in the original Athena methods paper [3].
#
#                       Primitive variable reconstruction for MHD simulations is a bit more complicated than hydrodynamic
#                       reconstruction, because we need to add source terms to the reconstructed magnetic field components.
#                       The importance of these source terms in MHD simulations is discussed in (Gardiner & Stone, 2005)
#                       [5]. Essentially, our directionally split PPM algorithms (directionally split because we perform
#                       the algorithm independently/separately in each spatial direction) leave out div(B) source terms
#                       when it performs the characteristic tracing step (i.e., the step where we subtract overshot
#                       wave contributions that don't reach the cell boundary in time dt/2). Adding the source terms
#                       defined in [5] after PPM reconstruction corrects this problem. Below you can find the source
#                       term formulas that are required for 2D and 3D MHD simulations (no source terms are necessary
#                       in 1D).
#
#                       2D X-Direction Reconstruction Magnetic Field Source Terms
#                       In the x-direction for a 2D MHD simulation, we need to add source terms to the reconstructed
#                       By values on the left and right sides of each intercell boundary (By_L and By_R).
#
#                       Bx_i-3/2                Bx_i-1/2                  Bx_i+1/2
#                          |                       |                         |
#                          |                       |                         |
#                          |         Vy_i-1    By_L|By_R       Vy_i          |
#                          |                       |                         |
#                          |                       |                         |
#                                  Cell i - 1                 Cell i
#                        After performing PPM reconstruction in the x-direction, we will add delta(By_L) to
#                        the reconstructed By_L value and delta(By_R) to the reconstructed By_R values.
#
#                        delta(By_L) = (dt/2dx)*Vy_i-1*(Bx_i-1/2 - Bx_i-3/2)
#                        delta(By_R) = (dt/2dx)*Vy_i*(Bx_i+1/2 - Bx_i-1/2)
#
#                       2D Y-Direction Reconstruction Magnetic Field Source Terms
#                       In the y-direction for a 2D MHD simulation, we need to add source terms to the reconstructed
#                       Bx values above (top/T) and below (bottom/B) each intercell boundary (Bx_T and Bx_B).
#                         _ _ _ _ _ _ _ _ _ _ _ _  By_j-3/2
#                        |                       |
#                        |                       |
#                        |                       |
#                        |         Vx_j-1        |   Cell j - 1
#                        |                       |
#                        |                       |
#                        |         Bx_T          |
#                        |- - - - - - - - - - - -| By_j-1/2
#                        |         Bx_B          |
#                        |                       |
#                        |                       |
#                        |         Vx_j          |   Cell j
#                        |                       |
#                        |                       |
#                        |_ _ _ _ _ _ _ _ _ _ _ _| By_j+1/2
#
#                        After performing PPM reconstruction in the y-direction, we will add delta(Bx_T) to
#                        the reconstructed Bx_T value and delta(Bx_B) to the reconstructed Bx_B values.
#
#                        delta(Bx_T) = (dt/2dy)*Vx_j-1*(By_j-1/2 - By_j-3/2)
#                        delta(Bx_B) = (dt/2dy)*Vx_j*(Bx_j+1/2 - Bx_j-1/2)
#
#                       3D X-Direction Reconstruction Magnetic Field Source Terms
#                       [Visualizations are not provided for the 3D source terms because it is difficult to clearly
#                        present all six sides of the cell in this format.]
#                       [Important Note: In 3D simulations, the positive z-direction (i.e., the "forward" direction
#                        in PythonMHD's terminology) is into the screen, whereas the negative z-direction (i.e.,
#                        the "backward" direction) is out of the screen.]
#                       For the x-direction in 3D, we need to add source terms to the left and right reconstructed
#                       By and Bz values (By_L, By_R, Bz_L, and Bz_R).
#                       Note: j = y-index, i = x-index, k = z-index
#                       delta(By_L) = -(dt/2)*Vy_(j,i-1,k)*minmod((Bz_(j,i-1,k+1/2) - Bz_(j,i-1,k-1/2))/dz,
#                                                           -(Bx_(j,i-1/2,k) - Bx_(j,i-3/2,k)/dx)
#                       delta(By_R) = -(dt/2)*Vy_(j,i,k)*minmod((Bz_(j,i,k+1/2) - Bz_(j,i,k-1/2))/dz,
#                                                           -(Bx_(j,i+1/2,k) - Bx_(j,i-1/2,k)/dx)
#                       delta(Bz_L) = -(dt/2)*Vz_(j,i-1,k)*minmod((By_(j+1/2,i-1,k) - By_(j-1/2,i-1,k))/dy,
#                                                           -(Bx_(j,i-1/2,k) - Bx_(j,i-3/2,k)/dx)
#                       delta(Bz_R) = -(dt/2)*Vz_(j,i,k)*minmod((By_(j+1/2,i,k) - By_(j-1/2,i,k))/dy,
#                                                           -(Bx_(j,i+1/2,k) - Bx_(j,i-1/2,k)/dx)
#
#                       3D Y-Direction Reconstruction Magnetic Field Source Terms
#                       For the y-direction in 3D, we need to add source terms to the top and bottom reconstructed
#                       Bx and Bz values (Bx_T, Bx_B, Bz_T, and Bz_B).
#                       Note: j = y-index, i = x-index, k = z-index
#                       delta(Bx_T) = -(dt/2)*Vx_(j-1,i,k)*minmod((Bz_(j-1,i,k+1/2) - Bz_(j-1,i,k-1/2))/dz,
#                                                                 -(By_(j-1/2,i,k) - By_(j-3/2,i,k))/dy)
#                       delta(Bx_B) = -(dt/2)*Vx_(j,i,k)*minmod((Bz_(j,i,k+1/2) - Bz_(j,i,k-1/2))/dz,
#                                                                 -(By_(j+1/2,i,k) - By_(j-1/2,i,k))/dy)
#                       delta(Bz_L) = -(dt/2)*Vz_(j-1,i,k)*minmod((Bx_(j-1,i+1/2,k) - Bx_(j-1,i-1/2,k))/dx,
#                                                                 -(By_(j-1/2,i,k) - By_(j-3/2,i,k))/dy)
#                       delta(Bz_R) = -(dt/2)*Vz_(j,i,k)*minmod((Bx_(j,i+1/2,k) - Bx_(j,i-1/2,k))/dx,
#                                                                 -(By_(j+1/2,i,k) - By_(j-1/2,i,k))/dy)
#
#                       3D Z-Direction Reconstruction Magnetic Field Source Terms
#                       For the z-direction in 3D, we need to add source terms to the back and forward reconstructed
#                       Bx and By values (Bx_B, Bx_F, By_B, and By_F).
#                       Note: j = y-index, i = x-index, k = z-index
#                       delta(Bx_B) = -(dt/2)*Vx_(j,i,k-1)*minmod((By_(j+1/2,i,k-1) - By_(j-1/2,i,k-1))/dy,
#                                                                 -(Bz_(j,i,k-1/2) - Bz_(j,i,k-3/2))/dz)
#                       delta(Bx_T) = -(dt/2)*Vx_(j,i,k)*minmod((By_(j+1/2,i,k) - By_(j-1/2,i,k))/dy,
#                                                                -(Bz_(j,i,k+1/2) - Bz_(j,i,k-1/2))/dz)
#                       delta(By_T) = -(dt/2)*Vy_(j,i,k-1)*minmod((Bx_(j,i+1/2,k-1) - By_(j,i-1/2,k-1))/dx,
#                                                                 -(Bz_(j,i,k-1/2) - Bz_(j,i,k-3/2))/dz)
#                       delta(By_B) = -(dt/2)*Vy_(j,i,k)*minmod((Bx_(j,i+1/2,k) - By_(j,i-1/2,k))/dx,
#                                                                 -(Bz_(j,i,k+1/2) - Bz_(j,i,k-1/2))/dz)
#
#References
# 1. Colella, P., & Woodward, P. R. (1984). The Piecewise Parabolic Method (PPM) for gas-dynamical simulations.
#    Journal of Computational Physics, 54(1), 174-201. https://doi.org/10.1016/0021-9991(84)90143-8
# 2. https://github.com/PrincetonUniversity/Athena-Cversion
# 3. Stone, J. M., Gardiner, T. A., Teuben, P., Hawley, J. F., & Simon, J. B. (2008).
#    Athena: A new code for astrophysical MHD. The Astrophysical Journal Supplemental Series,
#    178(1), 137-177. https://iopscience.iop.org/article/10.1086/588755/pdf
# 4. Banyuls, F., Font, A. J., Ibanez, J. M., Marti, J.M, & Miralles, J. A. (1997). Numerical {3 + 1} General
#    Relativistic Hydrodynamics: A Local Characteristic Approach. The Astrophysical Journal, 476, 221-231.
#    https://iopscience.iop.org/article/10.1086/303604/fulltext/34434.text.html
# 5. Gardiner, T. A., & Stone, J. M. (2005). An unsplit Godunov method for ideal MHD via Constrained Transport.
#    Journal of Computational Physics, 205(2), 509-539. https://arxiv.org/pdf/astro-ph/0501557.pdf
#

#####IMPORT STATEMENTS#####

#Import PythonMHD constants
import Source.PythonMHD_Constants as constants

#Import helper module for calculating the magnetohydrodynamic reconstruction eigenmatrices
import Source.ReconstructionEigenmatrices_MHD_HelperModule as eig

#Import NumPy for matrix operations
import numpy as np

#####X-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructX_mhd
#Purpose: Calculates the reconstructed/interpolated left and right states for every intercell
#         boundary in the x-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVarsX (the x-direction primitive variables for every cell in the simulation grid,
#                             includes all primitive variables except Bx)
#                  Bx (the x-component of the magnetic field at the centre of each cell
#                      in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dx (the cell width/size of the cell in the x-direction)
#                  BcX (integer for the boundary condition in the x-direction
#                       (0 = outflow and 1 = periodic))
#Outputs: leftPrimVarState (the interpolated primitive variable states just to the left
#                           of each intercell boundary)
#         rightPrimVarState (the interpolated primitive variable states just to the right
#                           of each intercell boundary)
def ppmReconstructX_mhd(primVars, Bx, gamma, dt, dx, BcX):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that there are only 1, 2, or 3 spatial dimensions
    assert numDim == 1 or numDim == 2 or numDim == 3, "Reconstruction algorithm encountered primitive variable matrix" \
                                                      " with invalid dimensions"
    #We need to expand the primitive variable and Bx matrices so that they have two extra columns
    #in the x-direction on either side. These extra cells will simplify subsequent steps in the algorithm.
    #(Note: The number of extra cells we need on either side is equal to the order of the reconstruction
    #       algorithm (i.e., 2 for second-order/PPM).)
    if numDim == 1: #if the sim is 1D
        #Create an empty matrix for the expanded primitive variable grid
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4))
        #Add the primitive variables we already have to the middle of the new grid
        expandedPrimVars[:,2:expandedPrimVars.shape[1]-2] = primVars[:,:]
        #Create an empty matrix for the expanded Bx grid
        expandedBx = np.zeros(shape=(Bx.shape[0]+4))
        #Add the Bx values that we already have to the middle of the new grid
        expandedBx[2:expandedBx.shape[0]-2] = Bx[:]
        #Now we will figure out how we should fill the four additional columns
        #Check whether the boundary condition (BC) in the x-direction is outflow or periodic
        if BcX == 0: #if the BC is outflow
            #If the BC is outflow, copy the leftmost primitive variables into
            #both of the additional columns on the left.
            expandedPrimVars[:,0] = primVars[:,0]
            expandedPrimVars[:,1] = primVars[:,0]
            #If the BC is outflow, copy the leftmost Bx values into
            #both of the additional columns on the left.
            expandedBx[0] = Bx[0]
            expandedBx[1] = Bx[0]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,expandedPrimVars.shape[1]-1] = primVars[:,primVars.shape[1]-1]
            expandedPrimVars[:,expandedPrimVars.shape[1]-2] = primVars[:,primVars.shape[1]-1]
            #Copy the rightmost Bx values into the additional
            #columns on the right.
            expandedBx[expandedBx.shape[0]-1] = Bx[Bx.shape[0]-1]
            expandedBx[expandedBx.shape[0]-2] = Bx[Bx.shape[0]-1]
        else: #if the BC is periodic
            #If the BC is periodic, copy the rightmost primitive variables into
            #the additional columns on the left.
            expandedPrimVars[:,0] = primVars[:,primVars.shape[1]-2]
            expandedPrimVars[:,1] = primVars[:,primVars.shape[1]-1]
            #If the BC is periodic, copy the rightmost Bx values into
            #the additional columns on the left.
            expandedBx[0] = Bx[Bx.shape[0]-2]
            expandedBx[1] = Bx[Bx.shape[0]-1]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,expandedPrimVars.shape[1]-1] = primVars[:,1]
            expandedPrimVars[:,expandedPrimVars.shape[1]-2] = primVars[:,0]
            #Copy the rightmost Bx values into the additional
            #columns on the right.
            expandedBx[expandedBx.shape[0]-1] = Bx[1]
            expandedBx[expandedBx.shape[0]-2] = Bx[0]
    else:  #if the sim is 2D or 3D
        #Create an empty matrix for the expanded primitive variable grid
        if numDim == 2:
            expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2]+4))
        else:
            expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2]+4,primVars.shape[3]))
        #Add the primitive variables we already have to the middle of the new grid
        expandedPrimVars[:,:,2:expandedPrimVars.shape[2]-2] = primVars[:]
        #Create an empty matrix for the expanded Bx grid
        if numDim == 2:
            expandedBx = np.zeros(shape=(Bx.shape[0],Bx.shape[1]+4))
        else:
            expandedBx = np.zeros(shape=(Bx.shape[0],Bx.shape[1]+4,Bx.shape[2]))
        #Add the primitive variables we already have to the middle of the new grid
        expandedPrimVars[:,:,2:expandedPrimVars.shape[2]-2] = primVars[:]
        #Add the Bx values that we already have to the middle of the new grid
        expandedBx[:,2:expandedBx.shape[1]-2] = Bx[:]
        #Now we will figure out how we should fill the four additional columns
        #Check whether the boundary condition (BC) in the x-direction is outflow or periodic
        if BcX == 0: #if the BC is outflow
            #If the BC is outflow, copy the leftmost primitive variables into
            #both of the additional columns on the left.
            expandedPrimVars[:,:,0] = primVars[:,:,0]
            expandedPrimVars[:,:,1] = primVars[:,:,0]
            #If the BC is outflow, copy the leftmost Bx values into
            #both of the additional columns on the left.
            expandedBx[:,0] = Bx[:,0]
            expandedBx[:,1] = Bx[:,0]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-1] = primVars[:,:,primVars.shape[2]-1]
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-2] = primVars[:,:,primVars.shape[2]-1]
            #Copy the rightmost Bx values into the additional
            #columns on the right.
            expandedBx[:,expandedBx.shape[1]-1] = Bx[:,Bx.shape[1]-1]
            expandedBx[:,expandedBx.shape[1]-2] = Bx[:,Bx.shape[1]-1]
        else: #if the BC is periodic
            #If the BC is periodic, copy the rightmost primitive variables into
            #the additional columns on the left.
            expandedPrimVars[:,:,0] = primVars[:,:,primVars.shape[2]-2]
            expandedPrimVars[:,:,1] = primVars[:,:,primVars.shape[2]-1]
            #If the BC is periodic, copy the rightmost Bx values into
            #the additional columns on the left.
            expandedBx[:,0] = Bx[:,Bx.shape[1]-2]
            expandedBx[:,1] = Bx[:,Bx.shape[1]-1]
            #Copy the leftmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-1] = primVars[:,:,1]
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-2] = primVars[:,:,0]
            #Copy the leftmost Bx values into the additional
            #columns on the right.
            expandedBx[:,expandedBx.shape[1]-1] = Bx[:,1]
            expandedBx[:,expandedBx.shape[1]-2] = Bx[:,0]

    #Using our expanded primitive variable matrices, we will create matrices
    #for left, right, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required for PPM
    #reconstruction. We will also store the Bx values for the centre cells,
    #because we will need these magnetic field components to calculate
    #the left and right eigenmatrices.
    if numDim == 1:
        centPrimVars = expandedPrimVars[:,1:expandedPrimVars.shape[1]-1]
        centBx = expandedBx[1:expandedBx.shape[0]-1]
        leftPrimVars = expandedPrimVars[:,0:expandedPrimVars.shape[1]-2]
        rightPrimVars = expandedPrimVars[:,2:expandedPrimVars.shape[1]]
    else:
        centPrimVars = expandedPrimVars[:,:,1:expandedPrimVars.shape[2]-1]
        centBx = expandedBx[:,1:expandedBx.shape[1]-1]
        leftPrimVars = expandedPrimVars[:,:,0:expandedPrimVars.shape[2]-2]
        rightPrimVars = expandedPrimVars[:,:,2:expandedPrimVars.shape[2]]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesX_mhd(centPrimVars, centBx, gamma)

    #Calculate the primitive variable difference between the right and left cells
    centPrimVarDiff = rightPrimVars - leftPrimVars
    #Calculate the primitive variable difference between the centre and left cells
    leftPrimVarDiff = centPrimVars - leftPrimVars
    #Calculate the primitive variable difference between the right and centre cells
    rightPrimVarDiff = rightPrimVars - centPrimVars

    #Compute weight values for positions where the left and right differences
    #have the same sign (i.e., leftPrimVarDiff and rightPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = leftPrimVarDiff*rightPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*leftPrimVarDiff*rightPrimVarDiff)[weightIndices] \
                            /(leftPrimVarDiff + rightPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    leftCharVarDiff = np.zeros(shape=leftPrimVarDiff.shape)
    rightCharVarDiff = np.zeros(shape=rightPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        #Multiply the centre primitive differences by the current left eigenmatrix row
        centCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*centPrimVarDiff[0,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*centPrimVarDiff[1,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*centPrimVarDiff[2,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*centPrimVarDiff[3,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*centPrimVarDiff[6,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*centPrimVarDiff[4,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*centPrimVarDiff[5,:]
        #Multiply the left primitive differences by the current left eigenmatrix row
        leftCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*leftPrimVarDiff[0,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*leftPrimVarDiff[1,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*leftPrimVarDiff[2,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*leftPrimVarDiff[3,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*leftPrimVarDiff[6,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*leftPrimVarDiff[4,:]
        leftCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*leftPrimVarDiff[5,:]
        #Multiply the right primitive differences by the current left eigenmatrix row
        rightCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*rightPrimVarDiff[0,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*rightPrimVarDiff[1,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*rightPrimVarDiff[2,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*rightPrimVarDiff[3,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*rightPrimVarDiff[6,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*rightPrimVarDiff[4,:]
        rightCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*rightPrimVarDiff[5,:]
        #Multiply the weights primitive differences by the current left eigenmatrix row
        weightChar[i,:] += leftEigenmatrix[i,0,:]*weight[0,:]
        weightChar[i,:] += leftEigenmatrix[i,1,:]*weight[1,:]
        weightChar[i,:] += leftEigenmatrix[i,2,:]*weight[2,:]
        weightChar[i,:] += leftEigenmatrix[i,3,:]*weight[3,:]
        weightChar[i,:] += leftEigenmatrix[i,6,:]*weight[6,:]
        weightChar[i,:] += leftEigenmatrix[i,4,:]*weight[4,:]
        weightChar[i,:] += leftEigenmatrix[i,5,:]*weight[5,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = leftCharVarDiff*rightCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(leftCharVarDiff), np.abs(rightCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
        slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] = primMonSlopes[i,:] + charMonSlopes[j,:] * rightEigenmatrix[i,j,:]

    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector to its left, and the slope vector to its right.
    if numDim == 1:
        centPrimMonSlopes = primMonSlopes[:,1:primMonSlopes.shape[1]-1]
        leftPrimMonSlopes = primMonSlopes[:,0:primMonSlopes.shape[1]-2]
        rightPrimMonSlopes = primMonSlopes[:,2:primMonSlopes.shape[1]]
    else:
        centPrimMonSlopes = primMonSlopes[:,:,1:primMonSlopes.shape[2]-1]
        leftPrimMonSlopes = primMonSlopes[:,:,0:primMonSlopes.shape[2]-2]
        rightPrimMonSlopes = primMonSlopes[:,:,2:primMonSlopes.shape[2]]

    #Remove the outermost columns from centPrimVars, leftPrimVars, and rightPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    if numDim == 1:
        centPrimVars = centPrimVars[:,1:centPrimVars.shape[1]-1]
        leftPrimVars = leftPrimVars[:,1:leftPrimVars.shape[1]-1]
        rightPrimVars = rightPrimVars[:,1:rightPrimVars.shape[1]-1]
    else:
        centPrimVars = centPrimVars[:,:,1:centPrimVars.shape[2]-1]
        leftPrimVars = leftPrimVars[:,:,1:leftPrimVars.shape[2]-1]
        rightPrimVars = rightPrimVars[:,:,1:rightPrimVars.shape[2]-1]

    #Calculate an interpolated state on the left edge of every cell
    leftInterfaceAvg = 0.5*(centPrimVars + leftPrimVars) \
                       - (centPrimMonSlopes - leftPrimMonSlopes)/6.0
    #Calculate an interpolated state on the right edge of every cell
    rightInterfaceAvg = 0.5*(rightPrimVars + centPrimVars) \
                        - (rightPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the left and right halves of the cell
    diffProd = (rightInterfaceAvg - centPrimVars)*(centPrimVars - leftInterfaceAvg)
    #Calculate the difference between the left and right interface states
    interfaceDiff = rightInterfaceAvg - leftInterfaceAvg
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the left and right interpolated states.
    avgDiff = 6.0 * (centPrimVars - 0.5*(leftInterfaceAvg + rightInterfaceAvg))
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    #Apply monotonicity constraints
    leftInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    rightInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctLeftIndices = np.logical_and(diffProdPos, (interfaceDiff*avgDiff) > np.square(interfaceDiff))
    leftInterfaceAvg[correctLeftIndices] = ((6.0*centPrimVars - 4.0*rightInterfaceAvg) / 2.0)[correctLeftIndices]
    correctRightIndices = np.logical_and(np.logical_and(diffProdPos,np.logical_not(correctLeftIndices)),
                                          (interfaceDiff*avgDiff) < (-1.0 * np.square(interfaceDiff)))
    rightInterfaceAvg[correctRightIndices] = ((6.0*centPrimVars - 4.0*leftInterfaceAvg) / 2.0)[correctRightIndices]
    #Apply additional monotonicity constraints
    leftInterfaceAvg = np.maximum(np.minimum(centPrimVars, leftPrimVars), leftInterfaceAvg)
    leftInterfaceAvg = np.minimum(np.maximum(centPrimVars, leftPrimVars), leftInterfaceAvg)
    rightInterfaceAvg = np.maximum(np.minimum(centPrimVars, rightPrimVars), rightInterfaceAvg)
    rightInterfaceAvg = np.minimum(np.maximum(centPrimVars, rightPrimVars), rightInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    if numDim == 1:
        leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1]
        rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1]
        eigenVals = eigenVals[:,1:eigenVals.shape[1]-1]
    elif numDim == 2:
        leftEigenmatrix = leftEigenmatrix[:,:,:,1:leftEigenmatrix.shape[3]-1]
        rightEigenmatrix = rightEigenmatrix[:,:,:,1:rightEigenmatrix.shape[3]-1]
        eigenVals = eigenVals[:,:,1:eigenVals.shape[2]-1]
    else:
        leftEigenmatrix = leftEigenmatrix[:,:,:,1:leftEigenmatrix.shape[3]-1,:]
        rightEigenmatrix = rightEigenmatrix[:,:,:,1:rightEigenmatrix.shape[3]-1,:]
        eigenVals = eigenVals[:,:,1:eigenVals.shape[2]-1,:]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdx = dt/dx
    coeff1 = rightInterfaceAvg - leftInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(leftInterfaceAvg + rightInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[6],0.0)*dtdx
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdx

    #Evolve the left interpolated state by half a timestep
    leftInterfaceAvg = leftInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the right interpolated state by half a timestep
    rightInterfaceAvg = rightInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)


    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas [2,3], we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid wave contributions from the left interpolated state.
    for i in range(eigenVals.shape[0]):
        leftOvershootIndices = eigenVals[i] <= 0.0
        leftOvershootFactor = np.zeros(shape=leftOvershootIndices.shape)
        leftOvershootVal1 = 0.5*dtdx*eigenVals[0]
        leftOvershootVal2 = 0.5*dtdx*eigenVals[i]
        leftOvershootVal3 = leftOvershootVal1 - leftOvershootVal2
        leftOvershootVal4 = constants.FOUR_THIRDS*(np.square(leftOvershootVal1) - np.square(leftOvershootVal2))
        for j in range(4):
            leftOvershootFactor += leftOvershootIndices*leftEigenmatrix[i,j,:] \
                                    *(leftOvershootVal3*(coeff1[j] + coeff2[j])
                                       + leftOvershootVal4*coeff2[j])
        leftOvershootFactor += leftOvershootIndices*leftEigenmatrix[i,6,:] \
                                *(leftOvershootVal3*(coeff1[6] + coeff2[6])
                                  + leftOvershootVal4*coeff2[6])
        leftOvershootFactor += leftOvershootIndices*leftEigenmatrix[i,4,:] \
                                *(leftOvershootVal3*(coeff1[4] + coeff2[4])
                                  + leftOvershootVal4*coeff2[4])
        leftOvershootFactor += leftOvershootIndices*leftEigenmatrix[i,5,:] \
                                *(leftOvershootVal3*(coeff1[5] + coeff2[5])
                                  + leftOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            leftInterfaceAvg[j] += leftOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the right interpolated state.
    for i in range(eigenVals.shape[0]):
        rightOvershootIndices = eigenVals[i] >= 0.0
        rightOvershootFactor = np.zeros(shape=rightOvershootIndices.shape)
        rightOvershootVal1 = 0.5*dtdx*eigenVals[6]
        rightOvershootVal2 = 0.5*dtdx*eigenVals[i]
        rightOvershootVal3 = rightOvershootVal1 - rightOvershootVal2
        rightOvershootVal4 = constants.FOUR_THIRDS*(np.square(rightOvershootVal1) - np.square(rightOvershootVal2))
        for j in range(4):
            rightOvershootFactor += rightOvershootIndices*leftEigenmatrix[i,j,:] \
                                    *(rightOvershootVal3*(coeff1[j] - coeff2[j])
                                      + rightOvershootVal4*coeff2[j])
        rightOvershootFactor += rightOvershootIndices*leftEigenmatrix[i,6,:] \
                                *(rightOvershootVal3*(coeff1[6] - coeff2[6])
                                  + rightOvershootVal4*coeff2[6])
        rightOvershootFactor += rightOvershootIndices*leftEigenmatrix[i,4,:] \
                                *(rightOvershootVal3*(coeff1[4] - coeff2[4])
                                  + rightOvershootVal4*coeff2[4])
        rightOvershootFactor += rightOvershootIndices*leftEigenmatrix[i,5,:] \
                                *(rightOvershootVal3*(coeff1[5] - coeff2[5])
                                  + rightOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            rightInterfaceAvg[j] += rightOvershootFactor*rightEigenmatrix[j,i,:]


    #Lastly, we will apply our boundary conditions to obtain the left and right PPM reconstructed
    #states for every intercell boundary in the x-direction.
    if BcX == 0: #if the boundary condition is outflow
        if numDim == 1:
            leftPrimVarState = np.append(leftInterfaceAvg[:,0].reshape(-1,1),rightInterfaceAvg,axis=1)
            rightPrimVarState = np.append(leftInterfaceAvg,rightInterfaceAvg[:,rightInterfaceAvg.shape[1]-1].reshape(-1,1),axis=1)
        elif numDim == 2:
            leftPrimVarState = np.append(leftInterfaceAvg[:,:,0].reshape(7,-1,1),rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1].reshape(7,-1,1),axis=2)
        else:
            leftPrimVarState = np.append(leftInterfaceAvg[:,:,0].reshape(7,rightInterfaceAvg.shape[1],1,-1),rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1].reshape(7,leftInterfaceAvg.shape[1],1,-1),axis=2)
    else: #if the boundary condition is periodic
        if numDim == 1:
            leftPrimVarState = np.append(rightInterfaceAvg[:,rightInterfaceAvg.shape[1]-1].reshape(-1,1),rightInterfaceAvg,axis=1)
            rightPrimVarState = np.append(leftInterfaceAvg,leftInterfaceAvg[:,0].reshape(-1,1),axis=1)
        elif numDim == 2:
            leftPrimVarState = np.append(rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1].reshape(7,-1,1),rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,leftInterfaceAvg[:,:,0].reshape(7,-1,1),axis=2)
        else:
            leftPrimVarState = np.append(rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1,:].reshape(7,rightInterfaceAvg.shape[1],1,-1),rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,leftInterfaceAvg[:,:,0].reshape(7,leftInterfaceAvg.shape[1],1,-1),axis=2)

    #Return the reconstructed left and right states
    return leftPrimVarState, rightPrimVarState

#####Y-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructY_mhd
#Purpose: Calculates the reconstructed/interpolated top and bottom states for every intercell
#         boundary in the y-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVars (the y-direction primitive variables for every cell in the simulation grid,
#                            includes all primitive variables except By)
#                  By (the y-component of the magnetic field at the centre of each cell
#                      in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dy (the cell height/size of the cell in the y-direction)
#                  BcY (integer for the boundary condition in the y-direction
#                       (0 = outflow and 1 = periodic))
#Outputs: topPrimVarState (the interpolated primitive variable states just above
#                          each intercell boundary)
#         bottomPrimVarState (the interpolated primitive variable states just below
#                             each intercell boundary)
def ppmReconstructY_mhd(primVars,By,gamma,dt,dy,BcY):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that there are only 1, 2, or 3 spatial dimensions
    assert numDim == 1 or numDim == 2 or numDim == 3, "Reconstruction algorithm encountered primitive variable matrix" \
                                                      " with invalid dimensions"
    #We need to expand the primitive variable and By matrices so that they have two extra rows
    #in the y-direction on either side. These extra cells will simplify subsequent
    #steps in the algorithm.(Note: The number of extra cells we need on either side is

    #equal to the order of the reconstruction algorithm (i.e., 2 for second-order/PPM).)
    #Create an empty matrix for the expanded primitive variable grid
    if numDim == 2:
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2]))
    else:
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2],primVars.shape[3]))
    #Add the primitive variables we already have to the middle of the new grid
    expandedPrimVars[:,2:expandedPrimVars.shape[1]-2,:] = primVars[:]
    #Create an empty matrix for the expanded By grid
    if numDim == 2:
        expandedBy = np.zeros(shape=(By.shape[0]+4,By.shape[1]))
    else:
        expandedBy = np.zeros(shape=(By.shape[0]+4,By.shape[1],By.shape[2]))
    #Add the primitive variables we already have to the middle of the new grid
    expandedBy[2:expandedBy.shape[0]-2,:] = By[:]
    #Now we will figure out how we should fill the four additional rows
    #Check whether the boundary condition (BC) in the y-direction is outflow or periodic
    if BcY == 0: #if the BC is outflow
        #If the BC is outflow, copy the topmost primitive variables into
        #both of the additional columns at the top.
        expandedPrimVars[:,0,:] = primVars[:,0,:]
        expandedPrimVars[:,1,:] = primVars[:,0,:]
        #If the BC is outflow, copy the topmost By values into
        #both of the additional columns at the top.
        expandedBy[0,:] = By[0,:]
        expandedBy[1,:] = By[0,:]
        #Copy the lowermost primitive variables into the additional
        #columns at the bottom.
        expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,primVars.shape[1]-1,:]
        expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,primVars.shape[1]-1,:]
        #Copy the lowermost By values into the additional
        #columns at the bottom.
        expandedBy[expandedBy.shape[0]-1,:] = By[By.shape[0]-1,:]
        expandedBy[expandedBy.shape[0]-2,:] = By[By.shape[0]-1,:]
    else: #if the BC is periodic
        #If the BC is periodic, copy the lowermost primitive variables into
        #the additional columns at the top.
        expandedPrimVars[:,0,:] = primVars[:,primVars.shape[1]-2,:]
        expandedPrimVars[:,1,:] = primVars[:,primVars.shape[1]-1,:]
        #If the BC is periodic, copy the lowermost By values into
        #the additional columns at the top.
        expandedBy[0,:] = By[By.shape[0]-2,:]
        expandedBy[1,:] = By[By.shape[0]-1,:]
        #Copy the topmost primitive variables into the additional
        #columns at the bottom.
        expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,1,:]
        expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,0,:]
        #Copy the topmost By values into the additional
        #columns at the bottom.
        expandedBy[expandedBy.shape[0]-1,:] = By[1,:]
        expandedBy[expandedBy.shape[0]-2,:] = By[0,:]

    #Using our expanded primitive variable matrix, we will create matrices
    #for top, bottom, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required for PPM
    #reconstruction.
    centPrimVars = expandedPrimVars[:,1:expandedPrimVars.shape[1]-1,:]
    topPrimVars = expandedPrimVars[:,0:expandedPrimVars.shape[1]-2,:]
    bottomPrimVars = expandedPrimVars[:,2:expandedPrimVars.shape[1],:]
    #We also need to save the By values for the centre cells
    centBy = expandedBy[1:expandedBy.shape[0]-1,:]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesY_mhd(centPrimVars, centBy, gamma)

    #Calculate the primitive variable difference between the bottom and top cells
    centPrimVarDiff = bottomPrimVars - topPrimVars
    #Calculate the primitive variable difference between the centre and top cells
    topPrimVarDiff = centPrimVars - topPrimVars
    #Calculate the primitive variable difference between the bottom and centre cells
    bottomPrimVarDiff = bottomPrimVars - centPrimVars

    #Compute weight values for positions where the top and bottom differences
    #have the same sign (i.e., topPrimVarDiff and bottomPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = topPrimVarDiff*bottomPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*topPrimVarDiff*bottomPrimVarDiff)[weightIndices] \
                            /(topPrimVarDiff + bottomPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    topCharVarDiff = np.zeros(shape=topPrimVarDiff.shape)
    bottomCharVarDiff = np.zeros(shape=bottomPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        #Multiply the centre primitive differences by the current left eigenmatrix row
        centCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*centPrimVarDiff[0,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*centPrimVarDiff[2,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*centPrimVarDiff[3,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*centPrimVarDiff[1,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*centPrimVarDiff[6,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*centPrimVarDiff[4,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*centPrimVarDiff[5,:]
        #Multiply the top primitive differences by the current left eigenmatrix row
        topCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*topPrimVarDiff[0,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*topPrimVarDiff[2,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*topPrimVarDiff[3,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*topPrimVarDiff[1,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*topPrimVarDiff[6,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*topPrimVarDiff[4,:]
        topCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*topPrimVarDiff[5,:]
        #Multiply the bottom primitive differences by the current left eigenmatrix row
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*bottomPrimVarDiff[0,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*bottomPrimVarDiff[2,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*bottomPrimVarDiff[3,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*bottomPrimVarDiff[1,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*bottomPrimVarDiff[6,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*bottomPrimVarDiff[4,:]
        bottomCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*bottomPrimVarDiff[5,:]
        #Multiply the weights primitive differences by the current left eigenmatrix row
        weightChar[i,:] += leftEigenmatrix[i,0,:]*weight[0,:]
        weightChar[i,:] += leftEigenmatrix[i,2,:]*weight[2,:]
        weightChar[i,:] += leftEigenmatrix[i,3,:]*weight[3,:]
        weightChar[i,:] += leftEigenmatrix[i,1,:]*weight[1,:]
        weightChar[i,:] += leftEigenmatrix[i,6,:]*weight[6,:]
        weightChar[i,:] += leftEigenmatrix[i,4,:]*weight[4,:]
        weightChar[i,:] += leftEigenmatrix[i,5,:]*weight[5,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = topCharVarDiff*bottomCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(topCharVarDiff), np.abs(bottomCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
        slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] = primMonSlopes[i,:] + charMonSlopes[j,:] * rightEigenmatrix[i,j,:]
    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector above it, and the slope vector below it.
    centPrimMonSlopes = primMonSlopes[:,1:primMonSlopes.shape[1]-1,:]
    topPrimMonSlopes = primMonSlopes[:,0:primMonSlopes.shape[1]-2,:]
    bottomPrimMonSlopes = primMonSlopes[:,2:primMonSlopes.shape[1],:]

    #Remove the outermost columns from centPrimVars, topPrimVars, and bottomPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    centPrimVars = centPrimVars[:,1:centPrimVars.shape[1]-1,:]
    topPrimVars = topPrimVars[:,1:topPrimVars.shape[1]-1,:]
    bottomPrimVars = bottomPrimVars[:,1:bottomPrimVars.shape[1]-1,:]

    #Calculate an interpolated state at the top edge of every cell
    topInterfaceAvg = 0.5*(centPrimVars + topPrimVars) \
                       - (centPrimMonSlopes - topPrimMonSlopes)/6.0
    #Calculate an interpolated state at the bottom edge of every cell
    bottomInterfaceAvg = 0.5*(bottomPrimVars + centPrimVars) \
                        - (bottomPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena [2]
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the top and bottom halves of the cell
    diffProd = (bottomInterfaceAvg - centPrimVars)*(centPrimVars - topInterfaceAvg)
    #Calculate the difference between the top and bottom interface states
    interfaceDiff = bottomInterfaceAvg - topInterfaceAvg
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the top and bottom interpolated states.
    avgDiff = 6.0*(centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    #Apply monotonicity constraints
    topInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    bottomInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctTopIndices = np.logical_and(diffProdPos, (interfaceDiff*avgDiff) > np.square(interfaceDiff))
    topInterfaceAvg[correctTopIndices] = ((6.0*centPrimVars - 4.0*bottomInterfaceAvg) / 2.0)[correctTopIndices]
    correctBottomIndices = np.logical_and(np.logical_and(diffProdPos,np.logical_not(correctTopIndices)),
                                          (interfaceDiff*avgDiff) < (-1.0 * np.square(interfaceDiff)))
    bottomInterfaceAvg[correctBottomIndices] = ((6.0*centPrimVars - 4.0*topInterfaceAvg) / 2.0)[correctBottomIndices]
    #Apply additional monotonicity constraints
    topInterfaceAvg = np.maximum(np.minimum(centPrimVars, topPrimVars), topInterfaceAvg)
    topInterfaceAvg = np.minimum(np.maximum(centPrimVars, topPrimVars), topInterfaceAvg)
    bottomInterfaceAvg = np.maximum(np.minimum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)
    bottomInterfaceAvg = np.minimum(np.maximum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1,:]
    rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1,:]
    eigenVals = eigenVals[:,1:eigenVals.shape[1]-1,:]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdy = dt/dy
    coeff1 = bottomInterfaceAvg - topInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[6],0.0)*dtdy
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdy

    #Evolve the top interpolated state by half a timestep
    topInterfaceAvg = topInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the bottom interpolated state by half a timestep
    bottomInterfaceAvg = bottomInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)

    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas, we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid/overshoot wave contributions from the top interpolated state.
    for i in range(eigenVals.shape[0]):
        topOvershootIndices = eigenVals[i] <= 0.0
        topOvershootFactor = np.zeros(shape=topOvershootIndices.shape)
        topOvershootVal1 = 0.5*dtdy*eigenVals[0]
        topOvershootVal2 = 0.5*dtdy*eigenVals[i]
        topOvershootVal3 = topOvershootVal1 - topOvershootVal2
        topOvershootVal4 = constants.FOUR_THIRDS*(np.square(topOvershootVal1) - np.square(topOvershootVal2))
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,0,:] \
                                *(topOvershootVal3*(coeff1[0] + coeff2[0])
                                   + topOvershootVal4*coeff2[0])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,2,:] \
                                *(topOvershootVal3*(coeff1[2] + coeff2[2])
                                   + topOvershootVal4*coeff2[2])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,3,:] \
                                *(topOvershootVal3*(coeff1[3] + coeff2[3])
                                   + topOvershootVal4*coeff2[3])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,1,:] \
                                *(topOvershootVal3*(coeff1[1] + coeff2[1])
                                   + topOvershootVal4*coeff2[1])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,6,:] \
                                *(topOvershootVal3*(coeff1[6] + coeff2[6])
                                   + topOvershootVal4*coeff2[6])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,4,:] \
                                *(topOvershootVal3*(coeff1[4] + coeff2[4])
                                   + topOvershootVal4*coeff2[4])
        topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,5,:] \
                                *(topOvershootVal3*(coeff1[5] + coeff2[5])
                                   + topOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            topInterfaceAvg[j] += topOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the bottom interpolated state.
    for i in range(eigenVals.shape[0]):
        bottomOvershootIndices = eigenVals[i] >= 0.0
        bottomOvershootFactor = np.zeros(shape=bottomOvershootIndices.shape)
        bottomOvershootVal1 = 0.5*dtdy*eigenVals[6]
        bottomOvershootVal2 = 0.5*dtdy*eigenVals[i]
        bottomOvershootVal3 = bottomOvershootVal1 - bottomOvershootVal2
        bottomOvershootVal4 = constants.FOUR_THIRDS*(np.square(bottomOvershootVal1) - np.square(bottomOvershootVal2))
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,0,:] \
                               *(bottomOvershootVal3*(coeff1[0] - coeff2[0])
                                  + bottomOvershootVal4*coeff2[0])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,2,:] \
                               *(bottomOvershootVal3*(coeff1[2] - coeff2[2])
                                  + bottomOvershootVal4*coeff2[2])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,3,:] \
                               *(bottomOvershootVal3*(coeff1[3] - coeff2[3])
                                  + bottomOvershootVal4*coeff2[3])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,1,:] \
                               *(bottomOvershootVal3*(coeff1[1] - coeff2[1])
                                  + bottomOvershootVal4*coeff2[1])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,6,:] \
                               *(bottomOvershootVal3*(coeff1[6] - coeff2[6])
                                  + bottomOvershootVal4*coeff2[6])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,4,:] \
                               *(bottomOvershootVal3*(coeff1[4] - coeff2[4])
                                  + bottomOvershootVal4*coeff2[4])
        bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,5,:] \
                               *(bottomOvershootVal3*(coeff1[5] - coeff2[5])
                                  + bottomOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            bottomInterfaceAvg[j] += bottomOvershootFactor*rightEigenmatrix[j,i,:]

    #Lastly, we will apply our boundary conditions to obtain the top and bottom PPM reconstructed
    #states for every intercell boundary in the y-direction.
    if BcY == 0: #if the boundary condition is outflow
        if numDim == 2:
            topPrimVarState = np.append(topInterfaceAvg[:,0,:].reshape(7,1,-1),bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(7,1,-1),
                                           axis=1)
        else:
            topPrimVarState = np.append(topInterfaceAvg[:,0,:,:].reshape(7,1,topInterfaceAvg.shape[2],-1),bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(7,1,bottomInterfaceAvg.shape[2],-1),
                                           axis=1)

    else: #if the boundary condition is periodic
        if numDim == 2:
            topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(7,1,-1),bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,topInterfaceAvg[:,0,:].reshape(7,1,-1),axis=1)
        else:
            topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(7,1,bottomInterfaceAvg.shape[2],-1),bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,topInterfaceAvg[:,0,:].reshape(7,1,topInterfaceAvg.shape[2],-1),axis=1)

    #Return the reconstructed top and bottom states
    return topPrimVarState, bottomPrimVarState


#####Z-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructZ_mhd
#Purpose: Calculates the reconstructed/interpolated back and forward states for every intercell
#         boundary in the z-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVars (the y-direction primitive variables for every cell in the simulation grid,
#                            includes all primitive variables except Bz)
#                  Bz (the z-component of the magnetic field at the centre of each cell
#                      in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dz (the cell height/size of the cell in the z-direction)
#                  BcZ (integer for the boundary condition in the z-direction
#                       (0 = outflow and 1 = periodic))
#Outputs: backPrimVarState (the interpolated primitive variable states just above
#                           each intercell boundary)
#         forwPrimVarState (the interpolated primitive variable states just below
#                           each intercell boundary)
def ppmReconstructZ_mhd(primVars,Bz,gamma,dt,dz,BcZ):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that the simulation is 3D (otherwise we shouldn't have a z-direction)
    assert numDim == 3, "Reconstruction algorithm (z-direction) encountered primitive variable matrix" \
                        " with invalid dimensions"
    #We need to expand the primitive variable and Bz matrices so that they have two extra rows
    #in the z-direction on either side. These extra cells will simplify subsequent
    #steps in the algorithm.
    #Create an empty matrix for the expanded primitive variable grid
    expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2],primVars.shape[3]+4))
    #Add the primitive variables we already have to the middle of the new grid
    expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]-2] = primVars[:,:,:,:]
    #Create an empty matrix for the expanded Bz grid
    expandedBz = np.zeros(shape=(Bz.shape[0],Bz.shape[1],Bz.shape[2]+4))
    #Add the primitive variables we already have to the middle of the new grid
    expandedBz[:,:,2:expandedBz.shape[2]-2] = Bz[:,:,:]
    #Now we will figure out how we should fill the four additional rows
    #Check whether the boundary condition (BC) in the z-direction is outflow or periodic
    if BcZ == 0: #if the BC is outflow
        #If the BC is outflow, copy the farthest back primitive variables into
        #both of the additional columns at the front.
        expandedPrimVars[:,:,:,0] = primVars[:,:,:,0]
        expandedPrimVars[:,:,:,1] = primVars[:,:,:,0]
        #If the BC is outflow, copy the farthest back Bz values into
        #both of the additional columns at the front.
        expandedBz[:,:,0] = Bz[:,:,0]
        expandedBz[:,:,1] = Bz[:,:,0]
        #Copy the frontmost primitive variables into the additional
        #columns at the back.
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,primVars.shape[3]-1]
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,primVars.shape[3]-1]
        #Copy the frontmost Bz values into the additional
        #columns at the back.
        expandedBz[:,:,expandedBz.shape[2]-1] = Bz[:,:,Bz.shape[2]-1]
        expandedBz[:,:,expandedBz.shape[2]-2] = Bz[:,:,Bz.shape[2]-1]
    else: #if the BC is periodic
        #If the BC is periodic, copy the frontmost primitive variables into
        #the additional columns at the back.
        expandedPrimVars[:,:,:,0] = primVars[:,:,:,primVars.shape[3]-2]
        expandedPrimVars[:,:,:,1] = primVars[:,:,:,primVars.shape[3]-1]
        #If the BC is periodic, copy the frontmost Bz values into
        #the additional columns at the back.
        expandedBz[:,:,0] = Bz[:,:,Bz.shape[2]-2]
        expandedBz[:,:,1] = Bz[:,:,Bz.shape[2]-1]
        #Copy the farthest back primitive variables into the additional
        #columns at the front.
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,1]
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,0]
        #Copy the farthest back Bz values into the additional
        #columns at the front.
        expandedBz[:,:,expandedBz.shape[2]-1] = Bz[:,:,1]
        expandedBz[:,:,expandedBz.shape[2]-2] = Bz[:,:,0]

    #Using our expanded primitive variable matrix, we will create matrices
    #for back, forward, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required for PPM
    #reconstruction.
    centPrimVars = expandedPrimVars[:,:,:,1:expandedPrimVars.shape[3]-1]
    backPrimVars = expandedPrimVars[:,:,:,0:expandedPrimVars.shape[3]-2]
    forwPrimVars = expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]]
    #We also need to save the Bz values for the centre cells.
    centBz = expandedBz[:,:,1:expandedBz.shape[2]-1]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesZ_mhd(centPrimVars, centBz, gamma)

    #Calculate the primitive variable difference between the forward and backward cells
    centPrimVarDiff = forwPrimVars - backPrimVars
    #Calculate the primitive variable difference between the centre and backward cells
    backPrimVarDiff = centPrimVars - backPrimVars
    #Calculate the primitive variable difference between the forward and centre cells
    forwPrimVarDiff = forwPrimVars - centPrimVars

    #Compute weight values for positions where the back and forward differences
    #have the same sign (i.e., backPrimVarDiff and forwPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = backPrimVarDiff*forwPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*backPrimVarDiff*forwPrimVarDiff)[weightIndices] \
                            /(backPrimVarDiff + forwPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    backCharVarDiff = np.zeros(shape=backPrimVarDiff.shape)
    forwCharVarDiff = np.zeros(shape=forwPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        #Multiply the centre primitive differences by the current left eigenmatrix row
        centCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*centPrimVarDiff[0,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*centPrimVarDiff[3,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*centPrimVarDiff[1,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*centPrimVarDiff[2,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*centPrimVarDiff[6,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*centPrimVarDiff[4,:]
        centCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*centPrimVarDiff[5,:]
        #Multiply the back primitive differences by the current left eigenmatrix row
        backCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*backPrimVarDiff[0,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*backPrimVarDiff[3,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*backPrimVarDiff[1,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*backPrimVarDiff[2,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*backPrimVarDiff[6,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*backPrimVarDiff[4,:]
        backCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*backPrimVarDiff[5,:]
        #Multiply the forward primitive differences by the current left eigenmatrix row
        forwCharVarDiff[i,:] += leftEigenmatrix[i,0,:]*forwPrimVarDiff[0,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,3,:]*forwPrimVarDiff[3,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,1,:]*forwPrimVarDiff[1,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,2,:]*forwPrimVarDiff[2,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,6,:]*forwPrimVarDiff[6,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,4,:]*forwPrimVarDiff[4,:]
        forwCharVarDiff[i,:] += leftEigenmatrix[i,5,:]*forwPrimVarDiff[5,:]
        #Multiply the weights primitive differences by the current left eigenmatrix row
        weightChar[i,:] += leftEigenmatrix[i,0,:]*weight[0,:]
        weightChar[i,:] += leftEigenmatrix[i,3,:]*weight[3,:]
        weightChar[i,:] += leftEigenmatrix[i,1,:]*weight[1,:]
        weightChar[i,:] += leftEigenmatrix[i,2,:]*weight[2,:]
        weightChar[i,:] += leftEigenmatrix[i,6,:]*weight[6,:]
        weightChar[i,:] += leftEigenmatrix[i,4,:]*weight[4,:]
        weightChar[i,:] += leftEigenmatrix[i,5,:]*weight[5,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = backCharVarDiff*forwCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(backCharVarDiff), np.abs(forwCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
        slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] = primMonSlopes[i,:] + charMonSlopes[j,:]*rightEigenmatrix[i,j,:]

    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector behind it, and the slope vector in front of it.
    centPrimMonSlopes = primMonSlopes[:,:,:,1:primMonSlopes.shape[3]-1]
    backPrimMonSlopes = primMonSlopes[:,:,:,0:primMonSlopes.shape[3]-2]
    forwPrimMonSlopes = primMonSlopes[:,:,:,2:primMonSlopes.shape[3]]
    #Remove the outermost columns from centPrimVars, backPrimVars, and forwPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    centPrimVars = centPrimVars[:,:,:,1:centPrimVars.shape[3]-1]
    backPrimVars = backPrimVars[:,:,:,1:backPrimVars.shape[3]-1]
    forwPrimVars = forwPrimVars[:,:,:,1:forwPrimVars.shape[3]-1]

    #Calculate an interpolated state at the back edge every cell
    backInterfaceAvg = 0.5*(centPrimVars + backPrimVars) \
                       - (centPrimMonSlopes - backPrimMonSlopes)/6.0
    #Calculate an interpolated state at the front edge of every cell
    forwInterfaceAvg = 0.5*(forwPrimVars + centPrimVars) \
                        - (forwPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena [2]
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the back and forward halves of the cell
    diffProd = (forwInterfaceAvg - centPrimVars)*(centPrimVars - backInterfaceAvg)
    #Calculate the difference between the back and forward interface states
    interfaceDiff = forwInterfaceAvg - backInterfaceAvg
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the back and forward interpolated states.
    avgDiff = 6.0*(centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    #Apply monotonicity constraints
    backInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    forwInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctBackIndices = np.logical_and(diffProdPos, (interfaceDiff*avgDiff) > np.square(interfaceDiff))
    backInterfaceAvg[correctBackIndices] = ((6.0*centPrimVars - 4.0*forwInterfaceAvg) / 2.0)[correctBackIndices]
    correctForwIndices = np.logical_and(np.logical_and(diffProdPos,np.logical_not(correctBackIndices)),
                                          (interfaceDiff*avgDiff) < (-1.0 * np.square(interfaceDiff)))
    forwInterfaceAvg[correctForwIndices] = ((6.0*centPrimVars - 4.0*backInterfaceAvg) / 2.0)[correctForwIndices]
    #Apply additional monotonicity constraints
    backInterfaceAvg = np.maximum(np.minimum(centPrimVars, backPrimVars), backInterfaceAvg)
    backInterfaceAvg = np.minimum(np.maximum(centPrimVars, backPrimVars), backInterfaceAvg)
    forwInterfaceAvg = np.maximum(np.minimum(centPrimVars, forwPrimVars), forwInterfaceAvg)
    forwInterfaceAvg = np.minimum(np.maximum(centPrimVars, forwPrimVars), forwInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    leftEigenmatrix = leftEigenmatrix[:,:,:,:,1:leftEigenmatrix.shape[4]-1]
    rightEigenmatrix = rightEigenmatrix[:,:,:,:,1:rightEigenmatrix.shape[4]-1]
    eigenVals = eigenVals[:,:,:,1:eigenVals.shape[3]-1]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdz = dt/dz
    coeff1 = forwInterfaceAvg - backInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[6],0.0)*dtdz
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdz

    #Evolve the back interpolated state by half a timestep
    backInterfaceAvg = backInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the forward interpolated state by half a timestep
    forwInterfaceAvg = forwInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)

    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas, we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid/overshoot wave contributions from the back interpolated state.
    for i in range(eigenVals.shape[0]):
        backOvershootIndices = eigenVals[i] <= 0.0
        backOvershootFactor = np.zeros(shape=backOvershootIndices.shape)
        backOvershootVal1 = 0.5*dtdz*eigenVals[0]
        backOvershootVal2 = 0.5*dtdz*eigenVals[i]
        backOvershootVal3 = backOvershootVal1 - backOvershootVal2
        backOvershootVal4 = constants.FOUR_THIRDS*(np.square(backOvershootVal1) - np.square(backOvershootVal2))
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,0,:] \
                                *(backOvershootVal3*(coeff1[0] + coeff2[0])
                                   + backOvershootVal4*coeff2[0])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,3,:] \
                                *(backOvershootVal3*(coeff1[3] + coeff2[3])
                                   + backOvershootVal4*coeff2[3])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,1,:] \
                                *(backOvershootVal3*(coeff1[1] + coeff2[1])
                                   + backOvershootVal4*coeff2[1])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,2,:] \
                                *(backOvershootVal3*(coeff1[2] + coeff2[2])
                                   + backOvershootVal4*coeff2[2])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,6,:] \
                                *(backOvershootVal3*(coeff1[6] + coeff2[6])
                                   + backOvershootVal4*coeff2[6])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,4,:] \
                                *(backOvershootVal3*(coeff1[4] + coeff2[4])
                                   + backOvershootVal4*coeff2[4])
        backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,5,:] \
                                *(backOvershootVal3*(coeff1[5] + coeff2[5])
                                   + backOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            backInterfaceAvg[j] += backOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the forward interpolated state.
    for i in range(eigenVals.shape[0]):
        forwOvershootIndices = eigenVals[i] >= 0.0
        forwOvershootFactor = np.zeros(shape=forwOvershootIndices.shape)
        forwOvershootVal1 = 0.5*dtdz*eigenVals[6]
        forwOvershootVal2 = 0.5*dtdz*eigenVals[i]
        forwOvershootVal3 = forwOvershootVal1 - forwOvershootVal2
        forwOvershootVal4 = constants.FOUR_THIRDS*(np.square(forwOvershootVal1) - np.square(forwOvershootVal2))
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,0,:] \
                               *(forwOvershootVal3*(coeff1[0] - coeff2[0])
                                  + forwOvershootVal4*coeff2[0])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,3,:] \
                               *(forwOvershootVal3*(coeff1[3] - coeff2[3])
                                  + forwOvershootVal4*coeff2[3])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,1,:] \
                               *(forwOvershootVal3*(coeff1[1] - coeff2[1])
                                  + forwOvershootVal4*coeff2[1])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,2,:] \
                               *(forwOvershootVal3*(coeff1[2] - coeff2[2])
                                  + forwOvershootVal4*coeff2[2])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,6,:] \
                               *(forwOvershootVal3*(coeff1[6] - coeff2[6])
                                  + forwOvershootVal4*coeff2[6])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,4,:] \
                               *(forwOvershootVal3*(coeff1[4] - coeff2[4])
                                  + forwOvershootVal4*coeff2[4])
        forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,5,:] \
                               *(forwOvershootVal3*(coeff1[5] - coeff2[5])
                                  + forwOvershootVal4*coeff2[5])
        for j in range(eigenVals.shape[0]):
            forwInterfaceAvg[j] += forwOvershootFactor*rightEigenmatrix[j,i,:]

    #Lastly, we will apply our boundary conditions to obtain the back and forward PPM reconstructed
    #states for every intercell boundary in the z-direction.
    if BcZ == 0: #if the boundary condition is outflow
        backPrimVarState = np.append(backInterfaceAvg[:,:,:,0].reshape(7,backInterfaceAvg.shape[1],-1,1),
                                     forwInterfaceAvg,axis=3)
        forwPrimVarState = np.append(backInterfaceAvg,
                                     forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(7,forwInterfaceAvg.shape[1],-1,1),
                                     axis=3)
    else: #if the boundary condition is periodic
        backPrimVarState = np.append(forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(7,forwInterfaceAvg.shape[1],-1,1),
                                     forwInterfaceAvg,axis=3)
        forwPrimVarState = np.append(backInterfaceAvg,
                                     backInterfaceAvg[:,:,:,0].reshape(7,backInterfaceAvg.shape[1],-1,1),
                                     axis=3)

    #Return the reconstructed back and forward states
    return backPrimVarState, forwPrimVarState

######2D RECONSTRUCTED MAGNETIC FIELD SOURCE TERM FUNCTIONS######

#Function:getByReconSourceTerms_2D
#Purpose: Calculates the source terms that should be added to
#         reconstructed By values in a 2D simulation, using the
#         formulas from [2,3,5].
#Input Parameters: vy (the cell-centred y-velocities for the entire simulation grid)
#                  faceBx (the face-centred Bx values for the entire simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dx (the cell width/size of the cell in the x-direction)
#                  BcX (integer for the boundary condition in the x-direction
#                       (0 = outflow and 1 = periodic))
#Outputs: ByCorrections (the source terms for all reconstructed By values)
def getByReconSourceTerms_2D(vy,faceBx,dt,dx,BcX):
    invDx = 1.0/dx
    halfDt = 0.5*dt
    if BcX == constants.OUTFLOW:
        leftVy = np.append(vy[:,0].reshape(-1,1),vy,axis=1)
        rightVy = np.append(vy,vy[:,vy.shape[1]-1].reshape(-1,1),axis=1)
        leftFaceBx = np.append(faceBx[:,0].reshape(-1,1),faceBx[:,0:faceBx.shape[1]-1],axis=1)
        rightFaceBx = np.append(faceBx[:,1:faceBx.shape[1]],faceBx[:,faceBx.shape[1]-1].reshape(-1, 1),axis=1)
    else:
        leftVy = np.append(vy[:,vy.shape[1]-1].reshape(-1,1),vy,axis=1)
        rightVy = np.append(vy,vy[:,0].reshape(-1,1),axis=1)
        leftFaceBx = np.append(faceBx[:,faceBx.shape[1]-2].reshape(-1,1),faceBx[:,0:faceBx.shape[1]-1],axis=1)
        rightFaceBx = np.append(faceBx[:,1:faceBx.shape[1]],faceBx[:,1].reshape(-1,1),axis=1)
    ByCorrections = np.zeros(shape=(2,faceBx.shape[0],faceBx.shape[1]))
    ByCorrections[0] = halfDt*leftVy*((faceBx-leftFaceBx)*invDx)
    ByCorrections[1] = halfDt*rightVy*((rightFaceBx-faceBx)*invDx)
    return ByCorrections

#Function:getBxReconSourceTerms_2D
#Purpose: Calculates the source terms that should be added to
#         reconstructed Bx values in a 2D simulation, using the
#         formulas from [2,3,5].
#Input Parameters: vx (the cell-centred x-velocities for the entire simulation grid)
#                  faceBy (the face-centred By values for the entire simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dy (the cell height/size of the cell in the y-direction)
#                  BcY (integer for the boundary condition in the y-direction
#                       (0 = outflow and 1 = periodic))
#Outputs: BxCorrections (the source terms for all reconstructed Bx values)
def getBxReconSourceTerms_2D(vx,faceBy,dt,dy,BcY):
    invDy = 1.0/dy
    halfDt = 0.5*dt
    if BcY == constants.OUTFLOW:
        topVx = np.append(vx[0,:].reshape(1,-1),vx,axis=0)
        bottomVx = np.append(vx,vx[vx.shape[0]-1,:].reshape(1,-1),axis=0)
        topFaceBy = np.append(faceBy[0,:].reshape(1,-1),faceBy[0:faceBy.shape[0]-1,:],axis=0)
        bottomFaceBy = np.append(faceBy[1:faceBy.shape[0]],faceBy[faceBy.shape[0]-1,:].reshape(1,-1),axis=0)
    else:
        topVx = np.append(vx[vx.shape[0]-1,:].reshape(1,-1),vx,axis=0)
        bottomVx = np.append(vx,vx[0,:].reshape(1,-1),axis=0)
        topFaceBy = np.append(faceBy[faceBy.shape[0]-2,:].reshape(1,-1),faceBy[0:faceBy.shape[0]-1,:],axis=0)
        bottomFaceBy = np.append(faceBy[1:faceBy.shape[0],:],faceBy[1,:].reshape(1,-1),axis=0)
    BxCorrections = np.zeros(shape=(2,faceBy.shape[0],faceBy.shape[1]))
    BxCorrections[0] = halfDt*topVx*((faceBy-topFaceBy)*invDy)
    BxCorrections[1] = halfDt*bottomVx*((bottomFaceBy-faceBy)*invDy)
    return BxCorrections

######3D RECONSTRUCTED MAGNETIC FIELD SOURCE TERM FUNCTIONS######
#
# def oldGetReconBCorrectionsX_3D(momY,momZ,dens,faceBx,faceBy,faceBz,dt,dx,dy,dz,BcX):
#     invDx = 1.0/dx
#     invDy = 1.0/dy
#     invDz = 1.0/dz
#     vy = momY/dens
#     vz = momZ/dens
#     halfDt = 0.5*dt
#     if BcX == constants.OUTFLOW:
#         leftVy = np.append(vy[:,0,:].reshape(vy.shape[0],1,-1),vy,axis=1)
#         rightVy = np.append(vy,vy[:,vy.shape[1]-1,:].reshape(vy.shape[0],1,-1),axis=1)
#         leftVz = np.append(vz[:,0,:].reshape(vz.shape[0],1,-1),vz,axis=1)
#         rightVz = np.append(vz,vz[:,vz.shape[1]-1,:].reshape(vz.shape[0],1,-1),axis=1)
#         leftFaceBx = np.append(faceBx[:,0,:].reshape(faceBx.shape[0],1,-1),faceBx[:,0:faceBx.shape[1]-1,:],axis=1)
#         rightFaceBx = np.append(faceBx[:,1:faceBx.shape[1],:],faceBx[:,faceBx.shape[1]-1,:].reshape(faceBx.shape[0],1,-1),axis=1)
#         leftFaceBy = np.append(faceBy[:,0,:].reshape(faceBy.shape[0],1,-1),faceBy,axis=1)
#         rightFaceBy = np.append(faceBy,faceBy[:,faceBy.shape[1]-1,:].reshape(faceBy.shape[0],1,-1),axis=1)
#         leftFaceBz = np.append(faceBz[:,0,:].reshape(faceBz.shape[0],1,-1),faceBz,axis=1)
#         rightFaceBz = np.append(faceBz,faceBz[:,faceBz.shape[1]-1,:].reshape(faceBz.shape[0],1,-1),axis=1)
#     else:
#         leftVy = np.append(vy[:,vy.shape[1]-1,:].reshape(vy.shape[0],1,-1),vy,axis=1)
#         rightVy = np.append(vy,vy[:,0,:].reshape(vy.shape[0],1,-1),axis=1)
#         leftVz = np.append(vz[:,vz.shape[1]-1,:].reshape(vz.shape[0],1,-1),vz,axis=1)
#         rightVz = np.append(vz,vz[:,0,:].reshape(vz.shape[0],1,-1),axis=1)
#         leftFaceBx = np.append(faceBx[:,faceBx.shape[1]-2,:].reshape(faceBx.shape[0],1,-1),
#                                faceBx[:,0:faceBx.shape[1]-1,:],axis=1)
#         rightFaceBx = np.append(faceBx[:,1:faceBx.shape[1],:],
#                                 faceBx[:,1].reshape(faceBx.shape[0],1,-1),axis=1)
#         leftFaceBy = np.append(faceBy[:,faceBy.shape[1]-1,:].reshape(faceBy.shape[0],1,-1),faceBy,axis=1)
#         rightFaceBy = np.append(faceBy,faceBy[:,0,:].reshape(faceBy.shape[0],1,-1),axis=1)
#         leftFaceBz = np.append(faceBz[:,0,:].reshape(faceBz.shape[0],1,-1),faceBz,axis=1)
#         rightFaceBz = np.append(faceBz,faceBz[:,0,:].reshape(faceBz.shape[0],1,-1),axis=1)
#     lowerLeftFaceBy = leftFaceBy[1:leftFaceBy.shape[0]]
#     leftFaceBy = leftFaceBy[0:leftFaceBy.shape[0]-1]
#     lowerRightFaceBy = rightFaceBy[1:rightFaceBy.shape[0]]
#     rightFaceBy = rightFaceBy[0:rightFaceBy.shape[0]-1]
#     forwLeftFaceBz = leftFaceBz[:,:,1:leftFaceBz.shape[2]]
#     leftFaceBz = leftFaceBz[:,:,0:leftFaceBz.shape[2]-1]
#     forwRightFaceBz = rightFaceBz[:,:,1:rightFaceBz.shape[2]]
#     rightFaceBz = rightFaceBz[:,:,0:rightFaceBz.shape[2]-1]
#     leftBxChange = (faceBx - leftFaceBx)*invDx
#     leftByChange = (lowerLeftFaceBy - leftFaceBy)*invDy
#     leftBzChange = (forwLeftFaceBz - leftFaceBz)*invDz
#     posLeftBxChange = leftBxChange >= 0.0
#     negLeftBxChange = np.logical_not(posLeftBxChange)
#     leftBxLessThanNegBy = leftBxChange < -1.0*leftByChange
#     leftBxMoreThanNegBy = leftBxChange > -1.0*leftByChange
#     posLeftBxCase_y = np.logical_and(posLeftBxChange,leftBxLessThanNegBy)
#     posLeftByCase_y = np.logical_and(posLeftBxChange,np.logical_not(leftBxLessThanNegBy))
#     negLeftBxCase_y = np.logical_and(negLeftBxChange, leftBxMoreThanNegBy)
#     negLeftByCase_y = np.logical_and(negLeftBxChange, np.logical_not(leftBxMoreThanNegBy))
#     leftChangeTermY = np.zeros(shape=leftByChange.shape)
#     leftChangeTermY[posLeftBxCase_y] = leftBxChange[posLeftBxCase_y]
#     leftChangeTermY[posLeftByCase_y] = -leftByChange[posLeftByCase_y]
#     leftChangeTermY[np.logical_and(posLeftBxChange, leftChangeTermY < 0.0)] = 0.0
#     leftChangeTermY[negLeftBxCase_y] = leftBxChange[negLeftBxCase_y]
#     leftChangeTermY[negLeftByCase_y] = -leftByChange[negLeftByCase_y]
#     leftChangeTermY[np.logical_and(negLeftBxChange, leftChangeTermY > 0.0)] = 0.0
#     leftBxLessThanNegBz = leftBxChange < -leftBzChange
#     leftBxMoreThanNegBz = leftBxChange > -leftBzChange
#     posLeftBxCase_z = np.logical_and(posLeftBxChange, leftBxLessThanNegBz)
#     posLeftBzCase_z = np.logical_and(posLeftBxChange, np.logical_not(leftBxLessThanNegBz))
#     negLeftBxCase_z = np.logical_and(negLeftBxChange, leftBxMoreThanNegBz)
#     negLeftBzCase_z = np.logical_and(negLeftBxChange, np.logical_not(leftBxMoreThanNegBz))
#     leftChangeTermZ = np.zeros(shape=leftBzChange.shape)
#     leftChangeTermZ[posLeftBxCase_z] = leftBxChange[posLeftBxCase_z]
#     leftChangeTermZ[posLeftBzCase_z] = -leftBzChange[posLeftBzCase_z]
#     leftChangeTermZ[np.logical_and(posLeftBxChange, leftChangeTermZ < 0.0)] = 0.0
#     leftChangeTermZ[negLeftBxCase_z] = leftBxChange[negLeftBxCase_z]
#     leftChangeTermZ[negLeftBzCase_z] = -leftBzChange[negLeftBzCase_z]
#     leftChangeTermZ[np.logical_and(negLeftBxChange, leftChangeTermZ > 0.0)] = 0.0
#     BCorrections = np.zeros(shape=(2,2,faceBx.shape[0],faceBx.shape[1],faceBx.shape[2]))
#     BCorrections[0,0] = halfDt*leftVy*leftChangeTermY
#     BCorrections[0,1] = halfDt*leftVz*leftChangeTermZ
#     rightBxChange = (rightFaceBx - faceBx)*invDx
#     rightByChange = (lowerRightFaceBy - rightFaceBy)*invDy
#     rightBzChange = (forwRightFaceBz - rightFaceBz)*invDz
#     posRightBxChange = rightBxChange >= 0.0
#     negRightBxChange = np.logical_not(posRightBxChange)
#     rightBxLessThanNegBy = rightBxChange < -rightByChange
#     rightBxMoreThanNegBy = rightBxChange > -rightByChange
#     posRightBxCase_y = np.logical_and(posRightBxChange,rightBxLessThanNegBy)
#     posRightByCase_y = np.logical_and(posRightBxChange,np.logical_not(rightBxLessThanNegBy))
#     negRightBxCase_y = np.logical_and(negRightBxChange, rightBxMoreThanNegBy)
#     negRightByCase_y = np.logical_and(negRightBxChange, np.logical_not(rightBxMoreThanNegBy))
#     rightChangeTermY = np.zeros(shape=rightByChange.shape)
#     rightChangeTermZ = np.zeros(shape=rightBzChange.shape)
#     rightChangeTermY[posRightBxCase_y] = rightBxChange[posRightBxCase_y]
#     rightChangeTermY[posRightByCase_y] = -rightByChange[posRightByCase_y]
#     rightChangeTermY[np.logical_and(posRightBxChange, rightChangeTermY < 0.0)] = 0.0
#     rightChangeTermY[negRightBxCase_y] = rightBxChange[negRightBxCase_y]
#     rightChangeTermY[negRightByCase_y] = -rightByChange[negRightByCase_y]
#     rightChangeTermY[np.logical_and(negRightBxChange, rightChangeTermY > 0.0)] = 0.0
#     rightBxLessThanNegBz = rightBxChange < -rightBzChange
#     rightBxMoreThanNegBz = rightBxChange > -rightBzChange
#     posRightBxCase_z = np.logical_and(posRightBxChange, rightBxLessThanNegBz)
#     posRightBzCase_z = np.logical_and(posRightBxChange, np.logical_not(rightBxLessThanNegBz))
#     negRightBxCase_z = np.logical_and(negRightBxChange, rightBxMoreThanNegBz)
#     negRightBzCase_z = np.logical_and(negRightBxChange, np.logical_not(rightBxMoreThanNegBz))
#     rightChangeTermZ[posRightBxCase_z] = rightBxChange[posRightBxCase_z]
#     rightChangeTermZ[posRightBzCase_z] = -rightBzChange[posRightBzCase_z]
#     rightChangeTermZ[np.logical_and(posRightBxChange, rightChangeTermZ < 0.0)] = 0.0
#     rightChangeTermZ[negRightBxCase_z] = rightBxChange[negRightBxCase_z]
#     rightChangeTermZ[negRightBzCase_z] = -rightBzChange[negRightBzCase_z]
#     rightChangeTermZ[np.logical_and(negRightBxChange, rightChangeTermZ > 0.0)] = 0.0
#     BCorrections[1,0] = halfDt*rightVy*rightChangeTermY
#     BCorrections[1,1] = halfDt*rightVz*rightChangeTermZ
#     return BCorrections

def getReconBCorrectionsX_3D(momY,momZ,dens,faceBx,faceBy,faceBz,dt,dx,dy,dz,BcX):
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    vy = momY/dens
    vz = momZ/dens
    halfDt = 0.5*dt
    if BcX == constants.OUTFLOW:
        expandedVy = np.append(vy[:,0,:].reshape(vy.shape[0],1,-1),vy,axis=1)
        expandedVy = np.append(expandedVy,vy[:,vy.shape[1]-1,:].reshape(vy.shape[0],1,-1),axis=1)
        expandedVz = np.append(vz[:,0,:].reshape(vz.shape[0],1,-1),vz,axis=1)
        expandedVz = np.append(expandedVz,vz[:,vz.shape[1]-1,:].reshape(vz.shape[0],1,-1),axis=1)
        expandedFaceBx = np.append(faceBx[:,0,:].reshape(faceBx.shape[0],1,-1),
                                   faceBx,axis=1)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[:,faceBx.shape[1]-1,:].reshape(faceBx.shape[0],1,-1),axis=1)
        expandedFaceBy = np.append(faceBy[:,0,:].reshape(faceBy.shape[0],1,-1),
                                   faceBy,axis=1)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[:,faceBy.shape[1]-1,:].reshape(faceBy.shape[0],1,-1),axis=1)
        expandedFaceBz = np.append(faceBz[:,0,:].reshape(faceBz.shape[0],1,-1),
                                   faceBz,axis=1)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[:,faceBz.shape[1]-1,:].reshape(faceBz.shape[0],1,-1),axis=1)
    else:
        expandedVy = np.append(vy[:,vy.shape[1]-1,:].reshape(vy.shape[0],1,-1),vy,axis=1)
        expandedVy = np.append(expandedVy,vy[:,0,:].reshape(vy.shape[0],1,-1),axis=1)
        expandedVz = np.append(vz[:,vz.shape[1]-1,:].reshape(vz.shape[0],1,-1),vz,axis=1)
        expandedVz = np.append(expandedVz,vz[:,0,:].reshape(vz.shape[0],1,-1),axis=1)
        expandedFaceBx = np.append(faceBx[:,faceBx.shape[1]-2,:].reshape(faceBx.shape[0],1,-1),
                                   faceBx,axis=1)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[:,1,:].reshape(faceBx.shape[0],1,-1),axis=1)
        expandedFaceBy = np.append(faceBy[:,faceBy.shape[1]-1,:].reshape(faceBy.shape[0],1,-1),
                                   faceBy,axis=1)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[:,0,:].reshape(faceBy.shape[0],1,-1),axis=1)
        expandedFaceBz = np.append(faceBz[:,faceBz.shape[1]-1,:].reshape(faceBz.shape[0],1,-1),
                                   faceBz,axis=1)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[:,0,:].reshape(faceBz.shape[0],1,-1),axis=1)
    BxChanges = (expandedFaceBx[:,1:expandedFaceBx.shape[1],:]
                 -expandedFaceBx[:,0:expandedFaceBx.shape[1]-1,:])*invDx
    ByChanges = (expandedFaceBy[1:expandedFaceBy.shape[0],:,:]
                 -expandedFaceBy[0:expandedFaceBy.shape[0]-1,:,:])*invDy
    BzChanges = (expandedFaceBz[:,:,1:expandedFaceBz.shape[2]]
                 -expandedFaceBz[:,:,0:expandedFaceBz.shape[2]-1])*invDz
    posBxChange = BxChanges >= 0.0
    negBxChange = np.logical_not(posBxChange)
    BxLessThanNegBy = BxChanges < -ByChanges
    BxMoreThanNegBy = BxChanges > -ByChanges
    posBxCase_y = np.logical_and(posBxChange,BxLessThanNegBy)
    posByCase_y = np.logical_and(posBxChange,np.logical_not(BxLessThanNegBy))
    negBxCase_y = np.logical_and(negBxChange, BxMoreThanNegBy)
    negByCase_y = np.logical_and(negBxChange, np.logical_not(BxMoreThanNegBy))
    changeTermY = np.zeros(shape=ByChanges.shape)
    changeTermY[posBxCase_y] = BxChanges[posBxCase_y]
    changeTermY[posByCase_y] = -ByChanges[posByCase_y]
    changeTermY[np.logical_and(posBxChange, changeTermY < 0.0)] = 0.0
    changeTermY[negBxCase_y] = BxChanges[negBxCase_y]
    changeTermY[negByCase_y] = -ByChanges[negByCase_y]
    changeTermY[np.logical_and(negBxChange, changeTermY > 0.0)] = 0.0
    BxLessThanNegBz = BxChanges < -BzChanges
    BxMoreThanNegBz = BxChanges > -BzChanges
    posBxCase_z = np.logical_and(posBxChange, BxLessThanNegBz)
    posBzCase_z = np.logical_and(posBxChange, np.logical_not(BxLessThanNegBz))
    negBxCase_z = np.logical_and(negBxChange, BxMoreThanNegBz)
    negBzCase_z = np.logical_and(negBxChange, np.logical_not(BxMoreThanNegBz))
    changeTermZ = np.zeros(shape=BzChanges.shape)
    changeTermZ[posBxCase_z] = BxChanges[posBxCase_z]
    changeTermZ[posBzCase_z] = -BzChanges[posBzCase_z]
    changeTermZ[np.logical_and(posBxChange, changeTermZ < 0.0)] = 0.0
    changeTermZ[negBxCase_z] = BxChanges[negBxCase_z]
    changeTermZ[negBzCase_z] = -BzChanges[negBzCase_z]
    changeTermZ[np.logical_and(negBxChange, changeTermZ > 0.0)] = 0.0
    BCorrections = np.zeros(shape=(2,2,faceBx.shape[0],faceBx.shape[1],faceBx.shape[2]))
    ySourceTerms = expandedVy*changeTermY
    zSourceTerms = expandedVz*changeTermZ
    BCorrections[0,0] = halfDt*ySourceTerms[:,0:ySourceTerms.shape[1]-1,:]
    BCorrections[0,1] = halfDt*zSourceTerms[:,0:zSourceTerms.shape[1]-1,:]
    BCorrections[1,0] = halfDt*ySourceTerms[:,1:ySourceTerms.shape[1],:]
    BCorrections[1,1] = halfDt*zSourceTerms[:,1:zSourceTerms.shape[1],:]
    return BCorrections

def oldGetReconBCorrectionsY_3D(momX,momZ,dens,faceBy,faceBx,faceBz,dt,dy,dx,dz,BcY):
    vx = momX/dens
    vz = momZ/dens
    halfDt = 0.5*dt
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    if BcY == constants.OUTFLOW:
        topVx = np.append(vx[0,:,:].reshape(1,vx.shape[1],-1),vx,axis=0)
        bottomVx = np.append(vx,vx[vx.shape[0]-1,:,:].reshape(1,vx.shape[1],-1),axis=0)
        topVz = np.append(vz[0,:,:].reshape(1,vz.shape[1],-1),vz,axis=0)
        bottomVz = np.append(vz,vz[vz.shape[0]-1,:,:].reshape(1,vz.shape[1],-1),axis=0)
        topFaceBy = np.append(faceBy[0,:,:].reshape(1,faceBy.shape[1],-1),faceBy[0:faceBy.shape[0]-1,:],axis=0)
        bottomFaceBy = np.append(faceBy[1:faceBy.shape[0],:,:],
                                 faceBy[faceBy.shape[0]-1,:,:].reshape(1,faceBy.shape[1],-1),axis=0)
        topFaceBx = np.append(faceBx[0,:,:].reshape(1,faceBx.shape[1],-1),faceBx,axis=0)
        topFaceBz = np.append(faceBz[0,:,:].reshape(1,faceBz.shape[1],-1),faceBz,axis=0)
        bottomFaceBx = np.append(faceBx,faceBx[faceBx.shape[0]-1,:,:].reshape(1,faceBx.shape[1],-1),axis=0)
        bottomFaceBz = np.append(faceBz,faceBz[faceBz.shape[0]-1,:,:].reshape(1,faceBz.shape[1],-1),axis=0)
    else:
        topVx = np.append(vx[vx.shape[0]-1,:,:].reshape(1,vx.shape[1],-1),vx,axis=0)
        bottomVx = np.append(vx,vx[0,:,:].reshape(1,vx.shape[1],-1),axis=0)
        topVz = np.append(vz[vz.shape[0]-1,:,:].reshape(1,vz.shape[1],-1),vz,axis=0)
        bottomVz = np.append(vz,vz[0,:,:].reshape(1,vz.shape[1],-1),axis=0)
        topFaceBy = np.append(faceBy[faceBy.shape[0]-2,:,:].reshape(1,faceBy.shape[1],-1),
                              faceBy[0:faceBy.shape[0]-1,:,:],axis=0)
        bottomFaceBy = np.append(faceBy[1:faceBy.shape[0],:,:],faceBy[1,:,:].reshape(1,faceBy.shape[1],-1),axis=0)
        topFaceBx = np.append(faceBx[faceBx.shape[0]-1,:,:].reshape(1,faceBx.shape[1],-1),faceBx,axis=0)
        topFaceBz = np.append(faceBz[faceBz.shape[0]-1,:,:].reshape(1,faceBz.shape[1],-1),faceBz,axis=0)
        bottomFaceBx = np.append(faceBx,faceBx[0,:,:].reshape(1,faceBx.shape[1],-1),axis=0)
        bottomFaceBz = np.append(faceBz,faceBz[0,:,:].reshape(1,faceBz.shape[1],-1),axis=0)
    rightTopFaceBx = topFaceBx[:,1:topFaceBx.shape[1],:]
    topFaceBx = topFaceBx[:,0:topFaceBx.shape[1]-1,:]
    rightBottomFaceBx = bottomFaceBx[:,1:bottomFaceBx.shape[1],:]
    bottomFaceBx = bottomFaceBx[:,0:bottomFaceBx.shape[1]-1,:]
    forwTopFaceBz = topFaceBz[:,:,1:topFaceBz.shape[2]]
    topFaceBz = topFaceBz[:,:,0:topFaceBz.shape[2]-1]
    forwBottomFaceBz = bottomFaceBz[:,:,1:bottomFaceBz.shape[2]]
    bottomFaceBz = bottomFaceBz[:,:,0:bottomFaceBz.shape[2]-1]
    topBxChange = (rightTopFaceBx - topFaceBx)*invDx
    topByChange = (faceBy - topFaceBy)*invDy
    topBzChange = (forwTopFaceBz - topFaceBz)*invDz
    posTopByChange = topByChange >= 0.0
    negTopByChange = np.logical_not(posTopByChange)
    topByLessThanNegBx = topByChange < -1.0 * topBxChange
    topByMoreThanNegBx = topByChange > -1.0 * topBxChange
    posTopByCase_x = np.logical_and(posTopByChange, topByLessThanNegBx)
    posTopBxCase_x = np.logical_and(posTopByChange, np.logical_not(topByLessThanNegBx))
    negTopByCase_x = np.logical_and(negTopByChange, topByMoreThanNegBx)
    negTopBxCase_x = np.logical_and(negTopByChange, np.logical_not(topByMoreThanNegBx))
    topChangeTermX = np.zeros(shape=topByChange.shape)
    topChangeTermZ = np.zeros(shape=topBzChange.shape)
    topChangeTermX[posTopByCase_x] = topByChange[posTopByCase_x]
    topChangeTermX[posTopBxCase_x] = -topBxChange[posTopBxCase_x]
    topChangeTermX[np.logical_and(posTopByChange, topChangeTermX < 0.0)] = 0.0
    topChangeTermX[negTopByCase_x] = topByChange[negTopByCase_x]
    topChangeTermX[negTopBxCase_x] = -topBxChange[negTopBxCase_x]
    topChangeTermX[np.logical_and(negTopByChange, topChangeTermX > 0.0)] = 0.0
    topByLessThanNegBz = topByChange < -1.0 * topBzChange
    topByMoreThanNegBz = topByChange > -1.0 * topBzChange
    posTopByCase_z = np.logical_and(posTopByChange, topByLessThanNegBz)
    posTopBzCase_z = np.logical_and(posTopByChange, np.logical_not(topByLessThanNegBz))
    negTopByCase_z = np.logical_and(negTopByChange, topByMoreThanNegBz)
    negTopBzCase_z = np.logical_and(negTopByChange, np.logical_not(topByMoreThanNegBz))
    topChangeTermZ[posTopByCase_z] = topByChange[posTopByCase_z]
    topChangeTermZ[posTopBzCase_z] = -topBzChange[posTopBzCase_z]
    topChangeTermZ[np.logical_and(posTopByChange, topChangeTermZ < 0.0)] = 0.0
    topChangeTermZ[negTopByCase_z] = topByChange[negTopByCase_z]
    topChangeTermZ[negTopBzCase_z] = -topBzChange[negTopBzCase_z]
    topChangeTermZ[np.logical_and(negTopByChange, topChangeTermZ > 0.0)] = 0.0
    BCorrections = np.zeros(shape=(2,2,faceBy.shape[0],faceBy.shape[1],faceBy.shape[2]))
    BCorrections[0,0] = halfDt*topVz*topChangeTermZ
    BCorrections[0,1] = halfDt*topVx*topChangeTermX
    bottomBxChange = (rightBottomFaceBx - bottomFaceBx)*invDx
    bottomByChange = (bottomFaceBy - faceBy)*invDy
    bottomBzChange = (forwBottomFaceBz - bottomFaceBz)*invDz
    posBottomByChange = bottomByChange >= 0.0
    negBottomByChange = np.logical_not(posBottomByChange)
    bottomByLessThanNegBx = bottomByChange < -1.0 * bottomBxChange
    bottomByMoreThanNegBx = bottomByChange > -1.0 * bottomBxChange
    posBottomByCase_x = np.logical_and(posBottomByChange, bottomByLessThanNegBx)
    posBottomBxCase_x = np.logical_and(posBottomByChange, np.logical_not(bottomByLessThanNegBx))
    negBottomByCase_x = np.logical_and(negBottomByChange, bottomByMoreThanNegBx)
    negBottomBxCase_x = np.logical_and(negBottomByChange, np.logical_not(bottomByMoreThanNegBx))
    bottomChangeTermX = np.zeros(shape=bottomByChange.shape)
    bottomChangeTermZ = np.zeros(shape=bottomBzChange.shape)
    bottomChangeTermX[posBottomByCase_x] = bottomByChange[posBottomByCase_x]
    bottomChangeTermX[posBottomBxCase_x] = -bottomBxChange[posBottomBxCase_x]
    bottomChangeTermX[np.logical_and(posBottomByChange, bottomChangeTermX < 0.0)] = 0.0
    bottomChangeTermX[negBottomByCase_x] = bottomByChange[negBottomByCase_x]
    bottomChangeTermX[negBottomBxCase_x] = -bottomBxChange[negBottomBxCase_x]
    bottomChangeTermX[np.logical_and(negBottomByChange, bottomChangeTermX > 0.0)] = 0.0
    bottomByLessThanNegBz = bottomByChange < -1.0 * bottomBzChange
    bottomByMoreThanNegBz = bottomByChange > -1.0 * bottomBzChange
    posBottomByCase_z = np.logical_and(posBottomByChange, bottomByLessThanNegBz)
    posBottomBzCase_z = np.logical_and(posBottomByChange, np.logical_not(bottomByLessThanNegBz))
    negBottomByCase_z = np.logical_and(negBottomByChange, bottomByMoreThanNegBz)
    negBottomBzCase_z = np.logical_and(negBottomByChange, np.logical_not(bottomByMoreThanNegBz))
    bottomChangeTermZ[posBottomByCase_z] = bottomByChange[posBottomByCase_z]
    bottomChangeTermZ[posBottomBzCase_z] = -bottomBzChange[posBottomBzCase_z]
    bottomChangeTermZ[np.logical_and(posBottomByChange, bottomChangeTermZ < 0.0)] = 0.0
    bottomChangeTermZ[negBottomByCase_z] = bottomByChange[negBottomByCase_z]
    bottomChangeTermZ[negBottomBzCase_z] = -bottomBzChange[negBottomBzCase_z]
    bottomChangeTermZ[np.logical_and(negBottomByChange, bottomChangeTermZ > 0.0)] = 0.0
    BCorrections[1,0] = halfDt*bottomVz*bottomChangeTermZ
    BCorrections[1,1] = halfDt*bottomVx*bottomChangeTermX
    return BCorrections

def getReconBCorrectionsY_3D(momX,momZ,dens,faceBx,faceBy,faceBz,dt,dx,dy,dz,BcY):
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    vx = momX/dens
    vz = momZ/dens
    halfDt = 0.5*dt
    if BcY == constants.OUTFLOW:
        expandedVx = np.append(vx[0,:,].reshape(1,vx.shape[1],-1),vx,axis=0)
        expandedVx = np.append(expandedVx,vx[vx.shape[0]-1,:,:].reshape(1,vx.shape[1],-1),axis=0)
        expandedVz = np.append(vz[0,:,:].reshape(1,vz.shape[1],-1),vz,axis=0)
        expandedVz = np.append(expandedVz,vz[vz.shape[0]-1,:,:].reshape(1,vz.shape[1],-1),axis=0)
        expandedFaceBy = np.append(faceBy[0,:,:].reshape(1,faceBy.shape[1],-1),
                                   faceBy,axis=0)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[faceBy.shape[0]-1,:,:].reshape(1,faceBy.shape[1],-1),axis=0)
        expandedFaceBx = np.append(faceBx[0,:,:].reshape(1,faceBx.shape[1],-1),
                                   faceBx,axis=0)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[faceBx.shape[0]-1,:,:].reshape(1,faceBx.shape[1],-1),axis=0)
        expandedFaceBz = np.append(faceBz[0,:,:].reshape(1,faceBz.shape[1],-1),
                                   faceBz,axis=0)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[faceBz.shape[0]-1,:,:].reshape(1,faceBz.shape[1],-1),axis=0)
    else:
        expandedVx = np.append(vx[vx.shape[0]-1,:,].reshape(1,vx.shape[1],-1),vx,axis=0)
        expandedVx = np.append(expandedVx,vx[0,:,:].reshape(1,vx.shape[1],-1),axis=0)
        expandedVz = np.append(vz[vz.shape[0]-1,:,:].reshape(1,vz.shape[1],-1),vz,axis=0)
        expandedVz = np.append(expandedVz,vz[0,:,:].reshape(1,vz.shape[1],-1),axis=0)
        expandedFaceBy = np.append(faceBy[faceBy.shape[0]-2,:,:].reshape(1,faceBy.shape[1],-1),
                                   faceBy,axis=0)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[1,:,:].reshape(1,faceBy.shape[1],-1),axis=0)
        expandedFaceBx = np.append(faceBx[faceBx.shape[0]-1,:,:].reshape(1,faceBx.shape[1],-1),
                                   faceBx,axis=0)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[0,:,:].reshape(1,faceBx.shape[1],-1),axis=0)
        expandedFaceBz = np.append(faceBz[faceBz.shape[0]-1,:,:].reshape(1,faceBz.shape[1],-1),
                                   faceBz,axis=0)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[0,:,:].reshape(1,faceBz.shape[1],-1),axis=0)
    BxChanges = (expandedFaceBx[:,1:expandedFaceBx.shape[1],:]
                 -expandedFaceBx[:,0:expandedFaceBx.shape[1]-1,:])*invDx
    ByChanges = (expandedFaceBy[1:expandedFaceBy.shape[0],:,:]
                 -expandedFaceBy[0:expandedFaceBy.shape[0]-1,:,:])*invDy
    BzChanges = (expandedFaceBz[:,:,1:expandedFaceBz.shape[2]]
                 -expandedFaceBz[:,:,0:expandedFaceBz.shape[2]-1])*invDz
    posByChange = ByChanges >= 0.0
    negByChange = np.logical_not(posByChange)
    ByLessThanNegBx = ByChanges < -BxChanges
    ByMoreThanNegBx = ByChanges > -BxChanges
    posByCase_x = np.logical_and(posByChange,ByLessThanNegBx)
    posBxCase_x = np.logical_and(posByChange,np.logical_not(ByLessThanNegBx))
    negByCase_x = np.logical_and(negByChange, ByMoreThanNegBx)
    negBxCase_x = np.logical_and(negByChange, np.logical_not(ByMoreThanNegBx))
    changeTermX = np.zeros(shape=BxChanges.shape)
    changeTermX[posByCase_x] = ByChanges[posByCase_x]
    changeTermX[posBxCase_x] = -BxChanges[posBxCase_x]
    changeTermX[np.logical_and(posByChange, changeTermX < 0.0)] = 0.0
    changeTermX[negByCase_x] = ByChanges[negByCase_x]
    changeTermX[negBxCase_x] = -BxChanges[negBxCase_x]
    changeTermX[np.logical_and(negByChange, changeTermX > 0.0)] = 0.0
    ByLessThanNegBz = ByChanges < -BzChanges
    ByMoreThanNegBz = ByChanges > -BzChanges
    posByCase_z = np.logical_and(posByChange, ByLessThanNegBz)
    posBzCase_z = np.logical_and(posByChange, np.logical_not(ByLessThanNegBz))
    negByCase_z = np.logical_and(negByChange, ByMoreThanNegBz)
    negBzCase_z = np.logical_and(negByChange, np.logical_not(ByMoreThanNegBz))
    changeTermZ = np.zeros(shape=BzChanges.shape)
    changeTermZ[posByCase_z] = ByChanges[posByCase_z]
    changeTermZ[posBzCase_z] = -BzChanges[posBzCase_z]
    changeTermZ[np.logical_and(posBzCase_z,BzChanges == 0.0)] = 0.0
    changeTermZ[np.logical_and(posByChange, changeTermZ < 0.0)] = 0.0
    changeTermZ[negByCase_z] = ByChanges[negByCase_z]
    changeTermZ[negBzCase_z] = -BzChanges[negBzCase_z]
    changeTermZ[np.logical_and(negBzCase_z, BzChanges == 0.0)] = 0.0
    changeTermZ[np.logical_and(negByChange, changeTermZ > 0.0)] = 0.0
    BCorrections = np.zeros(shape=(2,2,faceBy.shape[0],faceBy.shape[1],faceBy.shape[2]))
    xSourceTerms = expandedVx*changeTermX
    zSourceTerms = expandedVz*changeTermZ
    BCorrections[0,0] = halfDt*zSourceTerms[0:zSourceTerms.shape[0]-1,:,:]
    BCorrections[0,1] = halfDt*xSourceTerms[0:zSourceTerms.shape[0]-1,:,:]
    BCorrections[1,0] = halfDt*zSourceTerms[1:xSourceTerms.shape[0],:,:]
    BCorrections[1,1] = halfDt*xSourceTerms[1:xSourceTerms.shape[0],:,:]
    return BCorrections

def oldGetReconBCorrectionsZ_3D(momX,momY,dens,faceBx,faceBy,faceBz,dt,dx,dy,dz,BcX):
    vx = momX/dens
    vy = momY/dens
    halfDt = 0.5*dt
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    if BcX == constants.OUTFLOW:
        backVx = np.append(vx[:,:,0].reshape(vx.shape[0],-1,1),vx,axis=2)
        forwVx = np.append(vx,vx[:,:,vx.shape[2]-1].reshape(vx.shape[0],-1,1),axis=2)
        backVy = np.append(vy[:,:,0].reshape(vy.shape[0],-1,1),vy,axis=2)
        forwVy = np.append(vy,vy[:,:,vy.shape[2]-1].reshape(vy.shape[0],-1,1),axis=2)
        backFaceBz = np.append(faceBz[:,:,0].reshape(faceBz.shape[0],-1,1),faceBz[:,:,0:faceBz.shape[2]-1],axis=2)
        forwFaceBz = np.append(faceBz[:,:,1:faceBz.shape[2]],
                               faceBz[:,:,faceBz.shape[2]-1].reshape(faceBz.shape[0],-1,1),axis=2)
        backFaceBx = np.append(faceBx[:,:,0].reshape(faceBx.shape[0],-1,1),faceBx,axis=2)
        forwFaceBx = np.append(faceBx,faceBx[:,:,faceBx.shape[2]-1].reshape(faceBx.shape[0],-1,1),axis=2)
        backFaceBy = np.append(faceBy[:,:,0].reshape(faceBy.shape[0],-1,1),faceBy,axis=2)
        forwFaceBy = np.append(faceBy,faceBy[:,:,faceBy.shape[2]-1].reshape(faceBy.shape[0],-1,1),axis=2)
    else:
        backVx = np.append(vx[:,:,vx.shape[2]-1].reshape(vx.shape[0],-1,1),vx,axis=2)
        forwVx = np.append(vx,vx[:,:,0].reshape(vx.shape[0],-1,1),axis=2)
        backVy = np.append(vy[:,:,vx.shape[2]-1].reshape(vy.shape[0],-1,1),vy,axis=2)
        forwVy = np.append(vy,vy[:,:,0].reshape(vy.shape[0],-1,1),axis=2)
        backFaceBz = np.append(faceBz[:,:,faceBz.shape[2]-2].reshape(faceBz.shape[0],-1,1),
                               faceBz[:,:,0:faceBz.shape[2]-1],axis=2)
        forwFaceBz = np.append(faceBz[:,:,1:faceBz.shape[2]],
                               faceBz[:,:,1].reshape(faceBz.shape[0],-1,1),axis=2)
        backFaceBx = np.append(faceBx[:,:,faceBx.shape[2]-1].reshape(faceBx.shape[0],-1,1),faceBx,axis=2)
        forwFaceBx = np.append(faceBx,faceBx[:,:,0].reshape(faceBx.shape[0],-1,1),axis=2)
        backFaceBy = np.append(faceBy[:,:,faceBy.shape[2]-1].reshape(faceBy.shape[0],-1,1),faceBy,axis=2)
        forwFaceBy = np.append(faceBy,faceBy[:,:,0].reshape(faceBy.shape[0],-1,1),axis=2)
    rightBackFaceBx = backFaceBx[:,1:backFaceBx.shape[1],:]
    backFaceBx = backFaceBx[:,0:backFaceBx.shape[1]-1,:]
    rightForwFaceBx = forwFaceBx[:,1:forwFaceBx.shape[1],:]
    forwFaceBx = forwFaceBx[:,0:forwFaceBx.shape[1]-1,:]
    lowerBackFaceBy = backFaceBy[1:backFaceBy.shape[0],:,:]
    backFaceBy = backFaceBy[0:backFaceBy.shape[0]-1,:,:]
    lowerForwFaceBy = forwFaceBy[1:forwFaceBy.shape[0],:,:]
    forwFaceBy = forwFaceBy[0:forwFaceBy.shape[0]-1,:,:]
    backBxChange = (rightBackFaceBx - backFaceBx)*invDx
    backByChange = (lowerBackFaceBy - backFaceBy)*invDy
    backBzChange = (faceBz - backFaceBz)*invDz
    backChangeTermX = np.zeros(shape=backBxChange.shape)
    backChangeTermY = np.zeros(shape=backByChange.shape)
    backChangeTermX[np.logical_and(backBzChange >= 0.0,
                                   backBzChange < -1.0 * backBxChange)] = backBzChange[
        np.logical_and(backBzChange >= 0.0, backBzChange < -1.0 * backBxChange)]
    backChangeTermX[np.logical_and(backBzChange >= 0.0,
                                   backBzChange >= -1.0 * backBxChange)] = -backBxChange[
        np.logical_and(backBzChange >= 0.0, backBzChange >= -1.0 * backBxChange)]
    backChangeTermX[np.logical_and(backBzChange >= 0.0, backChangeTermX < 0.0)] = 0.0
    backChangeTermX[np.logical_and(backBzChange < 0.0,
                                   backBzChange > -1.0 * backBxChange)] = backBzChange[
        np.logical_and(backBzChange < 0.0, backBzChange > -1.0 * backBxChange)]
    backChangeTermX[np.logical_and(backBzChange < 0.0,
                                   backBzChange <= -1.0 * backBxChange)] = -backBxChange[
        np.logical_and(backBzChange < 0.0, backBzChange <= -1.0 * backBxChange)]
    backChangeTermX[np.logical_and(backBzChange < 0.0, backChangeTermX > 0.0)] = 0.0
    backChangeTermY[np.logical_and(backBzChange >= 0.0,
                                   backBzChange < -1.0 * backByChange)] = backBzChange[
        np.logical_and(backBzChange >= 0.0, backBzChange < -1.0 * backByChange)]
    backChangeTermY[np.logical_and(backBzChange >= 0.0,
                                   backBzChange >= -1.0 * backByChange)] = -backByChange[
        np.logical_and(backBzChange >= 0.0, backBzChange >= -1.0 * backByChange)]
    backChangeTermY[np.logical_and(backBzChange >= 0.0, backChangeTermY < 0.0)] = 0.0
    backChangeTermY[np.logical_and(backBzChange < 0.0,
                                   backBzChange > -1.0 * backByChange)] = backBzChange[
        np.logical_and(backBzChange < 0.0, backBzChange > -1.0 * backByChange)]
    backChangeTermY[np.logical_and(backBzChange < 0.0,
                                   backBzChange <= -1.0 * backByChange)] = -backByChange[
        np.logical_and(backBzChange < 0.0, backBzChange <= -1.0 * backByChange)]
    backChangeTermY[np.logical_and(backBzChange < 0.0, backChangeTermY > 0.0)] = 0.0
    BCorrections = np.zeros(shape=(2,2,faceBz.shape[0],faceBz.shape[1],faceBz.shape[2]))
    BCorrections[0,0] = halfDt*backVx*backChangeTermX
    BCorrections[0,1] = halfDt*backVy*backChangeTermY
    forwBxChange = (rightForwFaceBx - forwFaceBx)*invDx
    forwByChange = (lowerForwFaceBy - forwFaceBy)*invDy
    forwBzChange = (forwFaceBz - faceBz)*invDz
    forwChangeTermX = np.zeros(shape=forwBxChange.shape)
    forwChangeTermY = np.zeros(shape=forwByChange.shape)
    forwChangeTermX[np.logical_and(forwBzChange >= 0.0,
                                   forwBzChange < -1.0 * forwBxChange)] = forwBzChange[
        np.logical_and(forwBzChange >= 0.0, forwBzChange < -1.0 * forwBxChange)]
    forwChangeTermX[np.logical_and(forwBzChange >= 0.0,
                                   forwBzChange >= -1.0 * forwBxChange)] = -forwBxChange[
        np.logical_and(forwBzChange >= 0.0, forwBzChange >= -1.0 * forwBxChange)]
    forwChangeTermX[np.logical_and(forwBzChange >= 0.0, forwChangeTermX < 0.0)] = 0.0
    forwChangeTermX[np.logical_and(forwBzChange < 0.0,
                                   forwBzChange > -1.0 * forwBxChange)] = forwBzChange[
        np.logical_and(forwBzChange < 0.0, forwBzChange > -1.0 * forwBxChange)]
    forwChangeTermX[np.logical_and(forwBzChange < 0.0,
                                   forwBzChange <= -1.0 * forwBxChange)] = -forwBxChange[
        np.logical_and(forwBzChange < 0.0, forwBzChange <= -1.0 * forwBxChange)]
    forwChangeTermX[np.logical_and(forwBzChange < 0.0, forwChangeTermX > 0.0)] = 0.0
    forwChangeTermY[np.logical_and(forwBzChange >= 0.0,
                                   forwBzChange < -1.0 * forwByChange)] = forwBzChange[
        np.logical_and(forwBzChange >= 0.0, forwBzChange < -1.0 * forwByChange)]
    forwChangeTermY[np.logical_and(forwBzChange >= 0.0,
                                   forwBzChange >= -1.0 * forwByChange)] = -forwByChange[
        np.logical_and(forwBzChange >= 0.0, forwBzChange >= -1.0 * forwByChange)]
    forwChangeTermY[np.logical_and(forwBzChange >= 0.0, forwChangeTermY < 0.0)] = 0.0
    forwChangeTermY[np.logical_and(forwBzChange < 0.0,
                                   forwBzChange > -1.0 * forwByChange)] = forwBzChange[
        np.logical_and(forwBzChange < 0.0, forwBzChange > -1.0 * forwByChange)]
    forwChangeTermY[np.logical_and(forwBzChange < 0.0,
                                   forwBzChange <= -1.0 * forwByChange)] = -forwByChange[
        np.logical_and(forwBzChange < 0.0, forwBzChange <= -1.0 * forwByChange)]
    forwChangeTermY[np.logical_and(forwBzChange < 0.0, forwChangeTermY > 0.0)] = 0.0
    BCorrections[1,0] = halfDt*forwVx*forwChangeTermX
    BCorrections[1,1] = halfDt*forwVy*forwChangeTermY
    return BCorrections


def getReconBCorrectionsZ_3D(momX,momY,dens,faceBx,faceBy,faceBz,dt,dx,dy,dz,BcZ):
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    vx = momX/dens
    vy = momY/dens
    halfDt = 0.5*dt
    if BcZ == constants.OUTFLOW:
        expandedVx = np.append(vx[:,:,0].reshape(vx.shape[0],-1,1),vx,axis=2)
        expandedVx = np.append(expandedVx,vx[:,:,vx.shape[2]-1].reshape(vx.shape[0],-1,1),axis=2)
        expandedVy = np.append(vy[:,:,0].reshape(vy.shape[0],-1,1),vy,axis=2)
        expandedVy = np.append(expandedVy,vy[:,:,vy.shape[2]-1].reshape(vy.shape[0],-1,1),axis=2)
        expandedFaceBz = np.append(faceBz[:,:,0].reshape(faceBz.shape[0],-1,1),
                                   faceBz,axis=2)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[:,:,faceBz.shape[2]-1].reshape(faceBz.shape[0],-1,1),axis=2)
        expandedFaceBx = np.append(faceBx[:,:,0].reshape(faceBx.shape[0],-1,1),
                                   faceBx,axis=2)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[:,:,faceBx.shape[2]-1].reshape(faceBx.shape[0],-1,1),axis=2)
        expandedFaceBy = np.append(faceBy[:,:,0].reshape(faceBy.shape[0],-1,1),
                                   faceBy,axis=2)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[:,:,faceBy.shape[2]-1].reshape(faceBy.shape[0],-1,1),axis=2)
    else:
        expandedVx = np.append(vx[:,:,vx.shape[2]-1].reshape(vx.shape[0],-1,1),vx,axis=2)
        expandedVx = np.append(expandedVx,vx[:,:,0].reshape(vx.shape[0],-1,1),axis=2)
        expandedVy = np.append(vy[:,:,vy.shape[2]-1].reshape(vy.shape[0],-1,1),vy,axis=2)
        expandedVy = np.append(expandedVy,vy[:,:,0].reshape(vy.shape[0],-1,1),axis=2)
        expandedFaceBz = np.append(faceBz[:,:,faceBz.shape[2]-2].reshape(faceBz.shape[0],-1,1),
                                   faceBz,axis=2)
        expandedFaceBz = np.append(expandedFaceBz,
                                   faceBz[:,:,1].reshape(faceBz.shape[0],-1,1),axis=2)
        expandedFaceBx = np.append(faceBx[:,:,faceBx.shape[2]-1].reshape(faceBx.shape[0],-1,1),
                                   faceBx,axis=2)
        expandedFaceBx = np.append(expandedFaceBx,
                                   faceBx[:,:,0].reshape(faceBx.shape[0],-1,1),axis=2)
        expandedFaceBy = np.append(faceBy[:,:,faceBy.shape[2]-1].reshape(faceBy.shape[0],-1,1),
                                   faceBy,axis=2)
        expandedFaceBy = np.append(expandedFaceBy,
                                   faceBy[:,:,0].reshape(faceBy.shape[0],-1,1),axis=2)
    BxChanges = (expandedFaceBx[:,1:expandedFaceBx.shape[1],:]
                 -expandedFaceBx[:,0:expandedFaceBx.shape[1]-1,:])*invDx
    ByChanges = (expandedFaceBy[1:expandedFaceBy.shape[0],:,:]
                 -expandedFaceBy[0:expandedFaceBy.shape[0]-1,:,:])*invDy
    BzChanges = (expandedFaceBz[:,:,1:expandedFaceBz.shape[2]]
                 -expandedFaceBz[:,:,0:expandedFaceBz.shape[2]-1])*invDz
    posBzChange = BzChanges >= 0.0
    negBzChange = np.logical_not(posBzChange)
    BzLessThanNegBx = BzChanges < -BxChanges
    BzMoreThanNegBx = BzChanges > -BxChanges
    posBzCase_x = np.logical_and(posBzChange,BzLessThanNegBx)
    posBxCase_x = np.logical_and(posBzChange,np.logical_not(BzLessThanNegBx))
    negBzCase_x = np.logical_and(negBzChange, BzMoreThanNegBx)
    negBxCase_x = np.logical_and(negBzChange, np.logical_not(BzMoreThanNegBx))
    changeTermX = np.zeros(shape=ByChanges.shape)
    changeTermX[posBzCase_x] = BzChanges[posBzCase_x]
    changeTermX[posBxCase_x] = -BxChanges[posBxCase_x]
    changeTermX[np.logical_and(posBzChange, changeTermX < 0.0)] = 0.0
    changeTermX[negBzCase_x] = BzChanges[negBzCase_x]
    changeTermX[negBxCase_x] = -BxChanges[negBxCase_x]
    changeTermX[np.logical_and(negBzChange, changeTermX > 0.0)] = 0.0
    BzLessThanNegBy = BzChanges < -ByChanges
    BzMoreThanNegBy = BzChanges > -ByChanges
    posBzCase_y = np.logical_and(posBzChange, BzLessThanNegBy)
    posByCase_y = np.logical_and(posBzChange, np.logical_not(BzLessThanNegBy))
    negBzCase_y = np.logical_and(negBzChange, BzMoreThanNegBy)
    negByCase_y = np.logical_and(negBzChange, np.logical_not(BzMoreThanNegBy))
    changeTermY = np.zeros(shape=ByChanges.shape)
    changeTermY[posBzCase_y] = BzChanges[posBzCase_y]
    changeTermY[posByCase_y] = -ByChanges[posByCase_y]
    changeTermY[np.logical_and(posBzChange, changeTermY < 0.0)] = 0.0
    changeTermY[negBzCase_y] = BzChanges[negBzCase_y]
    changeTermY[negByCase_y] = -ByChanges[negByCase_y]
    changeTermY[np.logical_and(negBzChange, changeTermY > 0.0)] = 0.0
    BCorrections = np.zeros(shape=(2,2,faceBz.shape[0],faceBz.shape[1],faceBz.shape[2]))
    xSourceTerms = expandedVx*changeTermX
    ySourceTerms = expandedVy*changeTermY
    BCorrections[0,0] = halfDt*xSourceTerms[:,:,0:xSourceTerms.shape[2]-1]
    BCorrections[0,1] = halfDt*ySourceTerms[:,:,0:ySourceTerms.shape[2]-1]
    BCorrections[1,0] = halfDt*xSourceTerms[:,:,1:xSourceTerms.shape[2]]
    BCorrections[1,1] = halfDt*ySourceTerms[:,:,1:ySourceTerms.shape[2]]
    return BCorrections