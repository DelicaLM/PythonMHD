#RiemannSolvers_Hydro_Roe_HelperModule.py
#By Delica Leboe-McGowan, PhD Student, University of Manitoba
#Last Updated: January 1, 2024
#Purpose: Provides functions for calculating the intercell flux (via Roe's classic intercell flux
#         algorithm [1]) between adjacent cells in a hydrodynamic simulation on a Cartesian grid
#Additional Information:    These Roe functions are designed to generate intercell flux values that
#                        are numerically identical to those generated by the Roe algorithm in the 2017
#                        version of Athena [2] by James Stone and colleagues. In order to achieve this
#                        consistency, PythonMHD uses the Roe eigenmatrices that are presented in the
#                        original Athena methods paper [3]. However, there are two scenarios in which
#                        PythonMHD's Roe outputs may differ from the 2017 version of Athena:
#                        (1) PythonMHD gives the user the option of applying an entropy fix correction,
#                            which increases small wavespeeds as a strategy to increase numerical diffusion/
#                            artificial viscosity and, thereby, prevent or limit the appearance of unphysical
#                            rarefaction shocks (see PythonMHD's user guide or the excellent textbook by Toro
#                            for more information on entropy fixes in approximate Riemann solvers). An entropy
#                            fix isn't necessary to obtain smooth/continuous results for the provided test problems,
#                            but there may be types of simulated systems where including an entropy fix would be
#                            beneficial. In short, you probably won't need to take advantage of the entropy fix option,
#                            but PythonMHD still provides one in case you are curious about whether increasing numerical
#                            diffusion would improve your simulation results.
#                        (2) PythonMHD currently does not provide an HLLE Riemann solver, which Athena's
#                            Roe Riemann solver switches to if there is a negative pressure or density
#                            value in the interpolated state between two cells. However, since these
#                            scenarios are rare, only a Roe solver is provided for the time being.
#                            An HLLE solver (as well as other HLL Riemann solvers) will be included
#                            in a future version of PythonMHD. See the textbook by Toro [4] if you are
#                            interested in how HLL Riemann solvers differ from Roe's method.
#
# References:
# 1. Roe, P. L. (1981). Approximate Riemann solvers, parameter vectors, and difference schemes.
#    Journal of Computational Physics, 43(2), 357-372. https://doi.org/10.1016/0021-9991(81)90128-5.
# 2. https://github.com/PrincetonUniversity/Athena-Cversion
# 3. Stone, J. M., Gardiner, T. A., Teuben, P., Hawley, J. F., & Simon, J. B. (2008).
#    Athena: A new code for astrophysical MHD. The Astrophysical Journal Supplemental Series,
#    178(1), 137-177. https://iopscience.iop.org/article/10.1086/588755/pdf.
# 4. Toro, E. F. (2009). Riemann solvers and numerical methods for fluid dynamics: A practical introduction.
#    Springer, Berlin, Heidelberg. https://doi-org.uml.idm.oclc.org/10.1007/b79761.
# 5. Harten, A., & Hyman, J. M. (1983). Self adjusting grid methods for one-Dimensional hyperbolic conservation laws.
#    Journal of Computational Physics, 50(2), 235-269. https://doi.org/10.1016/0021-9991(83)90066-9.
# 6. Banyuls, F., Font, A. J., Ibanez, J. M., Marti, J.M, & Miralles, J. A. (1997). Numerical {3 + 1} General
#    Relativistic Hydrodynamics: A Local Characteristic Approach. The Astrophysical Journal, 476, 221-231.
#    https://iopscience.iop.org/article/10.1086/303604/fulltext/34434.text.html

#####IMPORT STATEMENTS#####

#Import PythonMHD constants
import Source.PythonMHD_Constants as constants

#Import helper module for Primitive -> Conservative and Conservative -> Primitive variable conversions
import Source.PrimCons_HelperModule as primConsLib

#Import NumPy for matrix operations
import numpy as np

#####X-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverX_hydro_roe
#Purpose: Calculates the intercell flux between adjacent cells in the x-direction.
#         This function implements Roe's Riemann solver algorithm for a hydrodynamic
#         simulation, using the eigenmatrices provided in [3].
#Input Parameters: leftPrimVars (the left cell-centred primitive variable states)
#                  rightPrimVars (the right cell-centred primitive variable states)
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the x-direction)
def riemannSolverX_hydro_roe(leftPrimVars, rightPrimVars, gamma, useEntropyFix, epsilon):
    #Calculate the conservative form of the primitive variables states
    #(because we will need the conservative variable differences/slopes
    # to find the amplitudes of the waves generated by discontinuities
    # in the hydrodynamic states (i.e., any place where adjacent cells have
    # different fluid densities, pressures, or velocities)).
    leftConsVars = primConsLib.primToCons_hydro_x(leftPrimVars,gamma)
    rightConsVars = primConsLib.primToCons_hydro_x(rightPrimVars, gamma)

    #Compute the Roe-averaged variables for all of the intercell boundaries in the x-direction

    #Get the density to the left of each intercell boundary
    rho_i = leftPrimVars[0,:]
    #Get the density to the right of each intercell boundary
    rho_i1 = rightPrimVars[0,:]
    #Calculate the square root of each density
    leftDensSqrt = np.sqrt(rho_i)
    rightDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(leftDens) + sqrt(rightDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(leftDensSqrt+rightDensSqrt)

    #Get the x-velocity to the left of each intercell boundary
    vx_i = leftPrimVars[1,:]
    #Get the x-velocity to the right of each intercell boundary
    vx_i1 = rightPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (leftDensSqrt*vx_i + rightDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity to the left of each intercell boundary
    vy_i = leftPrimVars[2,:]
    #Get the y-velocity to the right of each intercell boundary
    vy_i1 = rightPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (leftDensSqrt*vy_i + rightDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity to the left of each intercell boundary
    vz_i = leftPrimVars[3,:]
    #Get the z-velocity to the right of each intercell boundary
    vz_i1 = rightPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (leftDensSqrt*vz_i + rightDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVx*roeAvgVx + roeAvgVy*roeAvgVy + roeAvgVz*roeAvgVz

    #Get the hydrodynamic pressure to the left of each intercell boundary
    pres_i = leftPrimVars[4,:]
    #Get the hydrodynamic pressure to the right of each intercell boundary
    pres_i1 = rightPrimVars[4,:]

    #Compute the Roe-averaged enthalpy
    roeAvgH = ((leftConsVars[4]+pres_i)/leftDensSqrt + (rightConsVars[4]+pres_i1)/rightDensSqrt)*invSqrtDensSum

    #Start calculating the Roe-averaged wavespeeds

    #For hydrodynamics in the x-direction, there are three waves types that we need
    #to consider at each intercell boundary:
    #Rarefaction wave with speed |vx| - cs, where cs is the hydrodynamic sound speed
    #Contact discontinuity with speed vx
    #Shock wave with speed |vx| + cs, where cs is the hydrodynamic sound speed

    #Calculate the hydrodynamic sound speed
    roeAvgSoundSpeedSq = (gamma-1.0)*np.maximum(roeAvgH-0.5*roeAvgVSq,constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=leftPrimVars.shape)
    eigenVals[0,:] = roeAvgVx - roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vx)
                                                 #(vx < 0 -> shock, vx > 0 rarefaction)
    eigenVals[1,:] = roeAvgVx #contact discontinuity
    eigenVals[2,:] = roeAvgVx #contact discontinuity
    eigenVals[3,:] = roeAvgVx #contact discontinuity
    eigenVals[4,:] = roeAvgVx + roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vx)
                                                 #(vx < 0 -> rarefaction, vx > 0 shock)

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983)[5].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    if len(leftPrimVars.shape) == 2: #if the sim is 1D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1]))
    elif len(leftPrimVars.shape) == 3: #if the sim is 2D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1],
                                           leftPrimVars.shape[2]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1],
                                          leftPrimVars.shape[2]))
    else: #if the sim is 3D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1],
                                           leftPrimVars.shape[2],
                                           leftPrimVars.shape[3]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1],
                                          leftPrimVars.shape[2],
                                          leftPrimVars.shape[3]))

    #Add values to the right eigenmatrix (using the formulas from [2] and [3])
    rightEigenmatrix[0,0,:] = 1.0
    rightEigenmatrix[1,0,:] = roeAvgVx - roeAvgSoundSpeed
    rightEigenmatrix[2,0,:] = roeAvgVy
    rightEigenmatrix[3,0,:] = roeAvgVz
    rightEigenmatrix[4,0,:] = roeAvgH - roeAvgVx*roeAvgSoundSpeed

    rightEigenmatrix[2,1,:] = 1.0
    rightEigenmatrix[4,1,:] = roeAvgVy

    rightEigenmatrix[3,2,:] = 1.0
    rightEigenmatrix[4,2,:] = roeAvgVz

    rightEigenmatrix[0,3,:] = 1.0
    rightEigenmatrix[1,3,:] = roeAvgVx
    rightEigenmatrix[2,3,:] = roeAvgVy
    rightEigenmatrix[3,3,:] = roeAvgVz
    rightEigenmatrix[4,3,:] = 0.5*roeAvgVSq

    rightEigenmatrix[0,4,:] = 1.0
    rightEigenmatrix[1,4,:] = roeAvgVx + roeAvgSoundSpeed
    rightEigenmatrix[2,4,:] = roeAvgVy
    rightEigenmatrix[3,4,:] = roeAvgVz
    rightEigenmatrix[4,4,:] = roeAvgH + roeAvgVx*roeAvgSoundSpeed

    #Calculate a normalization factor for the left eigenmatrix
    normFactor = 0.5/roeAvgSoundSpeedSq
    #Calculate the value of the specific heat ratio - 1
    gammaMinOne = gamma - 1.0

    #Add values to the left eigenmatrix (using the formulas from [2] and [3])
    leftEigenmatrix[0,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq + roeAvgVx*roeAvgSoundSpeed)
    leftEigenmatrix[0,1,:] = -normFactor*(gammaMinOne*roeAvgVx + roeAvgSoundSpeed)
    leftEigenmatrix[0,2,:] = -normFactor*gammaMinOne*roeAvgVy
    leftEigenmatrix[0,3,:] = -normFactor*gammaMinOne*roeAvgVz
    leftEigenmatrix[0,4,:] = normFactor*gammaMinOne

    leftEigenmatrix[1,0,:] = -roeAvgVy
    leftEigenmatrix[1,2,:] = 1.0

    leftEigenmatrix[2,0,:] = -roeAvgVz
    leftEigenmatrix[2,3,:] = 1.0

    #Calculate another normalization factor
    gammaNorm = gammaMinOne/roeAvgSoundSpeedSq

    leftEigenmatrix[3,0,:] = 1.0 - normFactor*gammaMinOne*roeAvgVSq
    leftEigenmatrix[3,1,:] = gammaNorm*roeAvgVx
    leftEigenmatrix[3,2,:] = gammaNorm*roeAvgVy
    leftEigenmatrix[3,3,:] = gammaNorm*roeAvgVz
    leftEigenmatrix[3,4,:] = -gammaNorm

    leftEigenmatrix[4,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq-roeAvgVx*roeAvgSoundSpeed)
    leftEigenmatrix[4,1,:] = -normFactor*(gammaMinOne*roeAvgVx - roeAvgSoundSpeed)
    leftEigenmatrix[4,2,:] = leftEigenmatrix[0,2,:]
    leftEigenmatrix[4,3,:] = leftEigenmatrix[0,3,:]
    leftEigenmatrix[4,4,:] = leftEigenmatrix[0,4,:]

    #Calculate the flux variables for the cell to the left of the intercell boundary
    leftCellFlux = np.array([leftConsVars[1],
                             leftConsVars[1]*leftPrimVars[1] + leftPrimVars[4],
                             leftConsVars[1]*leftPrimVars[2],
                             leftConsVars[1]*leftPrimVars[3],
                             (leftConsVars[4]+leftPrimVars[4])*leftPrimVars[1]])
    #Calculate the flux variables for the cell to the right of the intercell boundary
    rightCellFlux = np.array([rightConsVars[1],
                              rightConsVars[1]*rightPrimVars[1] + rightPrimVars[4],
                              rightConsVars[1]*rightPrimVars[2],
                              rightConsVars[1]*rightPrimVars[3],
                              (rightConsVars[4]+rightPrimVars[4])*rightPrimVars[1]])

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = rightConsVars - leftConsVars
    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [5].)
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        for j in range(consVarsDiff.shape[0]):
            consVarsDiffProj[i] += leftEigenmatrix[i,j,:]*consVarsDiff[j]

    #Calculate the amplitudes associated with each of the waves.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]

    #Calculate the intercell flux as F_(i-1/2) = 0.5*(F_(i-1) + F_i) + F_roe
    interCellFlux = 0.5 * (leftCellFlux + rightCellFlux) #First take the average of the left
                                                         #and right cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    #(Note: The negative sign is here because we calculate the difference in
    #       conservative variables as rightConsVars - leftConsVars instead of
    #       leftConsVars - rightConsVars. (See page 146 in [3] to see how
    #       the Roe flux formula is presented in the Athena methods paper
    #       (Stone et al., 2008).
    for i in range(interCellFlux.shape[0]):
        for j in range(interCellFlux.shape[0]):
            interCellFlux[i] -= amps[j]*rightEigenmatrix[i, j,:] #multiplying by the right eigenmatrix gets us
                                                                 #from characteristic variables back into
                                                                 #conservative variables (technically the flux of
                                                                 #conservative variables)

    #If the smallest eigenvalue (vx - cs) is greater than zero,
    #return the left cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the x-direction,
    # the flow is super/hypersonic if the x-velocity is greater than
    # the hydrodynamic sound speed. We make the same correction if
    # vx is equal to the hydrodynamic sound speed, in order to
    # prevent us from ever having a rarefaction wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    interCellFlux[:,minEigenValIsPositiveOrZero] = leftCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vx + cs) is less or equal to zero,
    #return the right cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative x-direction (i.e., regions in
    # the fluid where |vx| > cs and vx < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly
    # in the positive x-direction (i.e., to the right), we use the left cell
    # flux. When the fluid is moving too quickly in the negative x-direction
    # (i.e., to the left), we use the right cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[4,:] <= 0.0
    interCellFlux[:,maxEigenValIsNegativeOrZero] = rightCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the x-direction
    return interCellFlux

#####Y-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverY_hydro_roe
#Purpose: Calculates the intercell flux between adjacent cells in the y-direction.
#         This function implements Roe's Riemann solver algorithm for a hydrodynamic
#         simulation, using the eigenmatrices provided in [3].
#Input Parameters: topPrimVars (the top/upper cell-centred primitive variable states)
#                  bottomPrimVars (the bottom/lower cell-centred primitive variable states)
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the y-direction)
def riemannSolverY_hydro_roe(topPrimVars, bottomPrimVars, gamma, useEntropyFix, epsilon):
    #Calculate the conservative form of the primitive variables states
    #(because we will need the conservative variable differences/slopes
    # to find the amplitudes of the waves generated by discontinuities
    # in the hydrodynamic states (i.e., any place where adjacent cells have
    # different fluid densities, pressures, or velocities)).
    topConsVars = primConsLib.primToCons_hydro_y(topPrimVars,gamma)
    bottomConsVars = primConsLib.primToCons_hydro_y(bottomPrimVars, gamma)

    #Compute the Roe-averaged variables for all of the intercell boundaries in the y-direction

    #Get the density above of each intercell boundary
    rho_i = topPrimVars[0,:]
    #Get the density below each intercell boundary
    rho_i1 = bottomPrimVars[0,:]
    #Calculate the square root of each density
    topDensSqrt = np.sqrt(rho_i)
    bottomDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(topDens) + sqrt(bottomDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(topDensSqrt+bottomDensSqrt)

    #Get the x-velocity above each intercell boundary
    vx_i = topPrimVars[1,:]
    #Get the x-velocity below each intercell boundary
    vx_i1 = bottomPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (topDensSqrt*vx_i + bottomDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity above each intercell boundary
    vy_i = topPrimVars[2,:]
    #Get the y-velocity below each intercell boundary
    vy_i1 = bottomPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (topDensSqrt*vy_i + bottomDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity above each intercell boundary
    vz_i = topPrimVars[3,:]
    #Get the z-velocity below each intercell boundary
    vz_i1 = bottomPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (topDensSqrt*vz_i + bottomDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVy*roeAvgVy + roeAvgVz*roeAvgVz + roeAvgVx*roeAvgVx

    #Get the hydrodynamic pressure above each intercell boundary
    pres_i = topPrimVars[4,:]
    #Get the hydrodynamic pressure below each intercell boundary
    pres_i1 = bottomPrimVars[4,:]

    #Compute the Roe-averaged enthalpy
    roeAvgH = ((topConsVars[4]+pres_i)/topDensSqrt + (bottomConsVars[4]+pres_i1)/bottomDensSqrt)*invSqrtDensSum

    #Start calculating the Roe-averaged wavespeeds

    #For hydrodynamics in the y-direction, there are three waves types that we need
    #to consider at each intercell boundary:
    #Rarefaction wave with speed |vy| - cs, where cs is the hydrodynamic sound speed
    #Contact discontinuity with speed vy
    #Shock wave with speed |vy| + cs, where cs is the hydrodynamic sound speed

    #Calculate the hydrodynamic sound speed
    roeAvgSoundSpeedSq = (gamma-1.0)*np.maximum(roeAvgH-0.5*roeAvgVSq,constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=topPrimVars.shape)
    eigenVals[0,:] = roeAvgVy - roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vx)
                                                 #(vx < 0 -> shock, vx > 0 rarefaction)
    eigenVals[1,:] = roeAvgVy #contact discontinuity
    eigenVals[2,:] = roeAvgVy #contact discontinuity
    eigenVals[3,:] = roeAvgVy #contact discontinuity
    eigenVals[4,:] = roeAvgVy + roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vx)
                                                 #(vx < 0 -> rarefaction, vx > 0 shock)

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983)[5].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    if len(topPrimVars.shape) == 2: #if the sim is 1D
        rightEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                           topPrimVars.shape[0],
                                           topPrimVars.shape[1]))
        leftEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                          topPrimVars.shape[0],
                                          topPrimVars.shape[1]))
    elif len(topPrimVars.shape) == 3: #if the sim is 2D
        rightEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                           topPrimVars.shape[0],
                                           topPrimVars.shape[1],
                                           topPrimVars.shape[2]))
        leftEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                          topPrimVars.shape[0],
                                          topPrimVars.shape[1],
                                          topPrimVars.shape[2]))
    else: #if the sim is 3D
        rightEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                           topPrimVars.shape[0],
                                           topPrimVars.shape[1],
                                           topPrimVars.shape[2],
                                           topPrimVars.shape[3]))
        leftEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                          topPrimVars.shape[0],
                                          topPrimVars.shape[1],
                                          topPrimVars.shape[2],
                                          topPrimVars.shape[3]))

    #Add values to the right eigenmatrix (using the formulas from [2] and [3])
    rightEigenmatrix[0,0,:] = 1.0
    rightEigenmatrix[1,0,:] = roeAvgVx
    rightEigenmatrix[2,0,:] = roeAvgVy - roeAvgSoundSpeed
    rightEigenmatrix[3,0,:] = roeAvgVz
    rightEigenmatrix[4,0,:] = roeAvgH - roeAvgVy*roeAvgSoundSpeed

    rightEigenmatrix[0,1,:] = 1.0
    rightEigenmatrix[1,1,:] = roeAvgVx
    rightEigenmatrix[2,1,:] = roeAvgVy
    rightEigenmatrix[3,1,:] = roeAvgVz
    rightEigenmatrix[4,1,:] = 0.5*roeAvgVSq

    rightEigenmatrix[3,2,:] = 1.0
    rightEigenmatrix[4,2,:] = roeAvgVz

    rightEigenmatrix[1,3,:] = 1.0
    rightEigenmatrix[4,3,:] = roeAvgVx

    rightEigenmatrix[0,4,:] = 1.0
    rightEigenmatrix[1,4,:] = roeAvgVx
    rightEigenmatrix[2,4,:] = roeAvgVy + roeAvgSoundSpeed
    rightEigenmatrix[3,4,:] = roeAvgVz
    rightEigenmatrix[4,4,:] = roeAvgH + roeAvgVy*roeAvgSoundSpeed

    #Calculate a normalization factor for the left eigenmatrix
    normFactor = 0.5/roeAvgSoundSpeedSq
    #Calculate the value of the specific heat ratio - 1
    gammaMinOne = gamma - 1.0

    #Add values to the left eigenmatrix (using the formulas from [2] and [3])
    leftEigenmatrix[0,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq + roeAvgVy*roeAvgSoundSpeed)
    leftEigenmatrix[0,1,:] = -normFactor*gammaMinOne*roeAvgVx
    leftEigenmatrix[0,2,:] = -normFactor*(gammaMinOne*roeAvgVy + roeAvgSoundSpeed)
    leftEigenmatrix[0,3,:] = -normFactor*gammaMinOne*roeAvgVz
    leftEigenmatrix[0,4,:] = normFactor*gammaMinOne

    #Calculate another normalization factor
    gammaNorm = gammaMinOne/roeAvgSoundSpeedSq
    leftEigenmatrix[1,0,:] = 1.0 - normFactor*gammaMinOne*roeAvgVSq
    leftEigenmatrix[1,1,:] = gammaNorm*roeAvgVx
    leftEigenmatrix[1,2,:] = gammaNorm*roeAvgVy
    leftEigenmatrix[1,3,:] = gammaNorm*roeAvgVz
    leftEigenmatrix[1,4,:] = -gammaNorm

    leftEigenmatrix[2,0,:] = -roeAvgVz
    leftEigenmatrix[2,3,:] = 1.0

    leftEigenmatrix[3,0,:] = -roeAvgVx
    leftEigenmatrix[3,1,:] = 1.0

    leftEigenmatrix[4,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq-roeAvgVy*roeAvgSoundSpeed)
    leftEigenmatrix[4,1,:] = leftEigenmatrix[0,1,:]
    leftEigenmatrix[4,2,:] = -normFactor*(gammaMinOne*roeAvgVy - roeAvgSoundSpeed)
    leftEigenmatrix[4,3,:] = leftEigenmatrix[0,3,:]
    leftEigenmatrix[4,4,:] = leftEigenmatrix[0,4,:]

    #Calculate the flux variables for the cell above the intercell boundary
    topCellFlux = np.array([topConsVars[2],
                             topConsVars[2]*topPrimVars[1],
                             topConsVars[2]*topPrimVars[2] + topPrimVars[4],
                             topConsVars[2]*topPrimVars[3],
                             (topConsVars[4]+topPrimVars[4])*topPrimVars[2]])
    #Calculate the flux variables for the cell below the intercell boundary
    bottomCellFlux = np.array([bottomConsVars[2],
                            bottomConsVars[2] * bottomPrimVars[1],
                            bottomConsVars[2] * bottomPrimVars[2] + bottomPrimVars[4],
                            bottomConsVars[2] * bottomPrimVars[3],
                            (bottomConsVars[4] + bottomPrimVars[4]) * bottomPrimVars[2]])

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = bottomConsVars - topConsVars
    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [5].)
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        for j in range(consVarsDiff.shape[0]):
            consVarsDiffProj[i] += leftEigenmatrix[i,j,:]*consVarsDiff[j]

    #Calculate the amplitudes associated with each of the waves.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]

    #Calculate the intercell flux as F_(j-1/2) = 0.5*(F_(j-1) + F_j) + F_roe
    interCellFlux = 0.5 * (topCellFlux + bottomCellFlux) #First take the average of the top
                                                         #and bottom cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    for i in range(interCellFlux.shape[0]):
        for j in range(interCellFlux.shape[0]):
            interCellFlux[i] -= amps[j] * rightEigenmatrix[i, j, :]  #multiplying by the right eigenmatrix gets us
                                                                     #from characteristic variables back into
                                                                     #conservative variables (technically the flux of
                                                                     #conservative variables)

    #If the smallest eigenvalue (vy - cs) is greater than zero,
    #return the top cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the y-direction,
    # the flow is super/hypersonic if the y-velocity is greater than
    # the hydrodynamic sound speed. We make the same correction if
    # vy is equal to the hydrodynamic sound speed, in order to
    # prevent us from ever having a rarefaction wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    interCellFlux[:,minEigenValIsPositiveOrZero] = topCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vy + cs) is less or equal to zero,
    #return the right cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative y-direction (i.e., regions in
    # the fluid where |vy| > cs and vy < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly in the positive
    # y-direction (i.e., down the simulation grid), we use the upper/top cell
    # flux. When the fluid is moving too quickly in the negative y-direction
    # (i.e., up the simulation grid), we use the lower/bottom cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[4,:] <= 0.0
    interCellFlux[:,maxEigenValIsNegativeOrZero] = bottomCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the y-direction
    return interCellFlux

#####Z-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverZ_hydro_roe
#Purpose: Calculates the intercell flux between adjacent cells in the z-direction.
#         This function implements Roe's Riemann solver algorithm for a hydrodynamic
#         simulation, using the eigenmatrices provided in [3].
#Input Parameters: backPrimVars (the back cell-centred primitive variable states)
#                               (i.e., the cells that are closer to you (than forwPrimVars)
#                                      if the z-axis goes into your screen)
#                  forwPrimVars (the forward cell-centred primitive variable states)
#                               (i.e., the cells that are farther from you (than backPrimVars)
#                                      if the z-axis goes into your screen)
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the z-direction)
def riemannSolverZ_hydro_roe(backPrimVars, forwPrimVars, gamma, useEntropyFix, epsilon):
    #Calculate the conservative form of the primitive variables states
    #(because we will need the conservative variable differences/slopes
    # to find the amplitudes of the waves generated by discontinuities
    # in the hydrodynamic states (i.e., any place where adjacent cells have
    # different fluid densities, pressures, or velocities)).
    backConsVars = primConsLib.primToCons_hydro_z(backPrimVars,gamma)
    forwConsVars = primConsLib.primToCons_hydro_z(forwPrimVars, gamma)

    #Compute the Roe-averaged variables for all of the intercell boundaries in the z-direction

    #Get the density behind each intercell boundary
    rho_i = backPrimVars[0,:]
    #Get the density in front of each intercell boundary
    rho_i1 = forwPrimVars[0,:]
    #Calculate the square root of each density
    backDensSqrt = np.sqrt(rho_i)
    forwDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(backDens) + sqrt(forwDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(backDensSqrt+forwDensSqrt)

    #Get the x-velocity behind each intercell boundary
    vx_i = backPrimVars[1,:]
    #Get the x-velocity in front of each intercell boundary
    vx_i1 = forwPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (backDensSqrt*vx_i + forwDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity behind each intercell boundary
    vy_i = backPrimVars[2,:]
    #Get the y-velocity in front of each intercell boundary
    vy_i1 = forwPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (backDensSqrt*vy_i + forwDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity behind each intercell boundary
    vz_i = backPrimVars[3,:]
    #Get the z-velocity in front of each intercell boundary
    vz_i1 = forwPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (backDensSqrt*vz_i + forwDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVz*roeAvgVz + roeAvgVx*roeAvgVx + roeAvgVy*roeAvgVy

    #Get the hydrodynamic pressure behind each intercell boundary
    pres_i = backPrimVars[4,:]
    #Get the hydrodynamic pressure in front of each intercell boundary
    pres_i1 = forwPrimVars[4,:]

    #Compute the Roe-averaged enthalpy
    roeAvgH = ((backConsVars[4]+pres_i)/backDensSqrt + (forwConsVars[4]+pres_i1)/forwDensSqrt)*invSqrtDensSum

    #Start calculating the Roe-averaged wavespeeds

    #For hydrodynamics in the z-direction, there are three waves types that we need
    #to consider at each intercell boundary:
    #Rarefaction wave with speed |vz| - cs, where cs is the hydrodynamic sound speed
    #Contact discontinuity with speed vz
    #Shock wave with speed |vz| + cs, where cs is the hydrodynamic sound speed

    #Calculate the hydrodynamic sound speed
    roeAvgSoundSpeedSq = (gamma-1.0)*np.maximum(roeAvgH-0.5*roeAvgVSq,constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=backPrimVars.shape)
    eigenVals[0,:] = roeAvgVz - roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vz)
                                                 #(vz < 0 -> shock, vz > 0 rarefaction)
    eigenVals[1,:] = roeAvgVz #contact discontinuity
    eigenVals[2,:] = roeAvgVz #contact discontinuity
    eigenVals[3,:] = roeAvgVz #contact discontinuity
    eigenVals[4,:] = roeAvgVz + roeAvgSoundSpeed #either the shock or rarefaction wave (depending on sign of vz)
                                                 #(vz < 0 -> rarefaction, vz > 0 shock)

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983)[5].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)\
                                                                 *(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    if len(backPrimVars.shape) == 2: #if the sim is 1D
        rightEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                           backPrimVars.shape[0],
                                           backPrimVars.shape[1]))
        leftEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                          backPrimVars.shape[0],
                                          backPrimVars.shape[1]))
    elif len(backPrimVars.shape) == 3: #if the sim is 2D
        rightEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                           backPrimVars.shape[0],
                                           backPrimVars.shape[1],
                                           backPrimVars.shape[2]))
        leftEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                          backPrimVars.shape[0],
                                          backPrimVars.shape[1],
                                          backPrimVars.shape[2]))
    else: #if the sim is 3D
        rightEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                           backPrimVars.shape[0],
                                           backPrimVars.shape[1],
                                           backPrimVars.shape[2],
                                           backPrimVars.shape[3]))
        leftEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                          backPrimVars.shape[0],
                                          backPrimVars.shape[1],
                                          backPrimVars.shape[2],
                                          backPrimVars.shape[3]))

    #Add values to the right eigenmatrix (using the formulas from [2] and [3])
    rightEigenmatrix[0,0,:] = 1.0
    rightEigenmatrix[1,0,:] = roeAvgVx
    rightEigenmatrix[2,0,:] = roeAvgVy
    rightEigenmatrix[3,0,:] = roeAvgVz - roeAvgSoundSpeed
    rightEigenmatrix[4,0,:] = roeAvgH - roeAvgVz*roeAvgSoundSpeed

    rightEigenmatrix[2,1,:] = 1.0
    rightEigenmatrix[4,1,:] = roeAvgVy

    rightEigenmatrix[0,2,:] = 1.0
    rightEigenmatrix[1,2,:] = roeAvgVx
    rightEigenmatrix[2,2,:] = roeAvgVy
    rightEigenmatrix[3,2,:] = roeAvgVz
    rightEigenmatrix[4,2,:] = 0.5*roeAvgVSq

    rightEigenmatrix[1,3,:] = 1.0
    rightEigenmatrix[4,3,:] = roeAvgVx

    rightEigenmatrix[0,4,:] = 1.0
    rightEigenmatrix[1,4,:] = roeAvgVx
    rightEigenmatrix[2,4,:] = roeAvgVy
    rightEigenmatrix[3,4,:] = roeAvgVz + roeAvgSoundSpeed
    rightEigenmatrix[4,4,:] = roeAvgH + roeAvgVz*roeAvgSoundSpeed

    #Calculate a normalization factor for the left eigenmatrix
    normFactor = 0.5/roeAvgSoundSpeedSq
    #Calculate the value of the specific heat ratio - 1
    gammaMinOne = gamma - 1.0

    #Add values to the left eigenmatrix (using the formulas from [2] and [3])
    leftEigenmatrix[0,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq + roeAvgVz*roeAvgSoundSpeed)
    leftEigenmatrix[0,1,:] = -normFactor*gammaMinOne*roeAvgVx
    leftEigenmatrix[0,2,:] = -normFactor*gammaMinOne*roeAvgVy
    leftEigenmatrix[0,3,:] = -normFactor*(gammaMinOne*roeAvgVz + roeAvgSoundSpeed)
    leftEigenmatrix[0,4,:] = normFactor*gammaMinOne

    leftEigenmatrix[1,0,:] = -roeAvgVy
    leftEigenmatrix[1,2,:] = 1.0

    #Calculate another normalization factor
    gammaNorm = gammaMinOne/roeAvgSoundSpeedSq

    leftEigenmatrix[2,0,:] = 1.0 - normFactor*gammaMinOne*roeAvgVSq
    leftEigenmatrix[2,1,:] = gammaNorm*roeAvgVx
    leftEigenmatrix[2,2,:] = gammaNorm*roeAvgVy
    leftEigenmatrix[2,3,:] = gammaNorm*roeAvgVz
    leftEigenmatrix[2,4,:] = -gammaNorm

    leftEigenmatrix[3,0,:] = -roeAvgVx
    leftEigenmatrix[3,1,:] = 1.0

    leftEigenmatrix[4,0,:] = normFactor*(0.5*gammaMinOne*roeAvgVSq-roeAvgVz*roeAvgSoundSpeed)
    leftEigenmatrix[4,1,:] = leftEigenmatrix[0,1,:]
    leftEigenmatrix[4,2,:] = leftEigenmatrix[0,2,:]
    leftEigenmatrix[4,3,:] = -normFactor*(gammaMinOne*roeAvgVz - roeAvgSoundSpeed)
    leftEigenmatrix[4,4,:] = leftEigenmatrix[0,4,:]

    #Calculate the flux variables for the cell behind the intercell boundary
    backCellFlux = np.array([backConsVars[3],
                             backConsVars[3]*backPrimVars[1],
                             backConsVars[3]*backPrimVars[2],
                             backConsVars[3]*backPrimVars[3] + backPrimVars[4],
                             (backConsVars[4]+backPrimVars[4])*backPrimVars[3]])
    #Calculate the flux variables for the cell in front of the intercell boundary
    forwCellFlux = np.array([forwConsVars[3],
                             forwConsVars[3]*forwPrimVars[1],
                             forwConsVars[3]*forwPrimVars[2],
                             forwConsVars[3]*forwPrimVars[3] + forwPrimVars[4],
                             (forwConsVars[4]+forwPrimVars[4])*forwPrimVars[3]])

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = forwConsVars - backConsVars
    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [5].)
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        for j in range(consVarsDiff.shape[0]):
            consVarsDiffProj[i] += leftEigenmatrix[i,j,:]*consVarsDiff[j]

    #Calculate the amplitudes associated with each of the waves.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]

    #Calculate the intercell flux as F_(k-1/2) = 0.5*(F_(k-1) + F_k) + F_roe
    interCellFlux = 0.5*(backCellFlux + forwCellFlux) #First take the average of the back
                                                      #and forward cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    for i in range(interCellFlux.shape[0]):
        for j in range(interCellFlux.shape[0]):
            interCellFlux[i] -= amps[j]*rightEigenmatrix[i,j,:] #multiplying by the right eigenmatrix gets us
                                                                #from characteristic variables back into
                                                                #conservative variables (technically the flux of
                                                                #conservative variables)

    #If the smallest eigenvalue (vz - cs) is greater than zero,
    #return the back cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the z-direction,
    # the flow is super/hypersonic if the z-velocity is greater than
    # the hydrodynamic sound speed. We make the same correction if
    # vz is equal to the hydrodynamic sound speed, in order to
    # prevent us from ever having a rarefaction wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    interCellFlux[:,minEigenValIsPositiveOrZero] = backCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vz + cs) is less or equal to zero,
    #return the forward cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative z-direction (i.e., regions in
    # the fluid where |vz| > cs and vz < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly
    # in the positive z-direction (i.e., into the screen), we use the back cell
    # flux. When the fluid is moving too quickly in the negative z-direction
    # (i.e., out of the screen), we use the forward cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[4,:] <= 0.0
    interCellFlux[:,maxEigenValIsNegativeOrZero] = forwCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the z-direction
    return interCellFlux