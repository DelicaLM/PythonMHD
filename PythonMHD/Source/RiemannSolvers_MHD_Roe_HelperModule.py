#RiemannSolvers_MHD_Roe_HelperModule.py
#By Delica Leboe-McGowan, PhD Student, University of Manitoba
#Last Updated: January 1, 2024
#Purpose: Provides functions for calculating the intercell flux (via Roe's classic intercell flux
#         algorithm [1] and the MHD version developed by Cargo & Gallice (1997) [2]) between adjacent
#         cells in a magnetohydrodynamic simulation on a Cartesian grid.
#
#Additional Information:    These Roe functions are designed to generate intercell flux values that
#                        are numerically identical to those generated by the Roe algorithm in the 2017
#                        version of Athena [3] by James Stone and colleagues. In order to achieve this
#                        consistency, PythonMHD uses the Roe eigenmatrices that are presented in the
#                        original Athena methods paper [4]. However, there are two scenarios in which
#                        PythonMHD's Roe outputs may differ from the 2017 version of Athena:
#                        (1) PythonMHD gives the user the option of applying an entropy fix correction,
#                            which increases small wavespeeds as a strategy to increase numerical diffusion/
#                            artificial viscosity and, thereby, prevent or limit the appearance of unphysical
#                            rarefaction shocks (see PythonMHD's user guide or the excellent textbook by Toro [5]
#                            for more information on entropy fixes in approximate Riemann solvers). An entropy
#                            fix isn't necessary to obtain smooth/continuous results for the provided test problems,
#                            but there may be types of simulated systems where including an entropy fix would be
#                            beneficial. In short, you probably won't need to take advantage of the entropy fix option,
#                            but PythonMHD still provides one in case you are curious about whether increasing numerical
#                            diffusion would improve your simulation results.
#                        (2) PythonMHD currently does not provide an HLLE Riemann solver, which Athena's
#                            Roe Riemann solver switches to if there is a negative pressure or density
#                            value in the interpolated state between two cells. However, since these
#                            scenarios are rare, only a Roe solver is provided for the time being.
#                            An HLLE solver (as well as other HLL Riemann solvers) will be included
#                            in a future version of PythonMHD. See the textbook by Toro [5] if you are
#                            interested in how HLL Riemann solvers differ from Roe's method.
#
# References:
# 1. Roe, P. L. (1981). Approximate Riemann solvers, parameter vectors, and difference schemes.
#    Journal of Computational Physics, 43(2), 357-372. https://doi.org/10.1016/0021-9991(81)90128-5.
# 2. Cargo, P., and Gallice, G. (1997). Roe Matrices for ideal MHD and systematic construction of
#    Roe matrices for systems of conservation laws. Journal of Computational Physics, 136(2), 446-
#    466.
# 3. https://github.com/PrincetonUniversity/Athena-Cversion
# 4. Stone, J. M., Gardiner, T. A., Teuben, P., Hawley, J. F., & Simon, J. B. (2008).
#    Athena: A new code for astrophysical MHD. The Astrophysical Journal Supplemental Series,
#    178(1), 137-177. https://iopscience.iop.org/article/10.1086/588755/pdf.
# 5. Toro, E. F. (2009). Riemann solvers and numerical methods for fluid dynamics: A practical introduction.
#    Springer, Berlin, Heidelberg. https://doi-org.uml.idm.oclc.org/10.1007/b79761.
# 6. Harten, A., & Hyman, J. M. (1983). Self adjusting grid methods for one-Dimensional hyperbolic conservation laws.
#    Journal of Computational Physics, 50(2), 235-269. https://doi.org/10.1016/0021-9991(83)90066-9.
# 7. Banyuls, F., Font, A. J., Ibanez, J. M., Marti, J.M, & Miralles, J. A. (1997). Numerical {3 + 1} General
#    Relativistic Hydrodynamics: A Local Characteristic Approach. The Astrophysical Journal, 476, 221-231.
#    https://iopscience.iop.org/article/10.1086/303604/fulltext/34434.text.html

#####IMPORT STATEMENTS#####

#Import PythonMHD constants
import Source.PythonMHD_Constants as constants

#Import NumPy for matrix operations
import numpy as np

#####X-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverX_mhd_roe
#Purpose: Calculates the intercell flux between adjacent cells in the x-direction.
#         This function implements Roe's Riemann solver algorithm for a magnetohydrodynamic
#         simulation, using the eigenmatrices provided in [4].
#Input Parameters: leftPrimVars (the left cell-centred primitive variable states)
#                  rightPrimVars (the right cell-centred primitive variable states)
#                  leftConsVars (the left cell-centred conservative variable states)
#                  rightConsVars (the right cell-centred conservative variable states)
#                  faceBx (the x-component of the magnetic field at each
#                          intercell boundary
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the x-direction)
def riemannSolverX_mhd_roe(leftPrimVars, rightPrimVars, leftConsVars, rightConsVars,
                           faceBx, gamma, useEntropyFix, epsilon):
    #Compute the Roe-averaged variables for all of the intercell boundaries in the x-direction

    #Get the density to the left of each intercell boundary
    rho_i = leftPrimVars[0,:]
    #Get the density to the right of each intercell boundary
    rho_i1 = rightPrimVars[0,:]
    #Calculate the square root of each density
    leftDensSqrt = np.sqrt(rho_i)
    rightDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(leftDens) + sqrt(rightDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(leftDensSqrt+rightDensSqrt)
    #Calculate the Roe-averaged density
    roeAvgDens = leftDensSqrt*rightDensSqrt

    #Get the x-velocity to the left of each intercell boundary
    vx_i = leftPrimVars[1,:]
    #Get the x-velocity to the right of each intercell boundary
    vx_i1 = rightPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (leftDensSqrt*vx_i + rightDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity to the left of each intercell boundary
    vy_i = leftPrimVars[2,:]
    #Get the y-velocity to the right of each intercell boundary
    vy_i1 = rightPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (leftDensSqrt*vy_i + rightDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity to the left of each intercell boundary
    vz_i = leftPrimVars[3,:]
    #Get the z-velocity to the right of each intercell boundary
    vz_i1 = rightPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (leftDensSqrt*vz_i + rightDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVx*roeAvgVx + roeAvgVy*roeAvgVy + roeAvgVz*roeAvgVz

    #Get the y-component of the magnetic field to the left of each intercell boundary
    By_i = leftPrimVars[4,:]
    #Get the y-component of the magnetic field to the right of each intercell boundary
    By_i1 = rightPrimVars[4,:]
    #Compute the Roe-averaged y-component of the magnetic field
    roeAvgBy = (rightDensSqrt*By_i+leftDensSqrt*By_i1)*invSqrtDensSum

    #Get the z-component of the magnetic field to the left of each intercell boundary
    Bz_i = leftPrimVars[5,:]
    #Get the z-component of the magnetic field to the right of each intercell boundary
    Bz_i1 = rightPrimVars[5,:]
    #Compute the Roe-averaged z-component of the magnetic field
    roeAvgBz = (rightDensSqrt*Bz_i+leftDensSqrt*Bz_i1)*invSqrtDensSum

    #Get the total magnitude of the magnetic field to the left of each intercell boundary
    B_i = np.sqrt(faceBx*faceBx + By_i*By_i + Bz_i*Bz_i)
    #Get the total magnitude of the magnetic field to the right of each intercell boundary
    B_i1 = np.sqrt(faceBx*faceBx + By_i1*By_i1 + Bz_i1*Bz_i1)
    #Calculate the squared magnetic field intensity for each side of the boundary
    halfLeftBSq = 0.5*(np.square(faceBx) + np.square(By_i) + np.square(Bz_i))
    halfRightBSq = 0.5*(np.square(faceBx) + np.square(By_i1) + np.square(Bz_i1))

    #Get the hydrodynamic pressure to the left of each intercell boundary
    pres_i = leftPrimVars[6,:]
    #Get the hydrodynamic pressure to the right of each intercell boundary
    pres_i1 = rightPrimVars[6,:]

    #Calculate the Roe-averaged enthalpy
    roeAvgH = ((leftConsVars[6] + pres_i + halfLeftBSq)/leftDensSqrt
               + (rightConsVars[6] + pres_i1 + halfRightBSq)/rightDensSqrt)*invSqrtDensSum


    #Start calculating the Roe-averaged wavespeeds

    #For magnetohydrodynamics in the x-direction, there are seven waves types that we need
    #to consider at each intercell boundary:
    #Fast magnetosonic wave with speed vx - cf, where cf is the fast magnetosonic speed
    #Alfven wave with speed vx - ca, where ca is the alfven speed
    #Slow magnetosonic wave with speed vx - cs, where cs is the slow magnetosonic speed
    #Contact discontinuity with speed vx
    #Slow magnetosonic wave with speed vx + cs, where cs is the slow magnetosonic speed
    #Alfven wave with speed vx + ca, where ca is the alfven speed
    #Fast magnetosonic wave with speed vx + cf, where cf is the fast magnetosonic speed

    #Compute some coefficients that will help us more easily calculate the required wave speeds.
    #Note: These are the same coefficients that are used in Athena's implementation of the Roe Riemann solver [3].

    invRoeDens = 1.0/roeAvgDens
    #Calculate a coefficient that is proportional to the difference between the transverse magnetic field strengths
    #to the left and to the right of the intercell boundary.
    BtranCoeff = 0.5*(np.square(By_i - By_i1) + np.square(Bz_i - Bz_i1))/(np.square(leftDensSqrt + rightDensSqrt))
    #Calculate a coefficient that is proportional to the sum of the left and right densities.
    rhoCoeff = 0.5*(rho_i + rho_i1)/roeAvgDens
    #Calculate the square of the Roe-averaged transverse magnetic field strengths.
    BtranSq = roeAvgBy*roeAvgBy + roeAvgBz*roeAvgBz
    Btran = np.sqrt(BtranSq)
    #Use the specific heat ratio, the density coefficient, and the transverse magnetic field strength
    #to calculate a value that will help us find the Roe-averaged fast magnetosonic speed.
    BtranSqStar = ((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)*BtranSq
    BtranStar = np.sqrt(BtranSqStar)
    reducedBtranSqStar = BtranSqStar*invRoeDens

    #Calculate the Roe-averaged Alfven speed
    roeAvgAlfvenSpeedSq = faceBx*faceBx*invRoeDens
    roeAvgAlfvenSpeed = np.sqrt(roeAvgAlfvenSpeedSq)

    #Use the Roe-averaged enthalpy, the Roe-averaged Alfven speed, the transverse magnetic field strength,
    #the Roe-averaged density, the Roe-averaged velocity, and the specific heat ratio to find the Roe-averaged
    #hydrodynamic sound speed.
    enthalpyMinB = roeAvgH - (roeAvgAlfvenSpeedSq + BtranSq*invRoeDens)
    roeAvgSoundSpeedSq = np.maximum((gamma - 1.0)*(enthalpyMinB - 0.5*roeAvgVSq)
                                          - (gamma - 2.0)*BtranCoeff, constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate the Roe-averaged fast magnetosonic speed
    speedSum = roeAvgAlfvenSpeedSq + reducedBtranSqStar + roeAvgSoundSpeedSq
    speedDiff = roeAvgAlfvenSpeedSq + reducedBtranSqStar - roeAvgSoundSpeedSq
    speedSqrt = np.sqrt(speedDiff*speedDiff + 4.0*roeAvgSoundSpeedSq*reducedBtranSqStar)
    roeAvgFastMagSonSpeedSq = 0.5*(speedSum + speedSqrt)
    roeAvgFastMagSonSpeed = np.sqrt(roeAvgFastMagSonSpeedSq)
    #Use the Roe-averaged hydrodynamic sound speed, Alfven speed, and fast magnetosonic speed to find the
    #Roe-averaged slow magnetosonic speed.
    roeAvgSlowMagSonSpeedSq = roeAvgSoundSpeedSq*roeAvgAlfvenSpeedSq/roeAvgFastMagSonSpeedSq
    roeAvgSlowMagSonSpeed = np.sqrt(roeAvgSlowMagSonSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=leftPrimVars.shape)
    eigenVals[0,:] = roeAvgVx - roeAvgFastMagSonSpeed
    eigenVals[1,:] = roeAvgVx - roeAvgAlfvenSpeed
    eigenVals[2,:] = roeAvgVx - roeAvgSlowMagSonSpeed
    eigenVals[3,:] = roeAvgVx
    eigenVals[4,:] = roeAvgVx + roeAvgSlowMagSonSpeed
    eigenVals[5,:] = roeAvgVx + roeAvgAlfvenSpeed
    eigenVals[6,:] = roeAvgVx + roeAvgFastMagSonSpeed

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983) [6].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))
        eigenVals[5,:] = eigenVals[5,:] + np.sign(eigenVals[5,:])*(np.abs(eigenVals[5,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[5,:])/(4.0*epsilon))
        eigenVals[6,:] = eigenVals[6,:] + np.sign(eigenVals[6,:])*(np.abs(eigenVals[6,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[6,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    if len(leftPrimVars.shape) == 2: #if the sim is 1D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1]))
    elif len(leftPrimVars.shape) == 3: #if the sim is 2D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1],
                                           leftPrimVars.shape[2]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1],
                                          leftPrimVars.shape[2]))
    else: #if the sim is 3D
        rightEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                           leftPrimVars.shape[0],
                                           leftPrimVars.shape[1],
                                           leftPrimVars.shape[2],
                                           leftPrimVars.shape[3]))
        leftEigenmatrix = np.zeros(shape=(leftPrimVars.shape[0],
                                          leftPrimVars.shape[0],
                                          leftPrimVars.shape[1],
                                          leftPrimVars.shape[2],
                                          leftPrimVars.shape[3]))

    #Calculate the fast and slow alpha coefficients
    fastAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    slowAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    fastAlphaOneIndices = roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0
    fastAlpha[fastAlphaOneIndices] = 1.0
    slowAlphaOneIndices = np.logical_and(np.logical_not(fastAlphaOneIndices),roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0)
    slowAlpha[slowAlphaOneIndices] = 1.0
    secondFastAlphaOneIndices = np.logical_and(np.logical_not(np.logical_or(fastAlphaOneIndices,slowAlphaOneIndices)),
                                               roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)
    fastAlpha[secondFastAlphaOneIndices] = 1.0
    #Find the indices where we can apply the conventional formula for fastAlpha and slowAlpha.
    calcAlphaIndices = np.logical_not(
        np.logical_or(roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0,
                      np.logical_or(roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0,
                                    roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)))
    #Calculate fastAlpha at these indices as sqrt((roeAvgSoundSpeed^2 - roeAvgSlowMagSonSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    fastAlpha[calcAlphaIndices] = np.sqrt((roeAvgSoundSpeedSq
                                           - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])
    #Calculate slowAlpha at these indices as sqrt((roeAvgFastMagSonSpeed^2 - roeAvgSoundSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    slowAlpha[calcAlphaIndices] = np.sqrt((roeAvgFastMagSonSpeedSq
                                           - roeAvgSoundSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])

    #Get the sign of the x-component of the magnetic field
    bxSign = np.sign(faceBx)
    bxSign[bxSign == 0] = 1

    sqrtRoeDens = np.sqrt(roeAvgDens)
    invSqrtRoeDens = 1.0/sqrtRoeDens
    #Calculate Qf, the product of the fast magnetosonic speed, fastAlpha, and the sign of Bx
    coeffQf = roeAvgFastMagSonSpeed*fastAlpha*bxSign
    #Calculate Qs, the product of the slow magnetosonic speed, slowAlpha, and the sign of Bx
    coeffQs = roeAvgSlowMagSonSpeed*slowAlpha*bxSign
    #Calculate AfPrime as roeAvgSoundSpeed*fastAlpha/sqrt(roeAvgDens)
    coeffAfPrime = roeAvgSoundSpeed*fastAlpha*invSqrtRoeDens
    #Calculate AsPrime as roeAvgSoundSpeed*slowAlpha/sqrt(roeAvgDens)
    coeffAsPrime = roeAvgSoundSpeed*slowAlpha*invSqrtRoeDens

    #Calculate the betaY and betaZ coefficients
    betaY = np.zeros(shape=BtranSq.shape)
    betaZ = np.zeros(shape=BtranSq.shape)
    #Set betaY to 1.0 if the transverse magnetic field strength is zero
    betaY[Btran == 0.0] = 1.0
    #If the transverse magnetic field strength is greater than zero,
    #calculate betaY as roeAvgBy/Btran and betaZ as roeAvgBz/Btran
    betaY[Btran > 0.0] = roeAvgBy[BtranSq > 0.0]/Btran[Btran > 0.0]
    betaZ[Btran > 0.0] = roeAvgBz[BtranSq > 0.0]/Btran[Btran > 0.0]

    #Calculate additional coefficients that will simplify the eigenvector calculations.
    betaYStar = betaY/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    betaZStar = betaZ/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    speedBeta = roeAvgVy*betaYStar + roeAvgVz*betaZStar
    betaStarSq = betaYStar*betaYStar + betaZStar*betaZStar
    coeffAfB = coeffAfPrime*BtranStar*betaStarSq
    coeffAsB = coeffAsPrime*BtranStar*betaStarSq

    #Assemble the left and right eigenvectors for Roe's method,
    #using the formulas in Athena's Roe solver [3].
    #Note: These eigenmatrices do not exactly match the eigenmatrices
    #in the Athena methods paper [4] because PythonMHD orders MHD
    #variables differently than Athena.
    #(Athena: density, momenta, energy, magnetic field components
    # PythonMHD: density, momenta, magnetic field components, energy)

    #Add values to the right eigenmatrix
    rightEigenmatrix[0,0,:] = fastAlpha
    rightEigenmatrix[0,2,:] = slowAlpha
    rightEigenmatrix[0,3,:] = 1.0
    rightEigenmatrix[0,4,:] = slowAlpha
    rightEigenmatrix[0,6,:] = fastAlpha

    rightEigenmatrix[1,0,:] = fastAlpha*eigenVals[0]
    rightEigenmatrix[1,2,:] = slowAlpha*eigenVals[2]
    rightEigenmatrix[1,3,:] = roeAvgVx
    rightEigenmatrix[1,4,:] = slowAlpha*eigenVals[4]
    rightEigenmatrix[1,6,:] = fastAlpha*eigenVals[6]

    fastAlphaVy = fastAlpha*roeAvgVy
    slowAlphaVy = slowAlpha*roeAvgVy
    coeffQsBetaYStar = coeffQs*betaYStar
    coeffQfBetaYStar = coeffQf*betaYStar
    rightEigenmatrix[2,0,:] = fastAlphaVy + coeffQsBetaYStar
    rightEigenmatrix[2,1,:] = -betaZ
    rightEigenmatrix[2,2,:] = slowAlphaVy - coeffQfBetaYStar
    rightEigenmatrix[2,3,:] = roeAvgVy
    rightEigenmatrix[2,4,:] = slowAlphaVy + coeffQfBetaYStar
    rightEigenmatrix[2,5,:] = betaZ
    rightEigenmatrix[2,6,:] = fastAlphaVy - coeffQsBetaYStar

    fastAlphaVz = fastAlpha*roeAvgVz
    slowAlphaVz = slowAlpha*roeAvgVz
    coeffQsBetaZStar = coeffQs*betaZStar
    coeffQfBetaZStar = coeffQf*betaZStar
    rightEigenmatrix[3,0,:] = fastAlphaVz + coeffQsBetaZStar
    rightEigenmatrix[3,1,:] = betaY
    rightEigenmatrix[3,2,:] = slowAlphaVz - coeffQfBetaZStar
    rightEigenmatrix[3,3,:] = roeAvgVz
    rightEigenmatrix[3,4,:] = slowAlphaVz + coeffQfBetaZStar
    rightEigenmatrix[3,5,:] = -betaY
    rightEigenmatrix[3,6,:] = fastAlphaVz - coeffQsBetaZStar

    rightEigenmatrix[6,0,:] = fastAlpha*(enthalpyMinB - roeAvgVx*roeAvgFastMagSonSpeed) + coeffQs*speedBeta + coeffAsB
    rightEigenmatrix[6,1,:] = -(roeAvgVy*betaZ - roeAvgVz*betaY)
    rightEigenmatrix[6,2,:] = slowAlpha*(enthalpyMinB - roeAvgVx*roeAvgSlowMagSonSpeed) - coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,3,:] = 0.5*roeAvgVSq + (gamma - 2.0)*BtranCoeff/(gamma - 1.0)
    rightEigenmatrix[6,4,:] = slowAlpha*(enthalpyMinB + roeAvgVx*roeAvgSlowMagSonSpeed) + coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,5,:] = -rightEigenmatrix[6,1,:]
    rightEigenmatrix[6,6,:] = fastAlpha*(enthalpyMinB + roeAvgVx*roeAvgFastMagSonSpeed) - coeffQs*speedBeta + coeffAsB

    rightEigenmatrix[4,0,:] = coeffAsPrime*betaYStar
    rightEigenmatrix[4,1,:] = -betaZ*bxSign*invSqrtRoeDens
    rightEigenmatrix[4,2,:] = -coeffAfPrime*betaYStar
    rightEigenmatrix[4,4,:] = rightEigenmatrix[4,2,:]
    rightEigenmatrix[4,5,:] = rightEigenmatrix[4,1,:]
    rightEigenmatrix[4,6,:] = rightEigenmatrix[4,0,:]

    rightEigenmatrix[5,0,:] = coeffAsPrime*betaZStar
    rightEigenmatrix[5,1,:] = betaY*bxSign*invSqrtRoeDens
    rightEigenmatrix[5,2,:] = -coeffAfPrime * betaZStar
    rightEigenmatrix[5,4,:] = rightEigenmatrix[5,2,:]
    rightEigenmatrix[5,5,:] = rightEigenmatrix[5,1,:]
    rightEigenmatrix[5,6,:] = rightEigenmatrix[5,0,:]

    #Calculate coefficients that will simplify
    #the left eigenvector calculations
    normFactor = 0.5/roeAvgSoundSpeedSq
    coeffCff = normFactor*fastAlpha*roeAvgFastMagSonSpeed
    coeffCss = normFactor*slowAlpha*roeAvgSlowMagSonSpeed
    coeffQf *= normFactor
    coeffQs *= normFactor
    coeffAf = normFactor*coeffAfPrime*roeAvgDens
    coeffAs = normFactor*coeffAsPrime*roeAvgDens
    coeffAfB = normFactor*coeffAfPrime*BtranStar
    coeffAsB = normFactor*coeffAsPrime*BtranStar

    normFactor *= (gamma - 1.0)
    fastAlpha *= normFactor
    slowAlpha *= normFactor
    betaYCoeff = betaYStar/betaStarSq
    betaZCoeff = betaZStar/betaStarSq
    speedBetaStar = roeAvgVy*betaYCoeff + roeAvgVz*betaZCoeff
    normFactor *= 2.0

    #Add values to the left eigenmatrix
    leftEigenmatrix[0,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed + roeAvgVx) \
                                  - coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[0,1,:] = -1.0*fastAlpha*roeAvgVx - coeffCff
    leftEigenmatrix[0,2,:] = -1.0*fastAlpha*roeAvgVy + coeffQs*betaYCoeff
    leftEigenmatrix[0,3,:] = -1.0*fastAlpha*roeAvgVz + coeffQs*betaZCoeff
    leftEigenmatrix[0,6,:] = fastAlpha
    leftEigenmatrix[0,4,:] = coeffAs*betaYCoeff - fastAlpha*roeAvgBy
    leftEigenmatrix[0,5,:] = coeffAs*betaZCoeff - fastAlpha*roeAvgBz

    leftEigenmatrix[1,0,:] = 0.5*(roeAvgVy*betaZ - roeAvgVz*betaY)
    leftEigenmatrix[1,2,:] = -0.5*betaZ
    leftEigenmatrix[1,3,:] = 0.5*betaY
    leftEigenmatrix[1,4,:] = -0.5*sqrtRoeDens*betaZ*bxSign
    leftEigenmatrix[1,5,:] = 0.5*sqrtRoeDens*betaY*bxSign

    leftEigenmatrix[2,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed + roeAvgVx) \
                                  + coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[2,1,:] = -slowAlpha*roeAvgVx - coeffCss
    leftEigenmatrix[2,2,:] = -slowAlpha*roeAvgVy - coeffQf*betaYCoeff
    leftEigenmatrix[2,3,:] = -slowAlpha*roeAvgVz - coeffQf*betaZCoeff
    leftEigenmatrix[2,6,:] = slowAlpha
    leftEigenmatrix[2,4,:] = -coeffAf*betaYCoeff - slowAlpha*roeAvgBy
    leftEigenmatrix[2,5,:] = -coeffAf*betaZCoeff - slowAlpha*roeAvgBz

    leftEigenmatrix[3,0,:] = 1.0 - normFactor*(0.5*roeAvgVSq - (gamma - 2.0)*BtranCoeff/(gamma - 1.0))
    leftEigenmatrix[3,1,:] = normFactor*roeAvgVx
    leftEigenmatrix[3,2,:] = normFactor*roeAvgVy
    leftEigenmatrix[3,3,:] = normFactor*roeAvgVz
    leftEigenmatrix[3,6,:] = -1.0*normFactor
    leftEigenmatrix[3,4,:] = normFactor*roeAvgBy
    leftEigenmatrix[3,5,:] = normFactor*roeAvgBz

    leftEigenmatrix[4,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed - roeAvgVx) \
                                  - coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[4,1,:] = -slowAlpha*roeAvgVx + coeffCss
    leftEigenmatrix[4,2,:] = -slowAlpha*roeAvgVy + coeffQf*betaYCoeff
    leftEigenmatrix[4,3,:] = -slowAlpha*roeAvgVz + coeffQf*betaZCoeff
    leftEigenmatrix[4,6,:] = slowAlpha
    leftEigenmatrix[4,4,:] = leftEigenmatrix[2,4,:]
    leftEigenmatrix[4,5,:] = leftEigenmatrix[2,5,:]

    leftEigenmatrix[5,0,:] = -leftEigenmatrix[1,0,:]
    leftEigenmatrix[5,2,:] = -leftEigenmatrix[1,2,:]
    leftEigenmatrix[5,3,:] = -leftEigenmatrix[1,3,:]
    leftEigenmatrix[5,4,:] = leftEigenmatrix[1,4,:]
    leftEigenmatrix[5,5,:] = leftEigenmatrix[1,5,:]

    leftEigenmatrix[6,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed - roeAvgVx) \
                                  + coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[6,1,:] = -fastAlpha*roeAvgVx + coeffCff
    leftEigenmatrix[6,2,:] = -fastAlpha*roeAvgVy - coeffQs*betaYCoeff
    leftEigenmatrix[6,3,:] = -fastAlpha*roeAvgVz - coeffQs*betaZCoeff
    leftEigenmatrix[6,6,:] = fastAlpha
    leftEigenmatrix[6,4,:] = leftEigenmatrix[0,4,:]
    leftEigenmatrix[6,5,:] = leftEigenmatrix[0,5,:]

    #Calculate the flux variables for the cell to the left of the intercell boundary.
    leftCellFlux = np.zeros(shape=leftConsVars.shape)
    leftCellFlux[0] = leftConsVars[1]
    leftCellFlux[1] = leftConsVars[1]*vx_i
    leftCellFlux[2] = leftConsVars[1]*vy_i
    leftCellFlux[3] = leftConsVars[1]*vz_i
    leftCellFlux[1] += pres_i
    leftCellFlux[6] = (leftConsVars[6]+pres_i)*vx_i
    leftCellFlux[1] -= 0.5*(faceBx*faceBx - np.square(By_i) - np.square(Bz_i))
    leftCellFlux[2] -= faceBx*By_i
    leftCellFlux[3] -= faceBx*Bz_i
    leftCellFlux[6] += (halfLeftBSq*vx_i - faceBx*(faceBx * vx_i + By_i * vy_i + Bz_i * vz_i))
    leftCellFlux[4] = By_i*vx_i - faceBx*vy_i
    leftCellFlux[5] = Bz_i*vx_i - faceBx*vz_i

    #Calculate the flux variables for the cell to the right of the intercell boundary.
    rightCellFlux = np.zeros(shape=rightConsVars.shape)
    rightCellFlux[0] = rightConsVars[1]
    rightCellFlux[1] = rightConsVars[1]*vx_i1
    rightCellFlux[2] = rightConsVars[1]*vy_i1
    rightCellFlux[3] = rightConsVars[1]*vz_i1
    rightCellFlux[1] += pres_i1
    rightCellFlux[6] = (rightConsVars[6]+pres_i1)*vx_i1
    rightCellFlux[1] -= 0.5*(faceBx*faceBx - np.square(By_i1) - np.square(Bz_i1))
    rightCellFlux[2] -= faceBx*By_i1
    rightCellFlux[3] -= faceBx*Bz_i1
    rightCellFlux[6] += (halfRightBSq*vx_i1 - faceBx*(faceBx * vx_i1 + By_i1 * vy_i1 + Bz_i1 * vz_i1))
    rightCellFlux[4] = By_i1*vx_i1 - faceBx*vy_i1
    rightCellFlux[5] = Bz_i1*vx_i1 - faceBx*vz_i1

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = rightConsVars - leftConsVars
    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [7].)
    # consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    # for i in range(consVarsDiff.shape[0]):
    #     for j in range(consVarsDiff.shape[0]):
    #         consVarsDiffProj[i] += leftEigenmatrix[i,j,:]*consVarsDiff[j]
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        consVarsDiffProj[i] += leftEigenmatrix[i,0,:]*consVarsDiff[0]
        consVarsDiffProj[i] += leftEigenmatrix[i,1,:]*consVarsDiff[1]
        consVarsDiffProj[i] += leftEigenmatrix[i,2,:]*consVarsDiff[2]
        consVarsDiffProj[i] += leftEigenmatrix[i,3,:]*consVarsDiff[3]
        consVarsDiffProj[i] += leftEigenmatrix[i,6,:]*consVarsDiff[6]
        consVarsDiffProj[i] += leftEigenmatrix[i,4,:]*consVarsDiff[4]
        consVarsDiffProj[i] += leftEigenmatrix[i,5,:]*consVarsDiff[5]

    #Calculate the amplitudes associated with each of the waves.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]
    amps[5] = 0.5*np.abs(eigenVals[5,:])*consVarsDiffProj[5]
    amps[6] = 0.5*np.abs(eigenVals[6,:])*consVarsDiffProj[6]

    #Calculate the intercell flux as F_(i-1/2) = 0.5*(F_(i-1) + F_i) + F_roe
    intercellFlux = 0.5 * (leftCellFlux + rightCellFlux) #First take the average of the left
                                                         #and right cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    #(Note: The negative sign is here because we calculate the difference in
    #       conservative variables as rightConsVars - leftConsVars instead of
    #       leftConsVars - rightConsVars. (See page 146 in [4] to see how
    #       the Roe flux formula is presented in the Athena methods paper
    #       (Stone et al., 2008)).
    # for i in range(intercellFlux.shape[0]):
    #     for j in range(intercellFlux.shape[0]):
    #         intercellFlux[i] -= amps[j]*rightEigenmatrix[i,j,:] #multiplying by the right eigenmatrix gets us
    #                                                             #from characteristic variables back into
    #                                                             #conservative variables (technically the flux of
    #                                                             #conservative variables)
    for i in range(intercellFlux.shape[0]):
        #Multiplying by the right eigenmatrix gets us from characteristic variables back into
        #conservative variables (technically the flux of conservative variables)
        intercellFlux[i] -= amps[0]*rightEigenmatrix[i,0,:]
        intercellFlux[i] -= amps[1]*rightEigenmatrix[i,1,:]
        intercellFlux[i] -= amps[2]*rightEigenmatrix[i,2,:]
        intercellFlux[i] -= amps[3]*rightEigenmatrix[i,3,:]
        intercellFlux[i] -= amps[4]*rightEigenmatrix[i,4,:]
        intercellFlux[i] -= amps[5]*rightEigenmatrix[i,5,:]
        intercellFlux[i] -= amps[6]*rightEigenmatrix[i,6,:]

    #If the smallest eigenvalue (vx - cf) is greater than zero,
    #return the left cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the x-direction,
    # the flow is super/hypersonic if the x-velocity is greater than
    # the fast magnetosonic wave speed. We make the same correction if
    # vx is equal to the fast magnetosonic speed, in order to
    # prevent us from ever having a fast magnetosonic wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    intercellFlux[:,minEigenValIsPositiveOrZero] = leftCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vx + cs) is less or equal to zero,
    #return the right cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative x-direction (i.e., regions in
    # the fluid where |vx| > cf and vx < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly
    # in the positive x-direction (i.e., to the right), we use the left cell
    # flux. When the fluid is moving too quickly in the negative x-direction
    # (i.e., to the left), we use the right cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[6,:] <= 0.0
    intercellFlux[:,maxEigenValIsNegativeOrZero] = rightCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the x-direction
    return intercellFlux


#####Y-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverY_mhd_roe
#Purpose: Calculates the intercell flux between adjacent cells in the y-direction.
#         This function implements Roe's Riemann solver algorithm for a magnetohydrodynamic
#         simulation, using the eigenmatrices provided in [4].
#Input Parameters: topPrimVars (the top cell-centred primitive variable states)
#                  bottomPrimVars (the bottom cell-centred primitive variable states)
#                  topConsVars (the top cell-centred conservative variable states)
#                  bottomConsVars (the bottom cell-centred conservative variable states)
#                  faceBy (the y-component of the magnetic field at each
#                          intercell boundary)
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the y-direction)
def riemannSolverY_mhd_roe(topPrimVars, bottomPrimVars, topConsVars, bottomConsVars,
                           faceBy, gamma, useEntropyFix, epsilon):
    #Compute the Roe-averaged variables for all of the intercell boundaries in the y-direction

    #Get the density above each intercell boundary
    rho_i = topPrimVars[0,:]
    #Get the density below each intercell boundary
    rho_i1 = bottomPrimVars[0,:]
    #Calculate the square root of each density
    topDensSqrt = np.sqrt(rho_i)
    bottomDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(leftDens) + sqrt(rightDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(topDensSqrt+bottomDensSqrt)
    #Calculate the Roe-averaged density
    roeAvgDens = topDensSqrt*bottomDensSqrt

    #Get the x-velocity above each intercell boundary
    vx_i = topPrimVars[1,:]
    #Get the x-velocity below each intercell boundary
    vx_i1 = bottomPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (topDensSqrt*vx_i + bottomDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity above each intercell boundary
    vy_i = topPrimVars[2,:]
    #Get the y-velocity below each intercell boundary
    vy_i1 = bottomPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (topDensSqrt*vy_i + bottomDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity above each intercell boundary
    vz_i = topPrimVars[3,:]
    #Get the z-velocity below each intercell boundary
    vz_i1 = bottomPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (topDensSqrt*vz_i + bottomDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVy*roeAvgVy + roeAvgVz*roeAvgVz + roeAvgVx*roeAvgVx

    #Get the z-component of the magnetic field above each intercell boundary
    Bz_i = topPrimVars[4,:]
    #Get the z-component of the magnetic field below each intercell boundary
    Bz_i1 = bottomPrimVars[4,:]
    #Compute the Roe-averaged z-component of the magnetic field
    roeAvgBz = (bottomDensSqrt*Bz_i+topDensSqrt*Bz_i1)*invSqrtDensSum

    #Get the x-component of the magnetic field above each intercell boundary
    Bx_i = topPrimVars[5,:]
    #Get the x-component of the magnetic field below each intercell boundary
    Bx_i1 = bottomPrimVars[5,:]
    #Compute the Roe-averaged x-component of the magnetic field
    roeAvgBx = (bottomDensSqrt*Bx_i+topDensSqrt*Bx_i1)*invSqrtDensSum

    #Calculate the squared magnetic field intensity for each side of the boundary
    halfTopBSq = 0.5*(np.square(faceBy) + np.square(Bz_i) + np.square(Bx_i))
    halfBottomBSq = 0.5*(np.square(faceBy) + np.square(Bz_i1) + np.square(Bx_i1))

    #Get the hydrodynamic pressure above each intercell boundary
    pres_i = topPrimVars[6,:]
    #Get the hydrodynamic pressure below each intercell boundary
    pres_i1 = bottomPrimVars[6,:]

    #Calculate the Roe-averaged enthalpy
    roeAvgH = ((topConsVars[6] + pres_i + halfTopBSq)/topDensSqrt
               + (bottomConsVars[6] + pres_i1 + halfBottomBSq)/bottomDensSqrt)*invSqrtDensSum


    #Start calculating the Roe-averaged wavespeeds

    #For magnetohydrodynamics in the y-direction, there are seven waves types that we need
    #to consider at each intercell boundary:
    #Fast magnetosonic wave with speed vy - cf, where cf is the fast magnetosonic speed
    #Alfven wave with speed vy - ca, where ca is the alfven speed
    #Slow magnetosonic wave with speed vy - cs, where cs is the slow magnetosonic speed
    #Contact discontinuity with speed vy
    #Slow magnetosonic wave with speed vy + cs, where cs is the slow magnetosonic speed
    #Alfven wave with speed vy + ca, where ca is the alfven speed
    #Fast magnetosonic wave with speed vy + cf, where cf is the fast magnetosonic speed

    #Compute some coefficients that will help us more easily calculate the required wave speeds.
    #Note: These are the same coefficients that are used in Athena's implementation of the Roe Riemann solver [3].

    invRoeDens = 1.0/roeAvgDens
    #Calculate a coefficient that is proportional to the difference between the transverse magnetic field strengths
    #above and below the intercell boundary.
    BtranCoeff = 0.5*(np.square(Bz_i - Bz_i1) + np.square(Bx_i - Bx_i1))/(np.square(topDensSqrt + bottomDensSqrt))
    #Calculate a coefficient that is proportional to the sum of the upper and lower densities.
    rhoCoeff = 0.5*(rho_i + rho_i1)/roeAvgDens
    #Calculate the square of the Roe-averaged transverse magnetic field strengths.
    BtranSq = roeAvgBz*roeAvgBz + roeAvgBx*roeAvgBx
    Btran = np.sqrt(BtranSq)
    #Use the specific heat ratio, the density coefficient, and the transverse magnetic field strength
    #to calculate a value that will help us find the Roe-averaged fast magnetosonic speed.
    BtranSqStar = ((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)*BtranSq
    BtranStar = np.sqrt(BtranSqStar)
    reducedBtranSqStar = BtranSqStar*invRoeDens

    #Calculate the Roe-averaged Alfven speed
    roeAvgAlfvenSpeedSq = faceBy*faceBy*invRoeDens
    roeAvgAlfvenSpeed = np.sqrt(roeAvgAlfvenSpeedSq)

    #Use the Roe-averaged enthalpy, the Roe-averaged Alfven speed, the transverse magnetic field strength,
    #the Roe-averaged density, the Roe-averaged velocity, and the specific heat ratio to find the Roe-averaged
    #hydrodynamic sound speed.
    enthalpyMinB = roeAvgH - (roeAvgAlfvenSpeedSq + BtranSq*invRoeDens)
    roeAvgSoundSpeedSq = np.maximum((gamma - 1.0)*(enthalpyMinB - 0.5*roeAvgVSq)
                                          - (gamma - 2.0)*BtranCoeff, constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate the Roe-averaged fast magnetosonic speed
    speedSum = roeAvgAlfvenSpeedSq + reducedBtranSqStar + roeAvgSoundSpeedSq
    speedDiff = roeAvgAlfvenSpeedSq + reducedBtranSqStar - roeAvgSoundSpeedSq
    speedSqrt = np.sqrt(speedDiff*speedDiff + 4.0*roeAvgSoundSpeedSq*reducedBtranSqStar)
    roeAvgFastMagSonSpeedSq = 0.5*(speedSum + speedSqrt)
    roeAvgFastMagSonSpeed = np.sqrt(roeAvgFastMagSonSpeedSq)
    #Use the Roe-averaged hydrodynamic sound speed, Alfven speed, and fast magnetosonic speed to find the
    #Roe-averaged slow magnetosonic speed.
    roeAvgSlowMagSonSpeedSq = roeAvgSoundSpeedSq*roeAvgAlfvenSpeedSq/roeAvgFastMagSonSpeedSq
    roeAvgSlowMagSonSpeed = np.sqrt(roeAvgSlowMagSonSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=topPrimVars.shape)
    eigenVals[0,:] = roeAvgVy - roeAvgFastMagSonSpeed
    eigenVals[1,:] = roeAvgVy - roeAvgAlfvenSpeed
    eigenVals[2,:] = roeAvgVy - roeAvgSlowMagSonSpeed
    eigenVals[3,:] = roeAvgVy
    eigenVals[4,:] = roeAvgVy + roeAvgSlowMagSonSpeed
    eigenVals[5,:] = roeAvgVy + roeAvgAlfvenSpeed
    eigenVals[6,:] = roeAvgVy + roeAvgFastMagSonSpeed

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983) [6].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))
        eigenVals[5,:] = eigenVals[5,:] + np.sign(eigenVals[5,:])*(np.abs(eigenVals[5,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[5,:])/(4.0*epsilon))
        eigenVals[6,:] = eigenVals[6,:] + np.sign(eigenVals[6,:])*(np.abs(eigenVals[6,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[6,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    if len(topPrimVars.shape) == 3: #if the sim is 2D
        rightEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                           topPrimVars.shape[0],
                                           topPrimVars.shape[1],
                                           topPrimVars.shape[2]))
        leftEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                          topPrimVars.shape[0],
                                          topPrimVars.shape[1],
                                          topPrimVars.shape[2]))
    else: #if the sim is 3D
        rightEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                           topPrimVars.shape[0],
                                           topPrimVars.shape[1],
                                           topPrimVars.shape[2],
                                           topPrimVars.shape[3]))
        leftEigenmatrix = np.zeros(shape=(topPrimVars.shape[0],
                                          topPrimVars.shape[0],
                                          topPrimVars.shape[1],
                                          topPrimVars.shape[2],
                                          topPrimVars.shape[3]))

    #Calculate the fast and slow alpha coefficients
    fastAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    slowAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    fastAlphaOneIndices = roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0
    fastAlpha[fastAlphaOneIndices] = 1.0
    slowAlphaOneIndices = np.logical_and(np.logical_not(fastAlphaOneIndices),roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0)
    slowAlpha[slowAlphaOneIndices] = 1.0
    secondFastAlphaOneIndices = np.logical_and(np.logical_not(np.logical_or(fastAlphaOneIndices,slowAlphaOneIndices)),
                                               roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)
    fastAlpha[secondFastAlphaOneIndices] = 1.0
    #Find the indices where we can apply the conventional formula for fastAlpha and slowAlpha.
    calcAlphaIndices = np.logical_not(
        np.logical_or(roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0,
                      np.logical_or(roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0,
                                    roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)))
    #Calculate fastAlpha at these indices as sqrt((roeAvgSoundSpeed^2 - roeAvgSlowMagSonSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    fastAlpha[calcAlphaIndices] = np.sqrt((roeAvgSoundSpeedSq
                                           - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])
    #Calculate slowAlpha at these indices as sqrt((roeAvgFastMagSonSpeed^2 - roeAvgSoundSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    slowAlpha[calcAlphaIndices] = np.sqrt((roeAvgFastMagSonSpeedSq
                                           - roeAvgSoundSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])

    #Get the sign of the y-component of the magnetic field
    bySign = np.sign(faceBy)
    bySign[bySign == 0] = 1

    sqrtRoeDens = np.sqrt(roeAvgDens)
    invSqrtRoeDens = 1.0/sqrtRoeDens
    #Calculate Qf, the product of the fast magnetosonic speed, fastAlpha, and the sign of By
    coeffQf = roeAvgFastMagSonSpeed*fastAlpha*bySign
    #Calculate Qs, the product of the slow magnetosonic speed, slowAlpha, and the sign of By
    coeffQs = roeAvgSlowMagSonSpeed*slowAlpha*bySign
    #Calculate AfPrime as roeAvgSoundSpeed*fastAlpha/sqrt(roeAvgDens)
    coeffAfPrime = roeAvgSoundSpeed*fastAlpha*invSqrtRoeDens
    #Calculate AsPrime as roeAvgSoundSpeed*slowAlpha/sqrt(roeAvgDens)
    coeffAsPrime = roeAvgSoundSpeed*slowAlpha*invSqrtRoeDens

    #Calculate the betaZ and betaX coefficients
    betaZ = np.zeros(shape=BtranSq.shape)
    betaX = np.zeros(shape=BtranSq.shape)
    #Set betaZ to 1.0 if the transverse magnetic field strength is zero
    betaZ[Btran == 0.0] = 1.0
    #If the transverse magnetic field strength is greater than zero,
    #calculate betaZ as roeAvgBz/Btran and betaX as roeAvgBx/Btran
    betaZ[Btran > 0.0] = roeAvgBz[Btran > 0.0]/Btran[Btran > 0.0]
    betaX[Btran > 0.0] = roeAvgBx[Btran > 0.0]/Btran[Btran > 0.0]

    #Calculate additional coefficients that will simplify the eigenvector calculations.
    betaZStar = betaZ/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    betaXStar = betaX/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    speedBeta = roeAvgVz*betaZStar + roeAvgVx*betaXStar
    betaStarSq = betaZStar*betaZStar + betaXStar*betaXStar
    coeffAfB = coeffAfPrime*BtranStar*betaStarSq
    coeffAsB = coeffAsPrime*BtranStar*betaStarSq

    #Assemble the left and right eigenvectors for Roe's method,
    #using the formulas in Athena's Roe solver [3].
    #Note: These eigenmatrices do not exactly match the eigenmatrices
    #in the Athena methods paper [4] because PythonMHD orders MHD
    #variables differently than Athena.
    #(Athena: density, momenta, energy, magnetic field components
    # PythonMHD: density, momenta, magnetic field components, energy)

    #Add values to the right eigenmatrix
    rightEigenmatrix[0,0,:] = fastAlpha
    rightEigenmatrix[0,2,:] = slowAlpha
    rightEigenmatrix[0,3,:] = 1.0
    rightEigenmatrix[0,4,:] = slowAlpha
    rightEigenmatrix[0,6,:] = fastAlpha

    rightEigenmatrix[2,0,:] = fastAlpha*eigenVals[0]
    rightEigenmatrix[2,2,:] = slowAlpha*eigenVals[2]
    rightEigenmatrix[2,3,:] = roeAvgVy
    rightEigenmatrix[2,4,:] = slowAlpha*eigenVals[4]
    rightEigenmatrix[2,6,:] = fastAlpha*eigenVals[6]

    fastAlphaVz = fastAlpha*roeAvgVz
    slowAlphaVz = slowAlpha*roeAvgVz
    coeffQsBetaZStar = coeffQs*betaZStar
    coeffQfBetaZStar = coeffQf*betaZStar
    rightEigenmatrix[3,0,:] = fastAlphaVz + coeffQsBetaZStar
    rightEigenmatrix[3,1,:] = -betaX
    rightEigenmatrix[3,2,:] = slowAlphaVz - coeffQfBetaZStar
    rightEigenmatrix[3,3,:] = roeAvgVz
    rightEigenmatrix[3,4,:] = slowAlphaVz + coeffQfBetaZStar
    rightEigenmatrix[3,5,:] = betaX
    rightEigenmatrix[3,6,:] = fastAlphaVz - coeffQsBetaZStar

    fastAlphaVx = fastAlpha*roeAvgVx
    slowAlphaVx = slowAlpha*roeAvgVx
    coeffQsBetaXStar = coeffQs*betaXStar
    coeffQfBetaXStar = coeffQf*betaXStar
    rightEigenmatrix[1,0,:] = fastAlphaVx + coeffQsBetaXStar
    rightEigenmatrix[1,1,:] = betaZ
    rightEigenmatrix[1,2,:] = slowAlphaVx - coeffQfBetaXStar
    rightEigenmatrix[1,3,:] = roeAvgVx
    rightEigenmatrix[1,4,:] = slowAlphaVx + coeffQfBetaXStar
    rightEigenmatrix[1,5,:] = -betaZ
    rightEigenmatrix[1,6,:] = fastAlphaVx - coeffQsBetaXStar

    rightEigenmatrix[6,0,:] = fastAlpha*(enthalpyMinB - roeAvgVy*roeAvgFastMagSonSpeed) + coeffQs*speedBeta + coeffAsB
    rightEigenmatrix[6,1,:] = -(roeAvgVz*betaX - roeAvgVx*betaZ)
    rightEigenmatrix[6,2,:] = slowAlpha*(enthalpyMinB - roeAvgVy*roeAvgSlowMagSonSpeed) - coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,3,:] = 0.5*roeAvgVSq + (gamma - 2.0)*BtranCoeff/(gamma - 1.0)
    rightEigenmatrix[6,4,:] = slowAlpha*(enthalpyMinB + roeAvgVy*roeAvgSlowMagSonSpeed) + coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,5,:] = -rightEigenmatrix[6,1,:]
    rightEigenmatrix[6,6,:] = fastAlpha*(enthalpyMinB + roeAvgVy*roeAvgFastMagSonSpeed) - coeffQs*speedBeta + coeffAsB

    rightEigenmatrix[4,0,:] = coeffAsPrime*betaZStar
    rightEigenmatrix[4,1,:] = -betaX*bySign*invSqrtRoeDens
    rightEigenmatrix[4,2,:] = -coeffAfPrime*betaZStar
    rightEigenmatrix[4,4,:] = rightEigenmatrix[4,2,:]
    rightEigenmatrix[4,5,:] = rightEigenmatrix[4,1,:]
    rightEigenmatrix[4,6,:] = rightEigenmatrix[4,0,:]

    rightEigenmatrix[5,0,:] = coeffAsPrime*betaXStar
    rightEigenmatrix[5,1,:] = betaZ*bySign*invSqrtRoeDens
    rightEigenmatrix[5,2,:] = -coeffAfPrime * betaXStar
    rightEigenmatrix[5,4,:] = rightEigenmatrix[5,2,:]
    rightEigenmatrix[5,5,:] = rightEigenmatrix[5,1,:]
    rightEigenmatrix[5,6,:] = rightEigenmatrix[5,0,:]

    #Calculate coefficients that will simplify
    #the left eigenvector calculations
    normFactor = 0.5/roeAvgSoundSpeedSq
    coeffCff = normFactor*fastAlpha*roeAvgFastMagSonSpeed
    coeffCss = normFactor*slowAlpha*roeAvgSlowMagSonSpeed
    coeffQf *= normFactor
    coeffQs *= normFactor
    coeffAf = normFactor*coeffAfPrime*roeAvgDens
    coeffAs = normFactor*coeffAsPrime*roeAvgDens
    coeffAfB = normFactor*coeffAfPrime*BtranStar
    coeffAsB = normFactor*coeffAsPrime*BtranStar

    normFactor *= (gamma - 1.0)
    fastAlpha *= normFactor
    slowAlpha *= normFactor
    betaZCoeff = betaZStar/betaStarSq
    betaXCoeff = betaXStar/betaStarSq
    speedBetaStar = roeAvgVz*betaZCoeff + roeAvgVx*betaXCoeff
    normFactor *= 2.0

    #Add values to the left eigenmatrix
    leftEigenmatrix[0,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed + roeAvgVy) \
                                  - coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[0,1,:] = -1.0*fastAlpha*roeAvgVx + coeffQs*betaXCoeff
    leftEigenmatrix[0,2,:] = -1.0*fastAlpha*roeAvgVy - coeffCff
    leftEigenmatrix[0,3,:] = -1.0*fastAlpha*roeAvgVz + coeffQs*betaZCoeff
    leftEigenmatrix[0,6,:] = fastAlpha
    leftEigenmatrix[0,4,:] = coeffAs*betaZCoeff - fastAlpha*roeAvgBz
    leftEigenmatrix[0,5,:] = coeffAs*betaXCoeff - fastAlpha*roeAvgBx

    leftEigenmatrix[1,0,:] = 0.5*(roeAvgVz*betaX - roeAvgVx*betaZ)
    leftEigenmatrix[1,3,:] = -0.5*betaX
    leftEigenmatrix[1,1,:] = 0.5*betaZ
    leftEigenmatrix[1,4,:] = -0.5*sqrtRoeDens*betaX*bySign
    leftEigenmatrix[1,5,:] = 0.5*sqrtRoeDens*betaZ*bySign

    leftEigenmatrix[2,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed + roeAvgVy) \
                                  + coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[2,1,:] = -slowAlpha*roeAvgVx - coeffQf*betaXCoeff
    leftEigenmatrix[2,2,:] = -slowAlpha*roeAvgVy - coeffCss
    leftEigenmatrix[2,3,:] = -slowAlpha*roeAvgVz - coeffQf*betaZCoeff
    leftEigenmatrix[2,6,:] = slowAlpha
    leftEigenmatrix[2,4,:] = -coeffAf*betaZCoeff - slowAlpha*roeAvgBz
    leftEigenmatrix[2,5,:] = -coeffAf*betaXCoeff - slowAlpha*roeAvgBx

    leftEigenmatrix[3,0,:] = 1.0 - normFactor*(0.5*roeAvgVSq - (gamma - 2.0)*BtranCoeff/(gamma - 1.0))
    leftEigenmatrix[3,1,:] = normFactor*roeAvgVx
    leftEigenmatrix[3,2,:] = normFactor*roeAvgVy
    leftEigenmatrix[3,3,:] = normFactor*roeAvgVz
    leftEigenmatrix[3,6,:] = -1.0*normFactor
    leftEigenmatrix[3,4,:] = normFactor*roeAvgBz
    leftEigenmatrix[3,5,:] = normFactor*roeAvgBx

    leftEigenmatrix[4,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed - roeAvgVy) \
                                  - coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[4,1,:] = -slowAlpha*roeAvgVx + coeffQf*betaXCoeff
    leftEigenmatrix[4,2,:] = -slowAlpha*roeAvgVy + coeffCss
    leftEigenmatrix[4,3,:] = -slowAlpha*roeAvgVz + coeffQf*betaZCoeff
    leftEigenmatrix[4,6,:] = slowAlpha
    leftEigenmatrix[4,4,:] = leftEigenmatrix[2,4,:]
    leftEigenmatrix[4,5,:] = leftEigenmatrix[2,5,:]

    leftEigenmatrix[5,0,:] = -leftEigenmatrix[1,0,:]
    leftEigenmatrix[5,1,:] = -leftEigenmatrix[1,1,:]
    leftEigenmatrix[5,3,:] = -leftEigenmatrix[1,3,:]
    leftEigenmatrix[5,4,:] = leftEigenmatrix[1,4,:]
    leftEigenmatrix[5,5,:] = leftEigenmatrix[1,5,:]

    leftEigenmatrix[6,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed - roeAvgVy) \
                                  + coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[6,1,:] = -fastAlpha*roeAvgVx - coeffQs*betaXCoeff
    leftEigenmatrix[6,2,:] = -fastAlpha*roeAvgVy + coeffCff
    leftEigenmatrix[6,3,:] = -fastAlpha*roeAvgVz - coeffQs*betaZCoeff
    leftEigenmatrix[6,6,:] = fastAlpha
    leftEigenmatrix[6,4,:] = leftEigenmatrix[0,4,:]
    leftEigenmatrix[6,5,:] = leftEigenmatrix[0,5,:]

    #Calculate the flux variables for the cell above the intercell boundary.
    topCellFlux = np.zeros(shape=topConsVars.shape)
    topCellFlux[0] = topConsVars[2]
    topCellFlux[1] = topConsVars[2]*vx_i
    topCellFlux[2] = topConsVars[2]*vy_i
    topCellFlux[3] = topConsVars[2]*vz_i
    topCellFlux[2] += pres_i
    topCellFlux[6] = (topConsVars[6]+pres_i)*vy_i
    topCellFlux[2] -= 0.5*(faceBy*faceBy - np.square(Bz_i) - np.square(Bx_i))
    topCellFlux[1] -= faceBy*Bx_i
    topCellFlux[3] -= faceBy*Bz_i
    topCellFlux[6] += (halfTopBSq*vy_i - faceBy*(faceBy*vy_i + Bz_i*vz_i + Bx_i*vx_i))
    topCellFlux[4] = Bz_i*vy_i - faceBy*vz_i
    topCellFlux[5] = Bx_i*vy_i - faceBy*vx_i

    #Calculate the flux variables for the cell below the intercell boundary.
    bottomCellFlux = np.zeros(shape=bottomConsVars.shape)
    bottomCellFlux[0] = bottomConsVars[2]
    bottomCellFlux[1] = bottomConsVars[2]*vx_i1
    bottomCellFlux[2] = bottomConsVars[2]*vy_i1
    bottomCellFlux[3] = bottomConsVars[2]*vz_i1
    bottomCellFlux[2] += pres_i1
    bottomCellFlux[6] = (bottomConsVars[6]+pres_i1)*vy_i1
    bottomCellFlux[2] -= 0.5*(faceBy*faceBy - np.square(Bz_i1) - np.square(Bx_i1))
    bottomCellFlux[1] -= faceBy*Bx_i1
    bottomCellFlux[3] -= faceBy*Bz_i1
    bottomCellFlux[6] += (halfBottomBSq*vy_i1 - faceBy*(faceBy*vy_i1 + Bz_i1*vz_i1 + Bx_i1*vx_i1))
    bottomCellFlux[4] = Bz_i1*vy_i1 - faceBy*vz_i1
    bottomCellFlux[5] = Bx_i1*vy_i1 - faceBy*vx_i1

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = bottomConsVars - topConsVars
    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [7].)
    # consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    # for i in range(consVarsDiff.shape[0]):
    #     for j in range(consVarsDiff.shape[0]):
    #         consVarsDiffProj[i] += leftEigenmatrix[i,j,:]*consVarsDiff[j]
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        consVarsDiffProj[i] += leftEigenmatrix[i,0,:]*consVarsDiff[0]
        consVarsDiffProj[i] += leftEigenmatrix[i,2,:]*consVarsDiff[2]
        consVarsDiffProj[i] += leftEigenmatrix[i,3,:]*consVarsDiff[3]
        consVarsDiffProj[i] += leftEigenmatrix[i,1,:]*consVarsDiff[1]
        consVarsDiffProj[i] += leftEigenmatrix[i,6,:]*consVarsDiff[6]
        consVarsDiffProj[i] += leftEigenmatrix[i,4,:]*consVarsDiff[4]
        consVarsDiffProj[i] += leftEigenmatrix[i,5,:]*consVarsDiff[5]

    #Calculate the amplitudes associated with each of the waves.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]
    amps[5] = 0.5*np.abs(eigenVals[5,:])*consVarsDiffProj[5]
    amps[6] = 0.5*np.abs(eigenVals[6,:])*consVarsDiffProj[6]

    #Calculate the intercell flux as G_(j-1/2) = 0.5*(G_(j-1) + G_j) + G_roe
    intercellFlux = 0.5*(topCellFlux + bottomCellFlux) #First take the average of the top
                                                       #and bottom cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    for i in range(intercellFlux.shape[0]):
        for j in range(intercellFlux.shape[0]):
            intercellFlux[i] -= amps[j]*rightEigenmatrix[i,j,:] #multiplying by the right eigenmatrix gets us
                                                                #from characteristic variables back into
                                                                #conservative variables (technically the flux of
                                                                #conservative variables)

    #If the smallest eigenvalue (vy - cf) is greater than zero,
    #return the top cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the y-direction,
    # the flow is super/hypersonic if the y-velocity is greater than
    # the fast magnetosonic wave speed. We make the same correction if
    # vy is equal to the fast magnetosonic speed, in order to
    # prevent us from ever having a fast magnetosonic wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    intercellFlux[:,minEigenValIsPositiveOrZero] = topCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vy + cs) is less or equal to zero,
    #return the right cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative y-direction (i.e., regions in
    # the fluid where |vy| > cf and vy < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly
    # in the positive y-direction (i.e., downward), we use the top cell
    # flux. When the fluid is moving too quickly in the negative y-direction
    # (i.e., upward), we use the bottom cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[6,:] <= 0.0
    intercellFlux[:,maxEigenValIsNegativeOrZero] = bottomCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the y-direction
    return intercellFlux

######Z-DIRECTION RIEMANN SOLVER######
#Function: riemannSolverZ_mhd_roe
#Purpose: Calculates the intercell flux between adjacent cells in the z-direction.
#         This function implements Roe's Riemann solver algorithm for an MHD
#         simulation, using the eigenmatrices provided in [3].
#Input Parameters: backPrimVars (the back cell-centred primitive variable states)
#                               (i.e., the cells that are closer to you (than forwPrimVars)
#                                      if the z-axis goes into your screen)
#                  forwPrimVars (the forward cell-centred primitive variable states)
#                               (i.e., the cells that are farther from you (than backPrimVars)
#                                      if the z-axis goes into your screen)
#                  backConsVars (the back cell-centred conservative variable states)
#                  forwardConsVars (the forward cell-centred conservative variable states)
#                  faceBz (the z-component of the magnetic field at each
#                          intercell boundary)
#                  gamma (the specific heat ratio of the ideal gas)
#                  useEntropyFix (boolean for whether an entropy fix
#                                 should be applied to the wavespeeds/eigenvalues)
#                  epsilon (epsilon value for the entropy fix)
#Outputs: intercellFlux (the intercell fluxes for every cell boundary in the z-direction)
def riemannSolverZ_mhd_roe(backPrimVars, forwPrimVars, backConsVars, forwConsVars,
                           faceBz, gamma, useEntropyFix, epsilon):
    #Compute the roe-averaged variables for all of the intercell boundaries in the z-direction

    #Get the density behind each intercell boundary
    rho_i = backPrimVars[0,:]
    backDensSqrt = np.sqrt(rho_i)
    #Get the density in front of each intercell boundary
    rho_i1 = forwPrimVars[0,:]
    #Calculate the square root of each density
    backDensSqrt = np.sqrt(rho_i)
    forwDensSqrt = np.sqrt(rho_i1)
    #Calculate the denominator values for Roe-averaging
    #(i.e., 1/(sqrt(backDens) + sqrt(forwDens))
    #(saves time if we only calculate these values once)
    invSqrtDensSum = 1.0/(backDensSqrt+forwDensSqrt)
    #Calculate the Roe-averaged density
    roeAvgDens = backDensSqrt*forwDensSqrt

    #Get the x-velocity behind each intercell boundary
    vx_i = backPrimVars[1,:]
    #Get the x-velocity in front of each intercell boundary
    vx_i1 = forwPrimVars[1,:]
    #Compute the Roe-averaged x-velocity
    roeAvgVx = (backDensSqrt*vx_i + forwDensSqrt*vx_i1)*invSqrtDensSum

    #Get the y-velocity behind each intercell boundary
    vy_i = backPrimVars[2,:]
    #Get the y-velocity in front of each intercell boundary
    vy_i1 = forwPrimVars[2,:]
    #Compute the Roe-averaged y-velocity
    roeAvgVy = (backDensSqrt*vy_i + forwDensSqrt*vy_i1)*invSqrtDensSum

    #Get the z-velocity behind each intercell boundary
    vz_i = backPrimVars[3,:]
    #Get the z-velocity in front of each intercell boundary
    vz_i1 = forwPrimVars[3,:]
    #Compute the Roe-averaged z-velocity
    roeAvgVz = (backDensSqrt*vz_i + forwDensSqrt*vz_i1)*invSqrtDensSum

    #Compute the square of the Roe-averaged total velocity
    roeAvgVSq = roeAvgVz*roeAvgVz + roeAvgVx*roeAvgVx + roeAvgVy*roeAvgVy

    #Get the x-component of the magnetic field behind each intercell boundary
    Bx_i = backPrimVars[4,:]
    #Get the x-component of the magnetic field in front of each intercell boundary
    Bx_i1 = forwPrimVars[4,:]
    #Compute the Roe-averaged y-component of the magnetic field
    roeAvgBx = (forwDensSqrt*Bx_i + backDensSqrt*Bx_i1)*invSqrtDensSum

    #Get the y-component of the magnetic field behind each intercell boundary
    By_i = backPrimVars[5,:]
    #Get the y-component of the magnetic field in front of each intercell boundary
    By_i1 = forwPrimVars[5,:]
    #Compute the Roe-averaged y-component of the magnetic field
    roeAvgBy = (forwDensSqrt*By_i + backDensSqrt*By_i1)*invSqrtDensSum

    #Calculate the squared magnetic field intensity for each side of the boundary
    halfBackBSq = 0.5*(np.square(faceBz) + np.square(Bx_i) + np.square(By_i))
    halfForwBSq = 0.5*(np.square(faceBz) + np.square(Bx_i1) + np.square(By_i1))

    #Get the hydrodynamic pressure behind each intercell boundary
    pres_i = backPrimVars[6,:]
    #Get the hydrodynamic pressure in front of each intercell boundary
    pres_i1 = forwPrimVars[6,:]

    #Calculate the Roe-averaged enthalpy
    roeAvgH = ((backConsVars[6] + pres_i + halfBackBSq)/backDensSqrt
               + (forwConsVars[6] + pres_i1 + halfForwBSq)/forwDensSqrt)*invSqrtDensSum

    #Start calculating the Roe-averaged wavespeeds

    #For magnetohydrodynamics in the z-direction, there are seven waves that we need
    #to consider at each intercell boundary:
    #Fast magnetosonic wave with speed vz - cf, where cf is the fast magnetosonic sound speed
    #Alfven wave with speed vz - va, where va is the alfven wave speed
    #Slow magnetosonic wave with speed vz - cs, where cs is the slow magnetosonic sound speed
    #Contact discontinuity/entropy wave with speed vz
    #Slow magnetosonic wave with speed vz + cs, where cs is the slow magnetosonic sound speed
    #Alfven wave with speed vz + va, where va is the alfven wave speed
    #Fast magnetosonic wave with speed vz + cf, where cf is the fast magnetosonic sound speed

    #Compute some coefficients that will help us more easily calculate the required wave speeds.
    #Note: These are the same coefficients that are used in Athena's implementation of the Roe Riemann solver [3].

    invRoeDens = 1.0/roeAvgDens
    #Calculate a coefficient that is proportional to the difference between the transverse magnetic field strengths
    #behind and in front of the intercell boundary.
    BtranCoeff = 0.5*(np.square(Bx_i - Bx_i1) + np.square(By_i - By_i1))/(np.square(backDensSqrt + forwDensSqrt))
    #Calculate a coefficient that is proportional to the sum of the back and forward densities.
    rhoCoeff = 0.5*(rho_i + rho_i1)/roeAvgDens
    #Calculate the square of the Roe-averaged transverse magnetic field strengths.
    BtranSq = roeAvgBx*roeAvgBx + roeAvgBy*roeAvgBy
    Btran = np.sqrt(BtranSq)
    #Use the specific heat ratio, the density coefficient, and the transverse magnetic field strength
    #to calculate a value that will help us find the Roe-averaged fast magnetosonic speed.
    BtranSqStar = ((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)*BtranSq
    BtranStar = np.sqrt(BtranSqStar)
    reducedBtranSqStar = BtranSqStar*invRoeDens

    #Calculate the Roe-averaged Alfven speed
    roeAvgAlfvenSpeedSq = faceBz*faceBz*invRoeDens
    roeAvgAlfvenSpeed = np.sqrt(roeAvgAlfvenSpeedSq)

    #Use the Roe-averaged enthalpy, the Roe-averaged Alfven speed, the transverse magnetic field strength,
    #the Roe-averaged density, the Roe-averaged velocity, and the specific heat ratio to find the Roe-averaged
    #hydrodynamic sound speed.
    enthalpyMinB = roeAvgH - (roeAvgAlfvenSpeedSq + BtranSq*invRoeDens)
    roeAvgSoundSpeedSq = np.maximum((gamma - 1.0)*(enthalpyMinB - 0.5*roeAvgVSq)
                                          - (gamma - 2.0)*BtranCoeff, constants.SMALL_VALUE)
    roeAvgSoundSpeed = np.sqrt(roeAvgSoundSpeedSq)

    #Calculate the Roe-averaged fast magnetosonic speed
    speedSum = roeAvgAlfvenSpeedSq + reducedBtranSqStar + roeAvgSoundSpeedSq
    speedDiff = roeAvgAlfvenSpeedSq + reducedBtranSqStar - roeAvgSoundSpeedSq
    speedSqrt = np.sqrt(speedDiff*speedDiff + 4.0*roeAvgSoundSpeedSq*reducedBtranSqStar)
    roeAvgFastMagSonSpeedSq = 0.5*(speedSum + speedSqrt)
    roeAvgFastMagSonSpeed = np.sqrt(roeAvgFastMagSonSpeedSq)
    #Use the Roe-averaged hydrodynamic sound speed, Alfven speed, and fast magnetosonic speed to find the
    #Roe-averaged slow magnetosonic speed.
    roeAvgSlowMagSonSpeedSq = roeAvgSoundSpeedSq*roeAvgAlfvenSpeedSq/roeAvgFastMagSonSpeedSq
    roeAvgSlowMagSonSpeed = np.sqrt(roeAvgSlowMagSonSpeedSq)

    #Calculate eigenvalues
    eigenVals = np.zeros(shape=backPrimVars.shape)
    eigenVals[0,:] = roeAvgVz - roeAvgFastMagSonSpeed
    eigenVals[1,:] = roeAvgVz - roeAvgAlfvenSpeed
    eigenVals[2,:] = roeAvgVz - roeAvgSlowMagSonSpeed
    eigenVals[3,:] = roeAvgVz
    eigenVals[4,:] = roeAvgVz + roeAvgSlowMagSonSpeed
    eigenVals[5,:] = roeAvgVz + roeAvgAlfvenSpeed
    eigenVals[6,:] = roeAvgVz + roeAvgFastMagSonSpeed

    #Apply entropy fix, if requested by the user
    #PythonMHD currently only supports the entropy fix method from (Harten & Hyman, 1983) [6].
    #If the absolute value of an eigenvalue is greater than or equal to 2*epsilon, we leave
    #the eigenvalue unchanged. (|eigenvalue| >= 2*epsilon -> eigenvalue = eigenvalue)
    #If the absolute value of the eigenvalue is less than 2*epsilon, we increase the
    #absolute value of the eigenvalue by eigenvalue^2/(4*epsilon).
    #(|eigenvalue| < 2*epsilon  && eigenvalue < 0 -> eigenvalue = eigenvalue - eigenvalue^2/(4*epsilon)
    # |eigenvalue| < 2*epsilon  && eigenvalue > 0 -> eigenvalue = eigenvalue + eigenvalue^2/(4*epsilon))
    if useEntropyFix:
        eigenVals[0,:] = eigenVals[0,:] + np.sign(eigenVals[0,:])*(np.abs(eigenVals[0,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[0,:])/(4.0*epsilon))
        eigenVals[1,:] = eigenVals[1,:] + np.sign(eigenVals[1,:])*(np.abs(eigenVals[1,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[1,:])/(4.0*epsilon))
        eigenVals[2,:] = eigenVals[2,:] + np.sign(eigenVals[2,:])*(np.abs(eigenVals[2,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[2,:])/(4.0*epsilon))
        eigenVals[3,:] = eigenVals[3,:] + np.sign(eigenVals[3,:])*(np.abs(eigenVals[3,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[3,:])/(4.0*epsilon))
        eigenVals[4,:] = eigenVals[4,:] + np.sign(eigenVals[4,:])*(np.abs(eigenVals[4,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[4,:])/(4.0*epsilon))
        eigenVals[5,:] = eigenVals[5,:] + np.sign(eigenVals[5,:])*(np.abs(eigenVals[5,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[5,:])/(4.0*epsilon))
        eigenVals[6,:] = eigenVals[6,:] + np.sign(eigenVals[6,:])*(np.abs(eigenVals[6,:]) < 2.0*epsilon)*(epsilon + np.square(eigenVals[6,:])/(4.0*epsilon))

    #Create matrices for the left and right eigenmatrices
    rightEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                       backPrimVars.shape[0],
                                       backPrimVars.shape[1],
                                       backPrimVars.shape[2],
                                       backPrimVars.shape[3]))
    leftEigenmatrix = np.zeros(shape=(backPrimVars.shape[0],
                                      backPrimVars.shape[0],
                                      backPrimVars.shape[1],
                                      backPrimVars.shape[2],
                                      backPrimVars.shape[3]))

    #Calculate the fast and slow alpha coefficients
    fastAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    slowAlpha = np.zeros(shape=roeAvgFastMagSonSpeed.shape)
    fastAlphaOneIndices = roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0
    fastAlpha[fastAlphaOneIndices] = 1.0
    slowAlphaOneIndices = np.logical_and(np.logical_not(fastAlphaOneIndices),roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0)
    slowAlpha[slowAlphaOneIndices] = 1.0
    secondFastAlphaOneIndices = np.logical_and(np.logical_not(np.logical_or(fastAlphaOneIndices,slowAlphaOneIndices)),
                                               roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)
    fastAlpha[secondFastAlphaOneIndices] = 1.0
    #Find the indices where we can apply the conventional formula for fastAlpha and slowAlpha.
    calcAlphaIndices = np.logical_not(
        np.logical_or(roeAvgFastMagSonSpeedSq - roeAvgSlowMagSonSpeedSq == 0.0,
                      np.logical_or(roeAvgSoundSpeedSq - roeAvgSlowMagSonSpeedSq <= 0.0,
                                    roeAvgFastMagSonSpeedSq - roeAvgSoundSpeedSq <= 0.0)))
    #Calculate fastAlpha at these indices as sqrt((roeAvgSoundSpeed^2 - roeAvgSlowMagSonSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    fastAlpha[calcAlphaIndices] = np.sqrt((roeAvgSoundSpeedSq
                                           - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])
    #Calculate slowAlpha at these indices as sqrt((roeAvgFastMagSonSpeed^2 - roeAvgSoundSpeed^2)/
    #                                             (roeAvgFastMagSonSpeed^2 - roeAvgSlowMagSonSpeed^2))
    slowAlpha[calcAlphaIndices] = np.sqrt((roeAvgFastMagSonSpeedSq
                                           - roeAvgSoundSpeedSq)[calcAlphaIndices]
                                          /(roeAvgFastMagSonSpeedSq
                                            - roeAvgSlowMagSonSpeedSq)[calcAlphaIndices])

    #Get the sign of the z-component of the magnetic field
    bzSign = np.sign(faceBz)
    bzSign[bzSign == 0] = 1

    sqrtRoeDens = np.sqrt(roeAvgDens)
    invSqrtRoeDens = 1.0/sqrtRoeDens
    #Calculate Qf, the product of the fast magnetosonic speed, fastAlpha, and the sign of Bz
    coeffQf = roeAvgFastMagSonSpeed*fastAlpha*bzSign
    #Calculate Qs, the product of the slow magnetosonic speed, slowAlpha, and the sign of Bz
    coeffQs = roeAvgSlowMagSonSpeed*slowAlpha*bzSign
    #Calculate AfPrime as roeAvgSoundSpeed*fastAlpha/sqrt(roeAvgDens)
    coeffAfPrime = roeAvgSoundSpeed*fastAlpha*invSqrtRoeDens
    #Calculate AsPrime as roeAvgSoundSpeed*slowAlpha/sqrt(roeAvgDens)
    coeffAsPrime = roeAvgSoundSpeed*slowAlpha*invSqrtRoeDens

    #Calculate the betaX and betaY coefficients
    betaX = np.zeros(shape=BtranSq.shape)
    betaY = np.zeros(shape=BtranSq.shape)
    #Set betaX to 1.0 if the transverse magnetic field strength is zero
    betaX[Btran == 0.0] = 1.0
    #If the transverse magnetic field strength is greater than zero,
    #calculate betaX as roeAvgBx/Btran and betaY as roeAvgBy/Btran
    betaX[Btran > 0.0] = roeAvgBx[Btran > 0.0]/Btran[Btran > 0.0]
    betaY[Btran > 0.0] = roeAvgBy[Btran > 0.0]/Btran[Btran > 0.0]

    #Calculate additional coefficients that will simplify the eigenvector calculations.
    betaXStar = betaX/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    betaYStar = betaY/np.sqrt((gamma - 1.0) - (gamma - 2.0)*rhoCoeff)
    speedBeta = roeAvgVx*betaXStar + roeAvgVy*betaYStar
    betaStarSq = betaXStar*betaXStar + betaYStar*betaYStar
    coeffAfB = coeffAfPrime*BtranStar*betaStarSq
    coeffAsB = coeffAsPrime*BtranStar*betaStarSq

    #Assemble the left and right eigenvectors for Roe's method,
    #using the formulas in Athena's Roe solver [3].
    #Note: These eigenmatrices do not exactly match the eigenmatrices
    #in the Athena methods paper [4] because PythonMHD orders MHD
    #variables differently than Athena.
    #(Athena: density, momenta, energy, magnetic field components
    # PythonMHD: density, momenta, magnetic field components, energy)

    #Assemble the left and right eigenvectors for Roe's method,
    #using the formulas in Athena's Roe solver.

    #Add values to the right eigenmatrix
    rightEigenmatrix[0,0,:] = fastAlpha
    rightEigenmatrix[0,2,:] = slowAlpha
    rightEigenmatrix[0,3,:] = 1.0
    rightEigenmatrix[0,4,:] = slowAlpha
    rightEigenmatrix[0,6,:] = fastAlpha

    rightEigenmatrix[3,0,:] = fastAlpha*eigenVals[0]
    rightEigenmatrix[3,2,:] = slowAlpha*eigenVals[2]
    rightEigenmatrix[3,3,:] = roeAvgVz
    rightEigenmatrix[3,4,:] = slowAlpha*eigenVals[4]
    rightEigenmatrix[3,6,:] = fastAlpha*eigenVals[6]

    fastAlphaVx = fastAlpha*roeAvgVx
    slowAlphaVx = slowAlpha*roeAvgVx
    coeffQsBetaXStar = coeffQs*betaXStar
    coeffQfBetaXStar = coeffQf*betaXStar
    rightEigenmatrix[1,0,:] = fastAlphaVx + coeffQsBetaXStar
    rightEigenmatrix[1,1,:] = -betaY
    rightEigenmatrix[1,2,:] = slowAlphaVx - coeffQfBetaXStar
    rightEigenmatrix[1,3,:] = roeAvgVx
    rightEigenmatrix[1,4,:] = slowAlphaVx + coeffQfBetaXStar
    rightEigenmatrix[1,5,:] = betaY
    rightEigenmatrix[1,6,:] = fastAlphaVx - coeffQsBetaXStar

    fastAlphaVy = fastAlpha*roeAvgVy
    slowAlphaVy = slowAlpha*roeAvgVy
    coeffQsBetaYStar = coeffQs*betaYStar
    coeffQfBetaYStar = coeffQf*betaYStar
    rightEigenmatrix[2,0,:] = fastAlphaVy + coeffQsBetaYStar
    rightEigenmatrix[2,1,:] = betaX
    rightEigenmatrix[2,2,:] = slowAlphaVy - coeffQfBetaYStar
    rightEigenmatrix[2,3,:] = roeAvgVy
    rightEigenmatrix[2,4,:] = slowAlphaVy + coeffQfBetaYStar
    rightEigenmatrix[2,5,:] = -betaX
    rightEigenmatrix[2,6,:] = fastAlphaVy - coeffQsBetaYStar

    rightEigenmatrix[6,0,:] = fastAlpha*(enthalpyMinB - roeAvgVz*roeAvgFastMagSonSpeed) + coeffQs*speedBeta + coeffAsB
    rightEigenmatrix[6,1,:] = -(roeAvgVx*betaY - roeAvgVy*betaX)
    rightEigenmatrix[6,2,:] = slowAlpha*(enthalpyMinB - roeAvgVz*roeAvgSlowMagSonSpeed) - coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,3,:] = 0.5*roeAvgVSq + (gamma - 2.0)*BtranCoeff/(gamma - 1.0)
    rightEigenmatrix[6,4,:] = slowAlpha*(enthalpyMinB + roeAvgVz*roeAvgSlowMagSonSpeed) + coeffQf*speedBeta - coeffAfB
    rightEigenmatrix[6,5,:] = -rightEigenmatrix[6,1,:,:]
    rightEigenmatrix[6,6,:] = fastAlpha*(enthalpyMinB + roeAvgVz*roeAvgFastMagSonSpeed) - coeffQs*speedBeta + coeffAsB

    rightEigenmatrix[4,0,:] = coeffAsPrime*betaXStar
    rightEigenmatrix[4,1,:] = -betaY*bzSign*invSqrtRoeDens
    rightEigenmatrix[4,2,:] = -coeffAfPrime*betaXStar
    rightEigenmatrix[4,4,:] = rightEigenmatrix[4,2,:,:]
    rightEigenmatrix[4,5,:] = rightEigenmatrix[4,1,:,:]
    rightEigenmatrix[4,6,:] = rightEigenmatrix[4,0,:,:]

    rightEigenmatrix[5,0,:] = coeffAsPrime*betaYStar
    rightEigenmatrix[5,1,:] = betaX*bzSign*invSqrtRoeDens
    rightEigenmatrix[5,2,:] = -coeffAfPrime*betaYStar
    rightEigenmatrix[5,4,:] = rightEigenmatrix[5,2,:,:]
    rightEigenmatrix[5,5,:] = rightEigenmatrix[5,1,:,:]
    rightEigenmatrix[5,6,:] = rightEigenmatrix[5,0,:,:]

    #Calculate coefficients that will simplify
    #the left eigenvector calculations
    normFactor = 0.5/roeAvgSoundSpeedSq
    coeffCff = normFactor*fastAlpha*roeAvgFastMagSonSpeed
    coeffCss = normFactor*slowAlpha*roeAvgSlowMagSonSpeed
    coeffQf *= normFactor
    coeffQs *= normFactor
    coeffAf = normFactor*coeffAfPrime*roeAvgDens
    coeffAs = normFactor*coeffAsPrime*roeAvgDens
    coeffAfB = normFactor*coeffAfPrime*BtranStar
    coeffAsB = normFactor*coeffAsPrime*BtranStar

    normFactor *= (gamma - 1.0)
    fastAlpha *= normFactor
    slowAlpha *= normFactor
    betaXCoeff = betaXStar/betaStarSq
    betaYCoeff = betaYStar/betaStarSq
    speedBetaStar = roeAvgVx*betaXCoeff + roeAvgVy*betaYCoeff
    normFactor *= 2.0

    #Add values to the left eigenmatrix
    leftEigenmatrix[0,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed + roeAvgVz) \
                                  - coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[0,3,:] = -fastAlpha*roeAvgVz - coeffCff
    leftEigenmatrix[0,1,:] = -fastAlpha*roeAvgVx + coeffQs*betaXCoeff
    leftEigenmatrix[0,2,:] = -fastAlpha*roeAvgVy + coeffQs*betaYCoeff
    leftEigenmatrix[0,6,:] = fastAlpha
    leftEigenmatrix[0,4,:] = coeffAs*betaXCoeff - fastAlpha*roeAvgBx
    leftEigenmatrix[0,5,:] = coeffAs*betaYCoeff - fastAlpha*roeAvgBy

    leftEigenmatrix[1,0,:] = 0.5*(roeAvgVx*betaY - roeAvgVy*betaX)
    leftEigenmatrix[1,1,:] = -0.5*betaY
    leftEigenmatrix[1,2,:] = 0.5*betaX
    leftEigenmatrix[1,4,:] = -0.5*sqrtRoeDens*betaY*bzSign
    leftEigenmatrix[1,5,:] = 0.5*sqrtRoeDens*betaX*bzSign

    leftEigenmatrix[2,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed + roeAvgVz) \
                                  + coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[2,3,:] = -slowAlpha*roeAvgVz - coeffCss
    leftEigenmatrix[2,1,:] = -slowAlpha*roeAvgVx - coeffQf*betaXCoeff
    leftEigenmatrix[2,2,:] = -slowAlpha*roeAvgVy - coeffQf*betaYCoeff
    leftEigenmatrix[2,6,:] = slowAlpha
    leftEigenmatrix[2,4,:] = -coeffAf*betaXCoeff - slowAlpha*roeAvgBx
    leftEigenmatrix[2,5,:] = -coeffAf*betaYCoeff - slowAlpha*roeAvgBy

    leftEigenmatrix[3,0,:] = 1.0 - normFactor*(0.5*roeAvgVSq - (gamma - 2.0)*BtranCoeff/(gamma - 1.0))
    leftEigenmatrix[3,3,:] = normFactor*roeAvgVz
    leftEigenmatrix[3,1,:] = normFactor*roeAvgVx
    leftEigenmatrix[3,2,:] = normFactor*roeAvgVy
    leftEigenmatrix[3,6,:] = -normFactor
    leftEigenmatrix[3,4,:] = normFactor*roeAvgBx
    leftEigenmatrix[3,5,:] = normFactor*roeAvgBy

    leftEigenmatrix[4,0,:] = slowAlpha*(roeAvgVSq - enthalpyMinB) + coeffCss*(roeAvgSlowMagSonSpeed - roeAvgVz) \
                                  - coeffQf*speedBetaStar + coeffAfB
    leftEigenmatrix[4,3,:] = -slowAlpha*roeAvgVz + coeffCss
    leftEigenmatrix[4,1,:] = -slowAlpha*roeAvgVx + coeffQf*betaXCoeff
    leftEigenmatrix[4,2,:] = -slowAlpha*roeAvgVy + coeffQf*betaYCoeff
    leftEigenmatrix[4,6,:] = slowAlpha
    leftEigenmatrix[4,4,:] = leftEigenmatrix[2,4,:,:]
    leftEigenmatrix[4,5,:] = leftEigenmatrix[2,5,:,:]

    leftEigenmatrix[5,0,:] = -leftEigenmatrix[1,0,:,:]
    leftEigenmatrix[5,1,:] = -leftEigenmatrix[1,1,:,:]
    leftEigenmatrix[5,2,:] = -leftEigenmatrix[1,2,:,:]
    leftEigenmatrix[5,4,:] = leftEigenmatrix[1,4,:,:]
    leftEigenmatrix[5,5,:] = leftEigenmatrix[1,5,:,:]

    leftEigenmatrix[6,0,:] = fastAlpha*(roeAvgVSq - enthalpyMinB) + coeffCff*(roeAvgFastMagSonSpeed - roeAvgVz) \
                                  + coeffQs*speedBetaStar - coeffAsB
    leftEigenmatrix[6,3,:] = -fastAlpha*roeAvgVz + coeffCff
    leftEigenmatrix[6,1,:] = -fastAlpha*roeAvgVx - coeffQs*betaXCoeff
    leftEigenmatrix[6,2,:] = -fastAlpha*roeAvgVy - coeffQs*betaYCoeff
    leftEigenmatrix[6,6,:] = fastAlpha
    leftEigenmatrix[6,4,:] = leftEigenmatrix[0,4,:,:]
    leftEigenmatrix[6,5,:] = leftEigenmatrix[0,5,:,:]

    #Calculate the flux variables for the cell behind the intercell boundary.
    backCellFlux = np.zeros(shape=backConsVars.shape)
    backCellFlux[0] = backConsVars[3]
    backCellFlux[1] = backConsVars[3]*vx_i
    backCellFlux[2] = backConsVars[3]*vy_i
    backCellFlux[3] = backConsVars[3]*vz_i
    backCellFlux[3] += pres_i
    backCellFlux[6] = (backConsVars[6]+pres_i)*vz_i
    backCellFlux[3] -= 0.5*(faceBz*faceBz - np.square(Bx_i) - np.square(By_i))
    backCellFlux[1] -= faceBz*Bx_i
    backCellFlux[2] -= faceBz*By_i
    backCellFlux[6] += (halfBackBSq*vz_i - faceBz*(faceBz * vz_i + Bx_i * vx_i + By_i * vy_i))
    backCellFlux[4] = Bx_i*vz_i - faceBz*vx_i
    backCellFlux[5] = By_i*vz_i - faceBz*vy_i

    #Calculate the flux variables for the cell in front of the intercell boundary.
    forwCellFlux = np.zeros(shape=forwConsVars.shape)
    forwCellFlux[0] = forwConsVars[3]
    forwCellFlux[1] = forwConsVars[3]*vx_i1
    forwCellFlux[2] = forwConsVars[3]*vy_i1
    forwCellFlux[3] = forwConsVars[3]*vz_i1
    forwCellFlux[3] += pres_i1
    forwCellFlux[6] = (forwConsVars[6]+pres_i1)*vz_i1
    forwCellFlux[3] -= 0.5*(faceBz*faceBz - np.square(Bx_i1) - np.square(By_i1))
    forwCellFlux[1] -= faceBz*Bx_i1
    forwCellFlux[2] -= faceBz*By_i1
    forwCellFlux[6] += (halfForwBSq*vz_i1 - faceBz*(faceBz * vz_i1 + Bx_i1 * vx_i1 + By_i1 * vy_i1))
    forwCellFlux[4] = Bx_i1*vz_i1 - faceBz*vx_i1
    forwCellFlux[5] = By_i1*vz_i1 - faceBz*vy_i1

    #Find the difference between the conservative variables
    #across the intercell boundary
    consVarsDiff = forwConsVars - backConsVars

    #Now we can multiply the conservative variable differences
    #by the left eigenmatrix to get the characteristic variables
    #(Note: An excellent description of what "characteristic variables"
    #       mean in the context of MHD and hydrodynamics is provided
    #       in the introduction of [7].)
    consVarsDiffProj = np.zeros(shape=consVarsDiff.shape)
    for i in range(consVarsDiff.shape[0]):
        consVarsDiffProj[i] += leftEigenmatrix[i,0,:]*consVarsDiff[0]
        consVarsDiffProj[i] += leftEigenmatrix[i,3,:]*consVarsDiff[3]
        consVarsDiffProj[i] += leftEigenmatrix[i,1,:]*consVarsDiff[1]
        consVarsDiffProj[i] += leftEigenmatrix[i,2,:]*consVarsDiff[2]
        consVarsDiffProj[i] += leftEigenmatrix[i,6,:]*consVarsDiff[6]
        consVarsDiffProj[i] += leftEigenmatrix[i,4,:]*consVarsDiff[4]
        consVarsDiffProj[i] += leftEigenmatrix[i,5,:]*consVarsDiff[5]

    #Calculate the amplitudes associated with each of the seven wavespeeds.
    amps = np.zeros(shape=consVarsDiff.shape)
    amps[0] = 0.5*np.abs(eigenVals[0,:])*consVarsDiffProj[0]
    amps[1] = 0.5*np.abs(eigenVals[1,:])*consVarsDiffProj[1]
    amps[2] = 0.5*np.abs(eigenVals[2,:])*consVarsDiffProj[2]
    amps[3] = 0.5*np.abs(eigenVals[3,:])*consVarsDiffProj[3]
    amps[4] = 0.5*np.abs(eigenVals[4,:])*consVarsDiffProj[4]
    amps[5] = 0.5*np.abs(eigenVals[5,:])*consVarsDiffProj[5]
    amps[6] = 0.5*np.abs(eigenVals[6,:])*consVarsDiffProj[6]

    #Calculate the intercell flux as H_(k-1/2) = 0.5*(H_(k-1) + H_k) + H_roe
    intercellFlux = 0.5*(backCellFlux + forwCellFlux) #First take the average of the back
                                                        #and forward cell-centred fluxes
    #Now we add the flux contributions from our Roe-approximated waves
    for i in range(intercellFlux.shape[0]):
        for j in range(intercellFlux.shape[0]):
            intercellFlux[i] -= amps[j]*rightEigenmatrix[i,j,:] #multiplying by the right eigenmatrix gets us
                                                                #from characteristic variables back into
                                                                #conservative variables (technically the flux of
                                                                #conservative variables)

    #If the smallest eigenvalue (vz - cf) is greater than zero,
    #return the back cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to minimize
    # error for supersonic flows. At a cell boundary in the z-direction,
    # the flow is super/hypersonic if the z-velocity is greater than
    # the fast magnetosonic wave speed. We make the same correction if
    # vz is equal to the fast magnetosonic speed, in order to
    # prevent us from ever having a fast magnetosonic wave with a
    # velocity of zero.)
    minEigenValIsPositiveOrZero = eigenVals[0] >= 0.0
    intercellFlux[:,minEigenValIsPositiveOrZero] = backCellFlux[:,minEigenValIsPositiveOrZero]

    #If the largest eigenvalue (vz + cs) is less or equal to zero,
    #return the forward cell flux instead of Roe's intercell flux values.
    #(This step is performed in Athena's Roe algorithm to address
    # supersonic flows in the negative z-direction (i.e., regions in
    # the fluid where |vz| > cf and vz < 0). For both of the supersonic
    # flow corrections, we take the cell-centred flux that is upwind
    # of the fluid motion. When the fluid is moving too quickly
    # in the positive z-direction (i.e., into the screen), we use the back cell
    # flux. When the fluid is moving too quickly in the negative y-direction
    # (i.e., out of the screen, towards you), we use the forward cell flux.)
    maxEigenValIsNegativeOrZero = eigenVals[6,:] <= 0.0
    intercellFlux[:,maxEigenValIsNegativeOrZero] = forwCellFlux[:,maxEigenValIsNegativeOrZero]

    #Return the intercell flux for every intercell boundary in the z-direction
    return intercellFlux