#Reconstruction_PPM_Hydro_HelperModule.py
#By Delica Leboe-McGowan, PhD Student, University of Manitoba
#Last Updated: January 1, 2024
#Purpose: Provides functions for second-order primitive variable reconstruction
#         in hydrodynamic simulations. The three functions in this module,
#         respectively, perform the piecewise parabolic method (PPM) [1] in the
#         x-, y-, and z-directions for Cartesian simulation grids.
#
#Additional Information:    The reconstruction functions in this script allow us to improve the effective spatial
#                       resolution of our hydrodynamic simulations. When we don't use a primitive variable
#                       reconstruction algorithm, we calculate the flux between two cells by passing the adjacent
#                       cell-centred gas states to our chosen Riemann solver. For example, in the x-direction, we give
#                       the Riemann solver the state of the gas at the centre of the cell just to the left of an
#                       intercell boundary (i.e., the boundary between two different cells) and the state of the gas
#                       at the centre of the cell just to the right of the same boundary. This approach assumes that
#                       the state of the gas is constant throughout a single cell. In a real gas system that is
#                       evolving over time, it is extremely (extremely!) unlikely that we would ever find a perfect
#                       cube of gas with no internal variations in density, pressure, or velocity. When we don't use
#                       primitive variable reconstruction, we calculate intercell flux values from a pixelated version
#                       of the gas. A preferable approach is to somehow reflect the primitive variable fluctuations
#                       within a single cell when we send gas states to the Riemann solver. Spatial reconstruction
#                       algorithms for CFD (Computational Fluid Dynamics) use the cell-centred gas states to interpolate
#                       the gas states at the boundaries between cells.
#                                              F_1/2                    F_3/2                     F_5/2
#                       |                       |                         |                         |
#                       |                       |                         |                         |
#                       |         W_0    W_1/2,L|W_1/2,R    W_1    W_3/2,L|W_3/2,R    W_2    W_5/2,L|
#                       |                       |                         |                         |
#                       |                       |                         |                         |
#                               Cell 0                     Cell 1                      Cell 2
#                       W = primitive variable vector, F = intercell flux vector
#
#                       The Piecewise Parabolic Method (PPM) is a second-order spatial reconstruction scheme because
#                       it uses parabolas to interpolate the gas states at cell boundaries. In PythonMHD, you have the
#                       option of instead using the Piecewise Linear Method (PLM) for spatial reconstruction, which is
#                       a first-order scheme that uses lines to interpolate the boundary states. To set the type
#                       of reconstruction algorithm that you would like to use (none, first-order, or second-order),
#                       use the "reconstructOrder" parameter in simPar (see PythonMHD user guide for information
#                       on how to properly set up simPar in your initialization file).
#
#                       The second-order/PPM reconstruction functions in this script are designed to generate
#                       interpolated gas states that are numerically identical (within a margin of ~10^()) to those
#                       generated by the PPM algorithm in the 2017 version of Athena [2] by James Stone and colleagues.
#                       In order to achieve this consistency, PythonMHD uses the reconstruction eigenmatrices
#                       (i.e., the matrices that allow us to convert between primitive and characteristic variables
#                       (see [4] for a good explanation of characteristic variables in the context of hydrodynamics))
#                       that are presented in the original Athena methods paper [3].
#
#References
# 1. Colella, P., & Woodward, P. R. (1984). The Piecewise Parabolic Method (PPM) for gas-dynamical simulations.
#    Journal of Computational Physics, 54(1), 174-201. https://doi.org/10.1016/0021-9991(84)90143-8.
# 2. https://github.com/PrincetonUniversity/Athena-Cversion
# 3. Stone, J. M., Gardiner, T. A., Teuben, P., Hawley, J. F., & Simon, J. B. (2008).
#    Athena: A new code for astrophysical MHD. The Astrophysical Journal Supplemental Series,
#    178(1), 137-177. https://iopscience.iop.org/article/10.1086/588755/pdf.
# 4. Banyuls, F., Font, A. J., Ibanez, J. M., Marti, J.M, & Miralles, J. A. (1997). Numerical {3 + 1} General
#    Relativistic Hydrodynamics: A Local Characteristic Approach. The Astrophysical Journal, 476, 221-231.
#    https://iopscience.iop.org/article/10.1086/303604/fulltext/34434.text.html
#

#####IMPORT STATEMENTS#####

#Import PythonMHD constants
import Source.PythonMHD_Constants as constants

#Import helper module for calculating the hydrodynamic reconstruction eigenmatrices
import Source.ReconstructionEigenmatrices_Hydro_HelperModule as eig

#Import NumPy for matrix operations
import numpy as np

#####X-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructX_hydro
#Purpose: Calculates the reconstructed/interpolated left and right states for every intercell
#         boundary in the x-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVars (the primitive variables for every cell in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dx (the cell width/size of the cell in the x-direction)
#                  BcX (integer for the boundary condition in the x-direction
#                      (0 = outflow and 1 = periodic))
#Outputs: leftPrimVarState (the interpolated primitive variable states just to the left
#                           of each intercell boundary)
#         rightPrimVarState (the interpolated primitive variable states just to the right
#                           of each intercell boundary)
def ppmReconstructX_hydro(primVars,gamma,dt,dx,BcX):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that there are only 1, 2, or 3 spatial dimensions
    assert numDim == 1 or numDim == 2 or numDim == 3, "Reconstruction algorithm (x-direction) encountered primitive" \
                                                      " variable matrix with invalid dimensions"
    #We need to expand the primitive variable matrix so that it has two extra columns
    #in the x-direction on either side. These extra cells will simplify subsequent
    #steps in the algorithm. (Note: The number of extra cells we need on either side
    #is equal to the order of the reconstruction algorithm (i.e., 2 for second-order/PPM).)
    if numDim == 1: #if the sim is 1D
        #Create an empty matrix for the expanded primitive variable grid
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4))
        #Add the primitive variables we already have to the middle of the new grid
        expandedPrimVars[:,2:expandedPrimVars.shape[1]-2] = primVars[:,:]
        #Now we will figure out how we should fill the four additional columns
        #Check whether the boundary condition (BC) in the x-direction is outflow or periodic
        if BcX == 0: #if the BC is outflow
            #If the BC is outflow, copy the leftmost primitive variables into
            #both of the additional columns on the left.
            expandedPrimVars[:,0] = primVars[:,0]
            expandedPrimVars[:,1] = primVars[:,0]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,expandedPrimVars.shape[1]-1] = primVars[:,primVars.shape[1]-1]
            expandedPrimVars[:,expandedPrimVars.shape[1]-2] = primVars[:,primVars.shape[1]-1]
        else: #if the BC is periodic
            #If the BC is periodic, copy the rightmost primitive variables into
            #the additional columns on the left.
            expandedPrimVars[:,0] = primVars[:,primVars.shape[1]-2]
            expandedPrimVars[:,1] = primVars[:,primVars.shape[1]-1]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,expandedPrimVars.shape[1]-1] = primVars[:,1]
            expandedPrimVars[:,expandedPrimVars.shape[1]-2] = primVars[:,0]
    else:  #if the sim is 2D or 3D
        #Create an empty matrix for the expanded primitive variable grid
        if numDim == 2:
            expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2]+4))
        else:
            expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2]+4,primVars.shape[3]))
        #Add the primitive variables we already have to the middle of the new grid
        expandedPrimVars[:,:,2:expandedPrimVars.shape[2]-2] = primVars[:]
        #Now we will figure out how we should fill the four additional columns
        #Check whether the boundary condition (BC) in the x-direction is outflow or periodic
        if BcX == 0: #if the BC is outflow
            #If the BC is outflow, copy the leftmost primitive variables into
            #both of the additional columns on the left.
            expandedPrimVars[:,:,0] = primVars[:,:,0]
            expandedPrimVars[:,:,1] = primVars[:,:,0]
            #Copy the rightmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-1] = primVars[:,:,primVars.shape[2]-1]
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-2] = primVars[:,:,primVars.shape[2]-1]
        else: #if the BC is periodic
            #If the BC is periodic, copy the rightmost primitive variables into
            #the additional columns on the left.
            expandedPrimVars[:,:,0] = primVars[:,:,primVars.shape[2]-2]
            expandedPrimVars[:,:,1] = primVars[:,:,primVars.shape[2]-1]
            #Copy the leftmost primitive variables into the additional
            #columns on the right.
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-1] = primVars[:,:,1]
            expandedPrimVars[:,:,expandedPrimVars.shape[2]-2] = primVars[:,:,0]

    #Using our expanded primitive variable matrix, we will create matrices
    #for left, right, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required for PPM
    #reconstruction.
    if numDim == 1:
        centPrimVars = expandedPrimVars[:,1:expandedPrimVars.shape[1]-1]
        leftPrimVars = expandedPrimVars[:,0:expandedPrimVars.shape[1]-2]
        rightPrimVars = expandedPrimVars[:,2:expandedPrimVars.shape[1]]
    else:
        centPrimVars = expandedPrimVars[:,:,1:expandedPrimVars.shape[2]-1]
        leftPrimVars = expandedPrimVars[:,:,0:expandedPrimVars.shape[2]-2]
        rightPrimVars = expandedPrimVars[:,:,2:expandedPrimVars.shape[2]]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesX_hydro(centPrimVars, gamma)

    #Calculate the primitive variable difference between the right and left cells
    centPrimVarDiff = rightPrimVars - leftPrimVars
    #Calculate the primitive variable difference between the centre and left cells
    leftPrimVarDiff = centPrimVars - leftPrimVars
    #Calculate the primitive variable difference between the right and centre cells
    rightPrimVarDiff = rightPrimVars - centPrimVars

    #Compute weight values for positions where the left and right differences
    #have the same sign (i.e., leftPrimVarDiff and rightPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = leftPrimVarDiff*rightPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*leftPrimVarDiff*rightPrimVarDiff)[weightIndices] \
                            /(leftPrimVarDiff + rightPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    leftCharVarDiff = np.zeros(shape=leftPrimVarDiff.shape)
    rightCharVarDiff = np.zeros(shape=rightPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            centCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*centPrimVarDiff[j,:]
            leftCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*leftPrimVarDiff[j,:]
            rightCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*rightPrimVarDiff[j,:]
            weightChar[i,:] += + leftEigenmatrix[i,j,:]*weight[j,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = leftCharVarDiff*rightCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(leftCharVarDiff), np.abs(rightCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
        slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] += charMonSlopes[j,:] * rightEigenmatrix[i,j,:]
    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector to its left, and the slope vector to its right.
    if numDim == 1:
        centPrimMonSlopes = primMonSlopes[:,1:primMonSlopes.shape[1]-1]
        leftPrimMonSlopes = primMonSlopes[:,0:primMonSlopes.shape[1]-2]
        rightPrimMonSlopes = primMonSlopes[:,2:primMonSlopes.shape[1]]
    else:
        centPrimMonSlopes = primMonSlopes[:,:,1:primMonSlopes.shape[2]-1]
        leftPrimMonSlopes = primMonSlopes[:,:,0:primMonSlopes.shape[2]-2]
        rightPrimMonSlopes = primMonSlopes[:,:,2:primMonSlopes.shape[2]]

    #Remove the outermost columns from centPrimVars, leftPrimVars, and rightPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    if numDim == 1:
        centPrimVars = centPrimVars[:,1:centPrimVars.shape[1]-1]
        leftPrimVars = leftPrimVars[:,1:leftPrimVars.shape[1]-1]
        rightPrimVars = rightPrimVars[:,1:rightPrimVars.shape[1]-1]
    else:
        centPrimVars = centPrimVars[:,:,1:centPrimVars.shape[2]-1]
        leftPrimVars = leftPrimVars[:,:,1:leftPrimVars.shape[2]-1]
        rightPrimVars = rightPrimVars[:,:,1:rightPrimVars.shape[2]-1]

    #Calculate an interpolated state on the left edge of every cell
    leftInterfaceAvg = 0.5*(centPrimVars + leftPrimVars) \
                       - (centPrimMonSlopes - leftPrimMonSlopes)/6.0
    #Calculate an interpolated state on the right edge of every cell
    rightInterfaceAvg = 0.5*(rightPrimVars + centPrimVars) \
                        - (rightPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena [2]
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the left and right halves of the cell
    diffProd = (rightInterfaceAvg - centPrimVars)*(centPrimVars - leftInterfaceAvg)
    #Calculate the difference between the left and right interface states
    interfaceDiff = rightInterfaceAvg - leftInterfaceAvg
    interfaceDiffSq = np.square(interfaceDiff)
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the left and right interpolated states.
    avgDiff = 6.0 * (centPrimVars - 0.5*(leftInterfaceAvg + rightInterfaceAvg))
    #Apply monotonicity constraints
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    leftInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    rightInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctLeftIndices = np.logical_and(diffProdPos,(interfaceDiff*avgDiff) > interfaceDiffSq)
    leftInterfaceAvg[correctLeftIndices] \
        = ((6.0*centPrimVars - 4.0*rightInterfaceAvg)/2.0)[correctLeftIndices]
    correctRightIndices = np.logical_and(diffProdPos,np.logical_and(np.logical_not(correctLeftIndices),(interfaceDiff*avgDiff) < (-1.0*interfaceDiffSq)))
    rightInterfaceAvg[correctRightIndices] \
        = ((6.0*centPrimVars - 4.0*leftInterfaceAvg)/2.0)[correctRightIndices]
    #Apply additional monotonicity constraints
    leftInterfaceAvg = np.maximum(np.minimum(centPrimVars, leftPrimVars), leftInterfaceAvg)
    leftInterfaceAvg = np.minimum(np.maximum(centPrimVars, leftPrimVars), leftInterfaceAvg)
    rightInterfaceAvg = np.maximum(np.minimum(centPrimVars, rightPrimVars), rightInterfaceAvg)
    rightInterfaceAvg = np.minimum(np.maximum(centPrimVars, rightPrimVars), rightInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    if numDim == 1:
        leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1]
        rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1]
        eigenVals = eigenVals[:,1:eigenVals.shape[1]-1]
    elif numDim == 2:
        leftEigenmatrix = leftEigenmatrix[:,:,:,1:leftEigenmatrix.shape[3]-1]
        rightEigenmatrix = rightEigenmatrix[:,:,:,1:rightEigenmatrix.shape[3]-1]
        eigenVals = eigenVals[:,:,1:eigenVals.shape[2]-1]
    else:
        leftEigenmatrix = leftEigenmatrix[:,:,:,1:leftEigenmatrix.shape[3]-1,:]
        rightEigenmatrix = rightEigenmatrix[:,:,:,1:rightEigenmatrix.shape[3]-1,:]
        eigenVals = eigenVals[:,:,1:eigenVals.shape[2]-1,:]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdx = dt/dx
    coeff1 = rightInterfaceAvg - leftInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(leftInterfaceAvg + rightInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[4],0.0)*dtdx
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdx

    #Evolve the left interpolated state by half a timestep
    leftInterfaceAvg = leftInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the right interpolated state by half a timestep
    rightInterfaceAvg = rightInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)


    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas, we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid/overshoot wave contributions from the left interpolated state.
    for i in range(eigenVals.shape[0]):
        leftOvershootIndices = eigenVals[i] <= 0.0
        leftOvershootFactor = np.zeros(shape=leftOvershootIndices.shape)
        leftOvershootVal1 = 0.5*dtdx*eigenVals[0]
        leftOvershootVal2 = 0.5*dtdx*eigenVals[i]
        leftOvershootVal3 = leftOvershootVal1 - leftOvershootVal2
        leftOvershootVal4 = constants.FOUR_THIRDS*(np.square(leftOvershootVal1) - np.square(leftOvershootVal2))
        for j in range(eigenVals.shape[0]):
            leftOvershootFactor += leftOvershootIndices*leftEigenmatrix[i,j,:] \
                                    *(leftOvershootVal3*(coeff1[j] + coeff2[j])
                                       + leftOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            leftInterfaceAvg[j] += leftOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the right interpolated state.
    for i in range(eigenVals.shape[0]):
        rightOvershootIndices = eigenVals[i] >= 0.0
        rightOvershootFactor = np.zeros(shape=rightOvershootIndices.shape)
        rightOvershootVal1 = 0.5*dtdx*eigenVals[4]
        rightOvershootVal2 = 0.5*dtdx*eigenVals[i]
        rightOvershootVal3 = rightOvershootVal1 - rightOvershootVal2
        rightOvershootVal4 = constants.FOUR_THIRDS*(np.square(rightOvershootVal1) - np.square(rightOvershootVal2))
        for j in range(eigenVals.shape[0]):
            rightOvershootFactor += rightOvershootIndices*leftEigenmatrix[i,j,:] \
                                   *(rightOvershootVal3*(coeff1[j] - coeff2[j])
                                      + rightOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            rightInterfaceAvg[j] += rightOvershootFactor*rightEigenmatrix[j,i,:]

    #Lastly, we will apply our boundary conditions to obtain the left and right PPM reconstructed
    #states for every intercell boundary in the x-direction.
    if BcX == 0: #if the boundary condition is outflow
        if numDim == 1: #if the sim is 1D
            leftPrimVarState = np.append(leftInterfaceAvg[:,0].reshape(-1,1),rightInterfaceAvg,axis=1)
            rightPrimVarState = np.append(leftInterfaceAvg,
                                          rightInterfaceAvg[:,rightInterfaceAvg.shape[1]-1].reshape(-1,1),axis=1)
        elif numDim == 2: #if the sim is 2D
            leftPrimVarState = np.append(leftInterfaceAvg[:,:,0].reshape(leftInterfaceAvg.shape[0],-1,1),
                                         rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,
                                          rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1].reshape(leftInterfaceAvg.shape[0],
                                                                                                      -1,1),axis=2)
        else: #if the sim is 3D
            leftPrimVarState = np.append(leftInterfaceAvg[:,:,0,:].reshape(leftInterfaceAvg.shape[0],
                                                                           leftInterfaceAvg.shape[1],1,-1),
                                         rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,
                                          rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1,:].reshape(rightInterfaceAvg.shape[0],
                                                                                                        rightInterfaceAvg.shape[1],
                                                                                                        1,-1),axis=2)
    else: #if the boundary condition is periodic
        if numDim == 1: #if the sim is 1D
            leftPrimVarState = np.append(rightInterfaceAvg[:,rightInterfaceAvg.shape[1]-1].reshape(-1,1),
                                         rightInterfaceAvg,axis=1)
            rightPrimVarState = np.append(leftInterfaceAvg,leftInterfaceAvg[:,0],axis=1)
        elif numDim == 2: #if the sim is 2D
            leftPrimVarState = np.append(rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1].reshape(rightInterfaceAvg.shape[0],-1,1),
                                         rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,
                                          leftInterfaceAvg[:,:,0].reshape(leftInterfaceAvg.shape[0],-1,1),axis=2)
        else: #if the sim is 3D
            leftPrimVarState = np.append(rightInterfaceAvg[:,:,rightInterfaceAvg.shape[2]-1,:].reshape(rightInterfaceAvg.shape[0],
                                                                                                       rightInterfaceAvg.shape[1],
                                                                                                       1, -1),
                                         rightInterfaceAvg,axis=2)
            rightPrimVarState = np.append(leftInterfaceAvg,
                                          leftInterfaceAvg[:,:,0].reshape(leftInterfaceAvg.shape[0],
                                                                          leftInterfaceAvg.shape[1],1,-1),axis=2)

    #Return the reconstructed left and right states
    return leftPrimVarState, rightPrimVarState

####Y-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructY_hydro
#Purpose: Calculates the reconstructed/interpolated top and bottom states for every intercell
#         boundary in the y-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVars (the primitive variables for every cell in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dy (the cell height/size of the cell in the y-direction)
#                  BcY (integer for the boundary condition in the y-direction
#                      (0 = outflow and 1 = periodic))
#Outputs: topPrimVarState (the interpolated primitive variable states just above
#                          of each intercell boundary)
#         bottomPrimVarState (the interpolated primitive variable states just below
#                             of each intercell boundary)
def ppmReconstructY_hydro(primVars,gamma,dt,dy,BcY):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that the sim is 2D or 3D (if the sim is 1D, we shouldn't have a y-direction)
    assert numDim == 2 or numDim == 3, "Reconstruction algorithm (y-direction) encountered primitive variable matrix" \
                                       " with invalid dimensions"
    #We need to expand the primitive variable matrix so that it has two extra columns
    #in the y-direction on either side. These extra cells will simplify subsequent
    #steps in the algorithm. (Note: The number of extra cells we need on either side
    #is equal to the order of the reconstruction algorithm (i.e., 2 for second-order/PPM).)

    #Create an empty matrix for the expanded primitive variable grid
    if numDim == 2:
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2]))
    else:
        expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2],primVars.shape[3]))
    #Add the primitive variables we already have to the middle of the new grid
    expandedPrimVars[:,2:expandedPrimVars.shape[1]-2,:] = primVars[:]
    #Now we will figure out how we should fill the four additional rows.

    #Check whether the boundary condition (BC) in the y-direction is outflow or periodic
    if BcY == 0: #if the BC is outflow
        #If the BC is outflow, copy the topmost primitive variables into
        #both of the additional columns at the top.
        expandedPrimVars[:,0,:] = primVars[:,0,:]
        expandedPrimVars[:,1,:] = primVars[:,0,:]
        #Copy the lowermost primitive variables into the additional
        #columns at the bottom.
        expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,primVars.shape[1]-1,:]
        expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,primVars.shape[1]-1,:]
    else: #if the BC is periodic
        #If the BC is periodic, copy the lowermost primitive variables into
        #the additional columns at the top.
        expandedPrimVars[:,0,:] = primVars[:,primVars.shape[1]-2,:]
        expandedPrimVars[:,1,:] = primVars[:,primVars.shape[1]-1,:]
        #Copy the topmost primitive variables into the additional
        #columns at the bottom.
        expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,1,:]
        expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,0,:]

    #Using our expanded primitive variable matrix, we will create matrices
    #for top, bottom, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required by PPM
    #reconstruction.
    centPrimVars = expandedPrimVars[:,1:expandedPrimVars.shape[1]-1,:]
    topPrimVars = expandedPrimVars[:,0:expandedPrimVars.shape[1]-2,:]
    bottomPrimVars = expandedPrimVars[:,2:expandedPrimVars.shape[1],:]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesY_hydro(centPrimVars, gamma)

    #Calculate the primitive variable difference between the bottom and top cells
    centPrimVarDiff = bottomPrimVars - topPrimVars
    #Calculate the primitive variable difference between the centre and top cells
    topPrimVarDiff = centPrimVars - topPrimVars
    #Calculate the primitive variable difference between the bottom and centre cells
    bottomPrimVarDiff = bottomPrimVars - centPrimVars

    #Compute weight values for positions where the top and bottom differences
    #have the same sign (i.e., topPrimVarDiff and bottomPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = topPrimVarDiff*bottomPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*topPrimVarDiff*bottomPrimVarDiff)[weightIndices] \
                            /(topPrimVarDiff + bottomPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    topCharVarDiff = np.zeros(shape=topPrimVarDiff.shape)
    bottomCharVarDiff = np.zeros(shape=bottomPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            centCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*centPrimVarDiff[j,:]
            topCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*topPrimVarDiff[j,:]
            bottomCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*bottomPrimVarDiff[j,:]
            weightChar[i,:] += + leftEigenmatrix[i,j,:]*weight[j,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = topCharVarDiff*bottomCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(topCharVarDiff), np.abs(bottomCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1,limSlope2))[slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] += charMonSlopes[j,:] * rightEigenmatrix[i,j,:]
    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector above it, and the slope vector below it.
    centPrimMonSlopes = primMonSlopes[:,1:primMonSlopes.shape[1]-1,:]
    topPrimMonSlopes = primMonSlopes[:,0:primMonSlopes.shape[1]-2,:]
    bottomPrimMonSlopes = primMonSlopes[:,2:primMonSlopes.shape[1],:]
    #Remove the outermost columns from centPrimVars, topPrimVars, and bottomPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    centPrimVars = centPrimVars[:,1:centPrimVars.shape[1]-1,:]
    topPrimVars = topPrimVars[:,1:topPrimVars.shape[1]-1,:]
    bottomPrimVars = bottomPrimVars[:,1:bottomPrimVars.shape[1]-1,:]

    #Calculate an interpolated state on the upper edge of every cell
    topInterfaceAvg = 0.5*(centPrimVars + topPrimVars) \
                       - (centPrimMonSlopes - topPrimMonSlopes)/6.0
    #Calculate an interpolated state on the lower edge of every cell
    bottomInterfaceAvg = 0.5*(bottomPrimVars + centPrimVars) \
                        - (bottomPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena [2]
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the upper and lower halves of the cell
    diffProd = (bottomInterfaceAvg - centPrimVars)*(centPrimVars - topInterfaceAvg)
    #Calculate the difference between the top and bottom interface states
    interfaceDiff = bottomInterfaceAvg - topInterfaceAvg
    interfaceDiffSq = np.square(interfaceDiff)
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the left and right interpolated states.
    avgDiff = 6.0 * (centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
    #Apply monotonicity constraints
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    topInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    bottomInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctTopIndices = np.logical_and(diffProdPos,(interfaceDiff*avgDiff) > interfaceDiffSq)
    topInterfaceAvg[correctTopIndices] \
        = ((6.0*centPrimVars - 4.0*bottomInterfaceAvg)/2.0)[correctTopIndices]
    correctBottomIndices = np.logical_and(diffProdPos,np.logical_and(np.logical_not(correctTopIndices),(interfaceDiff*avgDiff) < (-1.0*interfaceDiffSq)))
    bottomInterfaceAvg[correctBottomIndices] \
        = ((6.0*centPrimVars - 4.0*topInterfaceAvg)/2.0)[correctBottomIndices]
    #Apply additional monotonicity constraints
    topInterfaceAvg = np.maximum(np.minimum(centPrimVars, topPrimVars), topInterfaceAvg)
    topInterfaceAvg = np.minimum(np.maximum(centPrimVars, topPrimVars), topInterfaceAvg)
    bottomInterfaceAvg = np.maximum(np.minimum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)
    bottomInterfaceAvg = np.minimum(np.maximum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    if numDim == 2:
        leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1,:]
        rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1,:]
        eigenVals = eigenVals[:,1:eigenVals.shape[1]-1,:]
    else:
        leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1,:,:]
        rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1,:,:]
        eigenVals = eigenVals[:,1:eigenVals.shape[1]-1,:,:]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdy = dt/dy
    coeff1 = bottomInterfaceAvg - topInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[4],0.0)*dtdy
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdy

    #Evolve the left interpolated state by half a timestep
    topInterfaceAvg = topInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the right interpolated state by half a timestep
    bottomInterfaceAvg = bottomInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)


    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas, we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid/overshoot wave contributions from the upper interpolated state.
    for i in range(eigenVals.shape[0]):
        topOvershootIndices = eigenVals[i] <= 0.0
        topOvershootFactor = np.zeros(shape=topOvershootIndices.shape)
        topOvershootVal1 = 0.5*dtdy*eigenVals[0]
        topOvershootVal2 = 0.5*dtdy*eigenVals[i]
        topOvershootVal3 = topOvershootVal1 - topOvershootVal2
        topOvershootVal4 = constants.FOUR_THIRDS*(np.square(topOvershootVal1) - np.square(topOvershootVal2))
        for j in range(eigenVals.shape[0]):
            topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,j,:] \
                                    *(topOvershootVal3*(coeff1[j] + coeff2[j])
                                       + topOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            topInterfaceAvg[j] += topOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the lower interpolated state.
    for i in range(eigenVals.shape[0]):
        bottomOvershootIndices = eigenVals[i] >= 0.0
        bottomOvershootFactor = np.zeros(shape=bottomOvershootIndices.shape)
        bottomOvershootVal1 = 0.5*dtdy*eigenVals[4]
        bottomOvershootVal2 = 0.5*dtdy*eigenVals[i]
        bottomOvershootVal3 = bottomOvershootVal1 - bottomOvershootVal2
        bottomOvershootVal4 = constants.FOUR_THIRDS*(np.square(bottomOvershootVal1) - np.square(bottomOvershootVal2))
        for j in range(eigenVals.shape[0]):
            bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,j,:] \
                                   *(bottomOvershootVal3*(coeff1[j] - coeff2[j])
                                      + bottomOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            bottomInterfaceAvg[j] += bottomOvershootFactor*rightEigenmatrix[j,i,:]

    #Lastly, we will apply our boundary conditions to obtain the top and bottom PPM reconstructed
    #states for every intercell boundary in the y-direction.
    if BcY == 0: #if the boundary condition is outflow
        if numDim == 2:
            topPrimVarState = np.append(topInterfaceAvg[:,0,:].reshape(topInterfaceAvg.shape[0],1,-1),
                                        bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
                                                                               bottomInterfaceAvg.shape[0],1,-1),axis=1)
        else:
            topPrimVarState = np.append(topInterfaceAvg[:,0,:,:].reshape(topInterfaceAvg.shape[0],1,
                                                                         topInterfaceAvg.shape[2],-1),
                                        bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
                                                                               bottomInterfaceAvg.shape[0],1,
                                                                               bottomInterfaceAvg.shape[2],-1),axis=1)
    else: #if the boundary condition is periodic
        if numDim == 2:
            topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
                                                                                            bottomInterfaceAvg.shape[0],
                                                                                            1,-1),
                                        bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           topInterfaceAvg[:,0,:].reshape(topInterfaceAvg.shape[0],1,-1),axis=1)
        else:
            topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:,:].reshape(
                                                                                            bottomInterfaceAvg.shape[0],
                                                                                            1,bottomInterfaceAvg.shape[2],-1),
                                        bottomInterfaceAvg,axis=1)
            bottomPrimVarState = np.append(topInterfaceAvg,
                                           topInterfaceAvg[:,0,:,:].reshape(topInterfaceAvg.shape[0],
                                                                            1,topInterfaceAvg.shape[2],-1),axis=1)
    #Return the reconstructed top and bottom states
    return topPrimVarState, bottomPrimVarState
#
# #Function: ppmReconstructY_hydro
# #Purpose: Calculates the reconstructed/interpolated top and bottom states for every intercell
# #         boundary in the y-direction, using the piecewise parabolic method (PPM).
# #Input Parameters: primVars (the primitive variables for every cell in the simulation grid)
# #                  gamma (the specific heat ratio of the ideal gas)
# #                  dt (the timestep size)
# #                  dy (the cell height/size of the cell in the y-direction)
# #                  BcY (integer for the boundary condition in the y-direction
# #                       (0 = outflow and 1 = periodic))
# #Outputs: topPrimVarState (the interpolated primitive variable states just above
# #                          each intercell boundary)
# #         bottomPrimVarState (the interpolated primitive variable states just below
# #                             each intercell boundary)
# def ppmReconstructY_hydro(primVars,gamma,dt,dy,BcY):
#     #Get the number of spatial dimensions in primVars
#     #(i.e., determine whether we are working with a
#     #       1D, 2D, or 3D simulation grid)
#     numDim = len(primVars.shape) - 1
#     #Ensure that there are only 1, 2, or 3 spatial dimensions
#     assert numDim == 1 or numDim == 2 or numDim == 3, "Reconstruction algorithm encountered primitive variable matrix" \
#                                                       " with invalid dimensions"
#     #We need to expand the primitive variable matrix so that it has two extra rows
#     #in the y-direction on either side. These extra cells will simplify subsequent
#     #steps in the algorithm.
#     #Create an empty matrix for the expanded primitive variable grid
#     if numDim == 2:
#         expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2]))
#     else:
#         expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1]+4,primVars.shape[2],primVars.shape[3]))
#     #Add the primitive variables we already have to the middle of the new grid
#     expandedPrimVars[:,2:expandedPrimVars.shape[1]-2,:] = primVars[:]
#     #Now we will figure out how we should fill the four additional rows
#     #Check whether the boundary condition (BC) in the y-direction is outflow or periodic
#     if BcY == 0: #if the BC is outflow
#         #If the BC is outflow, copy the topmost primitive variables into
#         #both of the additional columns at the top.
#         expandedPrimVars[:,0,:] = primVars[:,0,:]
#         expandedPrimVars[:,1,:] = primVars[:,0,:]
#         #Copy the lowermost primitive variables into the additional
#         #columns at the bottom.
#         expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,primVars.shape[1]-1,:]
#         expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,primVars.shape[1]-1,:]
#     else: #if the BC is periodic
#         #If the BC is periodic, copy the lowermost primitive variables into
#         #the additional columns at the top.
#         expandedPrimVars[:,0,:] = primVars[:,primVars.shape[1]-2,:]
#         expandedPrimVars[:,1,:] = primVars[:,primVars.shape[1]-1,:]
#         #Copy the topmost primitive variables into the additional
#         #columns at the bottom.
#         expandedPrimVars[:,expandedPrimVars.shape[1]-1,:] = primVars[:,1,:]
#         expandedPrimVars[:,expandedPrimVars.shape[1]-2,:] = primVars[:,0,:]
#
#     #Using our expanded primitive variable matrix, we will create matrices
#     #for top, bottom, and centre cells. Calculating the differences between
#     #these cells will allow us to calculate the slopes required by PPM
#     #reconstruction.
#     centPrimVars = expandedPrimVars[:,1:expandedPrimVars.shape[1]-1,:]
#     topPrimVars = expandedPrimVars[:,0:expandedPrimVars.shape[1]-2,:]
#     bottomPrimVars = expandedPrimVars[:,2:expandedPrimVars.shape[1],:]
#
#     #Calculate the eigenvalues and eigenmatrices for the central cells
#     (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesY_hydro(centPrimVars, gamma)
#
#     #Calculate the primitive variable difference between the bottom and top cells
#     centPrimVarDiff = bottomPrimVars - topPrimVars
#     #Calculate the primitive variable difference between the centre and top cells
#     topPrimVarDiff = centPrimVars - topPrimVars
#     #Calculate the primitive variable difference between the bottom and centre cells
#     bottomPrimVarDiff = bottomPrimVars - centPrimVars
#
#     #Compute weight values for positions where the top and bottom differences
#     #have the same sign (i.e., topPrimVarDiff and bottomPrimVarDiff are both
#     #positive or both negative).
#     weight = np.zeros(shape=centPrimVars.shape)
#     weightIndices = topPrimVarDiff*bottomPrimVarDiff > 0.0
#     weight[weightIndices] = (2.0*topPrimVarDiff*bottomPrimVarDiff)[weightIndices] \
#                             /(topPrimVarDiff + bottomPrimVarDiff)[weightIndices]
#
#     #Before using the left eigenmatriceses to project these
#     #difference values onto characteristic variables,
#     #we need to change the variable order from
#     #(density, vx, vy, vz, pressure) to
#     #(density, vy, vz, vx, pressure).
#     centPrimVarDiffCopy = np.copy(centPrimVarDiff)
#     centPrimVarDiff[1] = centPrimVarDiffCopy[2]
#     centPrimVarDiff[2] = centPrimVarDiffCopy[3]
#     centPrimVarDiff[3] = centPrimVarDiffCopy[1]
#     topPrimVarDiffCopy = np.copy(topPrimVarDiff)
#     topPrimVarDiff[1] = topPrimVarDiffCopy[2]
#     topPrimVarDiff[2] = topPrimVarDiffCopy[3]
#     topPrimVarDiff[3] = topPrimVarDiffCopy[1]
#     bottomPrimVarDiffCopy = np.copy(bottomPrimVarDiff)
#     bottomPrimVarDiff[1] = bottomPrimVarDiffCopy[2]
#     bottomPrimVarDiff[2] = bottomPrimVarDiffCopy[3]
#     bottomPrimVarDiff[3] = bottomPrimVarDiffCopy[1]
#     weightCopy = np.copy(weight)
#     weight[1] = weightCopy[2]
#     weight[2] = weightCopy[3]
#     weight[3] = weightCopy[1]
#
#     #Now we will use the left eigenmatrices to project the
#     #difference values onto characteristic variables
#     centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
#     topCharVarDiff = np.zeros(shape=topPrimVarDiff.shape)
#     bottomCharVarDiff = np.zeros(shape=bottomPrimVarDiff.shape)
#     weightChar = np.zeros(shape=weight.shape)
#     for i in range(primVars.shape[0]):
#         for j in range(primVars.shape[0]):
#             centCharVarDiff[i,:] = centCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*centPrimVarDiff[j,:]
#             topCharVarDiff[i,:] = topCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*topPrimVarDiff[j,:]
#             bottomCharVarDiff[i,:] = bottomCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*bottomPrimVarDiff[j,:]
#             weightChar[i,:] = weightChar[i,:] + leftEigenmatrix[i,j,:]*weight[j,:]
#
#     #Calculate the monotonized slopes for the characteristic difference values
#     #(ensures that the scheme is total variation diminishing (TVD))
#     charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
#     slopeLimitIndices = topCharVarDiff*bottomCharVarDiff > 0.0
#     limSlope1 = np.minimum(np.abs(topCharVarDiff), np.abs(bottomCharVarDiff))
#     limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
#     charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
#         slopeLimitIndices]
#
#     #Use the right eigenmatrix to convert the monotonized slopes
#     #back into primitive variables
#     primMonSlopes = np.zeros(shape=charMonSlopes.shape)
#     for i in range(primVars.shape[0]):
#         for j in range(primVars.shape[0]):
#             primMonSlopes[i,:] = primMonSlopes[i,:] + charMonSlopes[j,:] * rightEigenmatrix[i,j,:]
#     #Now we switch back to the original
#     #(density, vx, vy, vz, pressure)
#     #variable order
#     primMonSlopesCopy = np.copy(primMonSlopes)
#     primMonSlopes[1] = primMonSlopesCopy[3]
#     primMonSlopes[2] = primMonSlopesCopy[1]
#     primMonSlopes[3] = primMonSlopesCopy[2]
#     #For each cell in our original primitive variables grid, we need to know its primitive monotonized
#     #slope vector, the slope vector above it, and the slope vector below it.
#     centPrimMonSlopes = primMonSlopes[:,1:primMonSlopes.shape[1]-1,:]
#     topPrimMonSlopes = primMonSlopes[:,0:primMonSlopes.shape[1]-2,:]
#     bottomPrimMonSlopes = primMonSlopes[:,2:primMonSlopes.shape[1],:]
#     #Remove the outermost columns from centPrimVars, topPrimVars, and bottomPrimVars
#     #(in order to match the dimensions of our primitive slope matrices).
#     centPrimVars = centPrimVars[:,1:centPrimVars.shape[1]-1,:]
#     topPrimVars = topPrimVars[:,1:topPrimVars.shape[1]-1,:]
#     bottomPrimVars = bottomPrimVars[:,1:bottomPrimVars.shape[1]-1,:]
#
#     #Calculate an interpolated state at the top edge of every cell
#     topInterfaceAvg = 0.5*(centPrimVars + topPrimVars) \
#                        - (1.0/6.0)*(centPrimMonSlopes - topPrimMonSlopes)
#     #Calculate an interpolated state at the bottom edge of every cell
#     bottomInterfaceAvg = 0.5*(bottomPrimVars + centPrimVars) \
#                         - (1.0/6.0)*(bottomPrimMonSlopes - centPrimMonSlopes)
#
#     #Next we will calculate a number of values from the 2017 version of Athena
#     #that will help us refine these interpolated states
#
#     #Calculate the product between the primitive variable changes over the top and bottom halves of the cell
#     diffProd = (bottomInterfaceAvg - centPrimVars)*(centPrimVars - topInterfaceAvg)
#     #Calculate the difference between the top and bottom interface states
#     interfaceDiff = bottomInterfaceAvg - topInterfaceAvg
#     #Calculate a value that is proportional to the difference between the actual
#     #cell-centred variables and the average of the top and bottom interpolated states.
#     avgDiff = 6.0*(centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
#     #Apply monotonicity constraints
#     topInterfaceAvg[diffProd <= 0.0] = centPrimVars[diffProd <= 0.0]
#     bottomInterfaceAvg[diffProd <= 0.0] = centPrimVars[diffProd <= 0.0]
#     topInterfaceAvg[(interfaceDiff*avgDiff) > np.square(interfaceDiff)] \
#         = ((6.0*centPrimVars - 4.0*bottomInterfaceAvg) / 2.0)[
#         (interfaceDiff*avgDiff) > np.square(interfaceDiff)]
#     bottomInterfaceAvg[(interfaceDiff*avgDiff) < (-1.0 * np.square(interfaceDiff))] \
#         = ((6.0*centPrimVars - 4.0*topInterfaceAvg) / 2.0)[
#         (interfaceDiff*avgDiff) < (-1.0*np.square(interfaceDiff))]
#     #Apply additional monotonicity constraints
#     topInterfaceAvg = np.maximum(np.minimum(centPrimVars, topPrimVars), topInterfaceAvg)
#     topInterfaceAvg = np.minimum(np.maximum(centPrimVars, topPrimVars), topInterfaceAvg)
#     bottomInterfaceAvg = np.maximum(np.minimum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)
#     bottomInterfaceAvg = np.minimum(np.maximum(centPrimVars, bottomPrimVars), bottomInterfaceAvg)
#
#     #Calculate coefficients that will allow us to evolve our interpolated values
#     #by half a timestep
#     coeff1 = bottomInterfaceAvg - topInterfaceAvg
#     coeff2 = 6.0*(centPrimVars - 0.5*(topInterfaceAvg + bottomInterfaceAvg))
#     coeff3 = 0.5*np.maximum(np.max(eigenVals[4]),0.0)*dt/dy
#     coeff4 = -0.5*np.minimum(np.min(eigenVals[0]),0.0)*dt/dy
#
#     #Evolve the top interpolated state by half a timestep
#     topInterfaceAvg = topInterfaceAvg + coeff4*(coeff1 + (1.0 - (4.0/3.0)*coeff4)*coeff2)
#     #Evolve the bottom interpolated state by half a timestep
#     bottomInterfaceAvg = bottomInterfaceAvg - coeff3*(coeff1 - (1.0 - (4.0/3.0)*coeff3)*coeff2)
#
#     #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
#     #Using Athena's characteristic tracing formulas, we will now subtract all of the
#     #wave contributions that do not reach the interface in dt/2.
#
#     #We need to put coeff1 and coeff2 into the
#     #(density, vy, vz, vx, pressure) variable order,
#     #because we will use the left eigenmatrix
#     #to project them onto characteristic variables.
#     coeff1Copy = np.copy(coeff1)
#     coeff1[1] = coeff1Copy[2]
#     coeff1[2] = coeff1Copy[3]
#     coeff1[3] = coeff1Copy[1]
#     coeff2Copy = np.copy(coeff2)
#     coeff2[1] = coeff2Copy[2]
#     coeff2[2] = coeff2Copy[3]
#     coeff2[3] = coeff2Copy[1]
#
#     #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
#     if numDim == 2:
#         leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1,:]
#         rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1,:]
#         eigenVals = eigenVals[:,1:eigenVals.shape[1]-1,:]
#     else:
#         leftEigenmatrix = leftEigenmatrix[:,:,1:leftEigenmatrix.shape[2]-1,:,:]
#         rightEigenmatrix = rightEigenmatrix[:,:,1:rightEigenmatrix.shape[2]-1,:,:]
#         eigenVals = eigenVals[:,1:eigenVals.shape[1]-1,:,:]
#
#     #Subtract invalid wave contributions from the top interpolated state.
#     for i in range(eigenVals.shape[0]):
#         topOvershootIndices = eigenVals[i] <= 0.0
#         topOvershootFactor = np.zeros(shape=topOvershootIndices.shape)
#         topOvershootVal1 = 0.5*(dt/dy)*eigenVals[0]
#         topOvershootVal2 = 0.5*(dt/dy)*eigenVals[i]
#         topOvershootVal3 = topOvershootVal1 - topOvershootVal2
#         topOvershootVal4 = (4.0/3.0)*(np.square(topOvershootVal1) - np.square(topOvershootVal2))
#         for j in range(eigenVals.shape[0]):
#             topOvershootFactor += topOvershootIndices*leftEigenmatrix[i,j,:] \
#                                     *(topOvershootVal3*(coeff1[j] + coeff2[j])
#                                        + topOvershootVal4*coeff2[j])
#         topOvershootCorr = np.zeros(shape=topInterfaceAvg.shape)
#         for j in range(eigenVals.shape[0]):
#             topOvershootCorr[j] = topOvershootFactor*rightEigenmatrix[j,i,:]
#         #Put the correction vector into the
#         #(density, vx, vy, vz, pressure)
#         #variable order
#         topOvershootCorrCopy = np.copy(topOvershootCorr)
#         topOvershootCorr[1] = topOvershootCorrCopy[3]
#         topOvershootCorr[2] = topOvershootCorrCopy[1]
#         topOvershootCorr[3] = topOvershootCorrCopy[2]
#         #Add the correction values to the upper interpolated state
#         topInterfaceAvg += topOvershootCorr
#
#     #Subtract invalid wave contributions from the bottom interpolated state.
#     for i in range(eigenVals.shape[0]):
#         bottomOvershootIndices = eigenVals[i] >= 0.0
#         bottomOvershootFactor = np.zeros(shape=bottomOvershootIndices.shape)
#         bottomOvershootVal1 = 0.5*(dt/dy)*eigenVals[4]
#         bottomOvershootVal2 = 0.5*(dt/dy)*eigenVals[i]
#         bottomOvershootVal3 = bottomOvershootVal1 - bottomOvershootVal2
#         bottomOvershootVal4 = (4.0/3.0)*(np.square(bottomOvershootVal1) - np.square(bottomOvershootVal2))
#         for j in range(eigenVals.shape[0]):
#             bottomOvershootFactor += bottomOvershootIndices*leftEigenmatrix[i,j,:] \
#                                    *(bottomOvershootVal3*(coeff1[j] - coeff2[j])
#                                       + bottomOvershootVal4*coeff2[j])
#         bottomOvershootCorr = np.zeros(shape=bottomInterfaceAvg.shape)
#         for j in range(eigenVals.shape[0]):
#             bottomOvershootCorr[j] = bottomOvershootFactor*rightEigenmatrix[j,i,:]
#         #Put the correction vector into the
#         #(density, vx, vy, vz, pressure)
#         #variable order
#         bottomOvershootCorrCopy = np.copy(bottomOvershootCorr)
#         bottomOvershootCorr[1] = bottomOvershootCorrCopy[3]
#         bottomOvershootCorr[2] = bottomOvershootCorrCopy[1]
#         bottomOvershootCorr[3] = bottomOvershootCorrCopy[2]
#         #Add the correction values to the lower interpolated state
#         bottomInterfaceAvg += bottomOvershootCorr
#
#     #Lastly, we will apply our boundary conditions to obtain the top and bottom PPM reconstructed
#     #states for every intercell boundary in the y-direction.
#     if BcY == 0: #if the boundary condition is outflow
#         if numDim == 2:
#             topPrimVarState = np.append(topInterfaceAvg[:,0,:].reshape(topInterfaceAvg.shape[0],1,-1),
#                                         bottomInterfaceAvg,axis=1)
#             bottomPrimVarState = np.append(topInterfaceAvg,
#                                            bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
#                                                                                bottomInterfaceAvg.shape[0],1,-1),
#                                            axis=1)
#         else:
#             topPrimVarState = np.append(topInterfaceAvg[:,0,:,:].reshape(topInterfaceAvg.shape[0],1,
#                                                                          topInterfaceAvg.shape[2],-1),
#                                         bottomInterfaceAvg,axis=1)
#             bottomPrimVarState = np.append(topInterfaceAvg,
#                                            bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
#                                                                                bottomInterfaceAvg.shape[0],1,
#                                                                                bottomInterfaceAvg.shape[2],-1),
#                                            axis=1)
#     else: #if the boundary condition is periodic
#         if numDim == 2:
#             topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:].reshape(
#                                                                                             bottomInterfaceAvg.shape[0],
#                                                                                             1,-1),
#                                         bottomInterfaceAvg,axis=1)
#             bottomPrimVarState = np.append(topInterfaceAvg,
#                                            topInterfaceAvg[:,0,:].reshape(topInterfaceAvg.shape[0],1,-1),
#                                            axis=1)
#         else:
#             topPrimVarState = np.append(bottomInterfaceAvg[:,bottomInterfaceAvg.shape[1]-1,:,:].reshape(
#                                                                                             bottomInterfaceAvg.shape[0],
#                                                                                             1,bottomInterfaceAvg.shape[2],-1),
#                                         bottomInterfaceAvg,axis=1)
#             bottomPrimVarState = np.append(topInterfaceAvg,
#                                            topInterfaceAvg[:,0,:,:].reshape(topInterfaceAvg.shape[0],
#                                                                             1,topInterfaceAvg.shape[2],-1),
#                                            axis=1)
#
#
#     #Return the reconstructed top and bottom states
#     return topPrimVarState, bottomPrimVarState

#####Z-DIRECTION PPM RECONSTRUCTION######
#Function: ppmReconstructZ_hydro
#Purpose: Calculates the reconstructed/interpolated back and forward states for every intercell
#         boundary in the z-direction, using the piecewise parabolic method (PPM) [1].
#Input Parameters: primVars (the primitive variables for every cell in the simulation grid)
#                  gamma (the specific heat ratio of the ideal gas)
#                  dt (the timestep size)
#                  dz (the cell depth/size of the cell in the z-direction)
#                  BcZ (integer for the boundary condition in the z-direction
#                      (0 = outflow and 1 = periodic))
#Outputs: backPrimVarState (the interpolated primitive variable states just behind
#                           of each intercell boundary)
#         forwPrimVarState (the interpolated primitive variable states just in front of
#                           of each intercell boundary)
def ppmReconstructZ_hydro(primVars,gamma,dt,dz,BcZ):
    #Get the number of spatial dimensions in primVars
    #(i.e., determine whether we are working with a
    #       1D, 2D, or 3D simulation grid)
    numDim = len(primVars.shape) - 1
    #Ensure that the sim is 3D (otherwise we shouldn't have a z-direction)
    assert numDim == 3, "Reconstruction algorithm (z-direction) encountered primitive variable matrix" \
                        " with invalid dimensions"
    #We need to expand the primitive variable matrix so that it has two extra rows
    #in the z-direction on either side. These extra cells will simplify subsequent
    #steps in the algorithm. (Note: The number of extra cells we need on either side
    #is equal to the order of the reconstruction algorithm (i.e., 2 for second-order/PPM).)
    #Create an empty matrix for the expanded primitive variable grid
    expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2],primVars.shape[3]+4))
    #Add the primitive variables we already have to the middle of the new grid
    expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]-2] = primVars[:,:,:,:]
    #Now we will figure out how we should fill the four additional rows
    #Check whether the boundary condition (BC) in the z-direction is outflow or periodic
    if BcZ == 0: #if the BC is outflow
        #If the BC is outflow, copy the farthest back primitive variables into
        #both of the additional columns at the front.
        expandedPrimVars[:,:,:,0] = primVars[:,:,:,0]
        expandedPrimVars[:,:,:,1] = primVars[:,:,:,0]
        #Copy the frontmost primitive variables into the additional
        #columns at the back.
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,primVars.shape[3]-1]
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,primVars.shape[3]-1]
    else: #if the BC is periodic
        #If the BC is periodic, copy the frontmost primitive variables into
        #the additional columns at the back.
        expandedPrimVars[:,:,:,0] = primVars[:,:,:,primVars.shape[3]-2]
        expandedPrimVars[:,:,:,1] = primVars[:,:,:,primVars.shape[3]-1]
        #Copy the farthest back primitive variables into the additional
        #columns at the front.
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,1]
        expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,0]

    #Using our expanded primitive variable matrix, we will create matrices
    #for back, forward, and centre cells. Calculating the differences between
    #these cells will allow us to calculate the slopes required by PPM
    #reconstruction.
    centPrimVars = expandedPrimVars[:,:,:,1:expandedPrimVars.shape[3]-1]
    backPrimVars = expandedPrimVars[:,:,:,0:expandedPrimVars.shape[3]-2]
    forwPrimVars = expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]]

    #Calculate the eigenvalues and eigenmatrices for the central cells
    (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesZ_hydro(centPrimVars, gamma)

    #Calculate the primitive variable difference between the forward and backward cells
    centPrimVarDiff = forwPrimVars - backPrimVars
    #Calculate the primitive variable difference between the centre and backward cells
    backPrimVarDiff = centPrimVars - backPrimVars
    #Calculate the primitive variable difference between the forward and centre cells
    forwPrimVarDiff = forwPrimVars - centPrimVars

    #Compute weight values for positions where the back and forward differences
    #have the same sign (i.e., backPrimVarDiff and forwPrimVarDiff are both
    #positive or both negative).
    weight = np.zeros(shape=centPrimVars.shape)
    weightIndices = backPrimVarDiff*forwPrimVarDiff > 0.0
    weight[weightIndices] = (2.0*backPrimVarDiff*forwPrimVarDiff)[weightIndices] \
                            /(backPrimVarDiff + forwPrimVarDiff)[weightIndices]

    #Now we will use the left eigenmatrices to project the
    #difference values onto characteristic variables
    centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
    backCharVarDiff = np.zeros(shape=backPrimVarDiff.shape)
    forwCharVarDiff = np.zeros(shape=forwPrimVarDiff.shape)
    weightChar = np.zeros(shape=weight.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            centCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*centPrimVarDiff[j,:]
            backCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*backPrimVarDiff[j,:]
            forwCharVarDiff[i,:] += leftEigenmatrix[i,j,:]*forwPrimVarDiff[j,:]
            weightChar[i,:] += + leftEigenmatrix[i,j,:]*weight[j,:]

    #Calculate the monotonized slopes for the characteristic difference values
    #(ensures that the scheme is total variation diminishing (TVD))
    charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
    slopeLimitIndices = backCharVarDiff*forwCharVarDiff > 0.0
    limSlope1 = np.minimum(np.abs(backCharVarDiff), np.abs(forwCharVarDiff))
    limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
    charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1,limSlope2))[slopeLimitIndices]

    #Use the right eigenmatrix to convert the monotonized slopes
    #back into primitive variables
    primMonSlopes = np.zeros(shape=charMonSlopes.shape)
    for i in range(primVars.shape[0]):
        for j in range(primVars.shape[0]):
            primMonSlopes[i,:] += charMonSlopes[j,:] * rightEigenmatrix[i,j,:]
    #For each cell in our original primitive variables grid, we need to know its primitive monotonized
    #slope vector, the slope vector behind it, and the slope vector in front of it.
    centPrimMonSlopes = primMonSlopes[:,:,:,1:primMonSlopes.shape[3]-1]
    backPrimMonSlopes = primMonSlopes[:,:,:,0:primMonSlopes.shape[3]-2]
    forwPrimMonSlopes = primMonSlopes[:,:,:,2:primMonSlopes.shape[3]]
    #Remove the outermost columns from centPrimVars, backPrimVars, and forwPrimVars
    #(in order to match the dimensions of our primitive slope matrices).
    centPrimVars = centPrimVars[:,:,:,1:centPrimVars.shape[3]-1]
    backPrimVars = backPrimVars[:,:,:,1:backPrimVars.shape[3]-1]
    forwPrimVars = forwPrimVars[:,:,:,1:forwPrimVars.shape[3]-1]

    #Calculate an interpolated state on the back edge of every cell
    backInterfaceAvg = 0.5*(centPrimVars + backPrimVars) \
                       - (centPrimMonSlopes - backPrimMonSlopes)/6.0
    #Calculate an interpolated state on the forward edge of every cell
    forwInterfaceAvg = 0.5*(forwPrimVars + centPrimVars) \
                        - (forwPrimMonSlopes - centPrimMonSlopes)/6.0

    #Next we will calculate a number of values from the 2017 version of Athena [2]
    #that will help us refine these interpolated states

    #Calculate the product between the primitive variable changes over the back and forward halves of the cell
    diffProd = (forwInterfaceAvg - centPrimVars)*(centPrimVars - backInterfaceAvg)
    #Calculate the difference between the back and forward interface states
    interfaceDiff = forwInterfaceAvg - backInterfaceAvg
    interfaceDiffSq = np.square(interfaceDiff)
    #Calculate a value that is proportional to the difference between the actual
    #cell-centred variables and the average of the back and forward interpolated states.
    avgDiff = 6.0 * (centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
    #Apply monotonicity constraints
    diffProdNegOrZero = diffProd <= 0.0
    diffProdPos = np.logical_not(diffProdNegOrZero)
    backInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    forwInterfaceAvg[diffProdNegOrZero] = centPrimVars[diffProdNegOrZero]
    correctBackIndices = np.logical_and(diffProdPos,(interfaceDiff*avgDiff) > interfaceDiffSq)
    backInterfaceAvg[correctBackIndices] \
        = ((6.0*centPrimVars - 4.0*forwInterfaceAvg)/2.0)[correctBackIndices]
    correctForwIndices = np.logical_and(diffProdPos,np.logical_and(np.logical_not(correctBackIndices),(interfaceDiff*avgDiff) < (-1.0*interfaceDiffSq)))
    forwInterfaceAvg[correctForwIndices] \
        = ((6.0*centPrimVars - 4.0*backInterfaceAvg)/2.0)[correctForwIndices]
    #Apply additional monotonicity constraints
    backInterfaceAvg = np.maximum(np.minimum(centPrimVars, backPrimVars), backInterfaceAvg)
    backInterfaceAvg = np.minimum(np.maximum(centPrimVars, backPrimVars), backInterfaceAvg)
    forwInterfaceAvg = np.maximum(np.minimum(centPrimVars, forwPrimVars), forwInterfaceAvg)
    forwInterfaceAvg = np.minimum(np.maximum(centPrimVars, forwPrimVars), forwInterfaceAvg)

    #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
    leftEigenmatrix = leftEigenmatrix[:,:,:,:,1:leftEigenmatrix.shape[4]-1]
    rightEigenmatrix = rightEigenmatrix[:,:,:,:,1:rightEigenmatrix.shape[4]-1]
    eigenVals = eigenVals[:,:,:,1:eigenVals.shape[3]-1]

    #Calculate coefficients that will allow us to evolve our interpolated values
    #by half a timestep
    dtdz = dt/dz
    coeff1 = forwInterfaceAvg - backInterfaceAvg
    coeff2 = 6.0*(centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
    coeff3 = 0.5*np.maximum(eigenVals[4],0.0)*dtdz
    coeff4 = -0.5*np.minimum(eigenVals[0],0.0)*dtdz

    #Evolve the back interpolated state by half a timestep
    backInterfaceAvg = backInterfaceAvg + coeff4*(coeff1 + (1.0 - constants.FOUR_THIRDS*coeff4)*coeff2)
    #Evolve the forward interpolated state by half a timestep
    forwInterfaceAvg = forwInterfaceAvg - coeff3*(coeff1 - (1.0 - constants.FOUR_THIRDS*coeff3)*coeff2)


    #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
    #Using Athena's characteristic tracing formulas, we will now subtract all of the
    #wave contributions that do not reach the interface in dt/2.

    #Subtract invalid/overshoot wave contributions from the back interpolated state.
    for i in range(eigenVals.shape[0]):
        backOvershootIndices = eigenVals[i] <= 0.0
        backOvershootFactor = np.zeros(shape=backOvershootIndices.shape)
        backOvershootVal1 = 0.5*dtdz*eigenVals[0]
        backOvershootVal2 = 0.5*dtdz*eigenVals[i]
        backOvershootVal3 = backOvershootVal1 - backOvershootVal2
        backOvershootVal4 = constants.FOUR_THIRDS*(np.square(backOvershootVal1) - np.square(backOvershootVal2))
        for j in range(eigenVals.shape[0]):
            backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,j,:] \
                                    *(backOvershootVal3*(coeff1[j] + coeff2[j])
                                       + backOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            backInterfaceAvg[j] += backOvershootFactor*rightEigenmatrix[j,i,:]

    #Subtract invalid/overshoot wave contributions from the forward interpolated state.
    for i in range(eigenVals.shape[0]):
        forwOvershootIndices = eigenVals[i] >= 0.0
        forwOvershootFactor = np.zeros(shape=forwOvershootIndices.shape)
        forwOvershootVal1 = 0.5*dtdz*eigenVals[4]
        forwOvershootVal2 = 0.5*dtdz*eigenVals[i]
        forwOvershootVal3 = forwOvershootVal1 - forwOvershootVal2
        forwOvershootVal4 = constants.FOUR_THIRDS*(np.square(forwOvershootVal1) - np.square(forwOvershootVal2))
        for j in range(eigenVals.shape[0]):
            forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,j,:] \
                                   *(forwOvershootVal3*(coeff1[j] - coeff2[j])
                                      + forwOvershootVal4*coeff2[j])
        for j in range(eigenVals.shape[0]):
            forwInterfaceAvg[j] += forwOvershootFactor*rightEigenmatrix[j,i,:]

    #Lastly, we will apply our boundary conditions to obtain the back and forward PPM reconstructed
    #states for every intercell boundary in the z-direction.
    if BcZ == 0: #if the boundary condition is outflow
        backPrimVarState = np.append(backInterfaceAvg[:,:,:,0].reshape(backInterfaceAvg.shape[0],
                                                                       backInterfaceAvg.shape[1],-1,1),
                                     forwInterfaceAvg,axis=3)
        forwPrimVarState = np.append(backInterfaceAvg,
                                     forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(
                                                                           forwInterfaceAvg.shape[0],
                                                                           forwInterfaceAvg.shape[1],-1,1),axis=3)
    else: #if the boundary condition is periodic
        backPrimVarState = np.append(forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(
                                                                                        forwInterfaceAvg.shape[0],
                                                                                        forwInterfaceAvg.shape[1],-1,1),
                                     forwInterfaceAvg,axis=3)
        forwPrimVarState = np.append(backInterfaceAvg,
                                     backInterfaceAvg[:,:,:,0].reshape(backInterfaceAvg.shape[0],
                                                                       backInterfaceAvg.shape[1],-1,1),axis=3)

    #Return the reconstructed back and forward states
    return backPrimVarState, forwPrimVarState

# #Function: ppmReconstructZ_hydro
# #Purpose: Calculates the reconstructed/interpolated back and forward states for every intercell
# #         boundary in the z-direction, using the piecewise parabolic method (PPM).
# #Input Parameters: primVars (the primitive variables for every cell in the simulation grid)
# #                  gamma (the specific heat ratio of the ideal gas)
# #                  dt (the timestep size)
# #                  dz (the cell depth/size of the cell in the z-direction)
# #                  BcZ (integer for the boundary condition in the z-direction
# #                       (0 = outflow and 1 = periodic))
# #Outputs: backPrimVarState (the interpolated primitive variable states just behind
# #                           each intercell boundary)
# #         forwPrimVarState (the interpolated primitive variable states just in front of
# #                           each intercell boundary)
# def ppmReconstructZ_hydro(primVars,gamma,dt,dz,BcZ):
#     #Get the number of spatial dimensions in primVars
#     #(i.e., determine whether we are working with a
#     #       1D, 2D, or 3D simulation grid)
#     numDim = len(primVars.shape) - 1
#     #Ensure that there are only 1, 2, or 3 spatial dimensions
#     assert numDim == 1 or numDim == 2 or numDim == 3, "Reconstruction algorithm encountered primitive variable matrix" \
#                                                       " with invalid dimensions"
#     #We need to expand the primitive variable matrix so that it has two extra rows
#     #in the z-direction on either side. These extra cells will simplify subsequent
#     #steps in the algorithm.
#     #Create an empty matrix for the expanded primitive variable grid
#     expandedPrimVars = np.zeros(shape=(primVars.shape[0],primVars.shape[1],primVars.shape[2],primVars.shape[3]+4))
#     #Add the primitive variables we already have to the middle of the new grid
#     expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]-2] = primVars[:,:,:,:]
#     #Now we will figure out how we should fill the four additional rows
#     #Check whether the boundary condition (BC) in the z-direction is outflow or periodic
#     if BcZ == 0: #if the BC is outflow
#         #If the BC is outflow, copy the farthest back primitive variables into
#         #both of the additional columns at the front.
#         expandedPrimVars[:,:,:,0] = primVars[:,:,:,0]
#         expandedPrimVars[:,:,:,1] = primVars[:,:,:,0]
#         #Copy the frontmost primitive variables into the additional
#         #columns at the back.
#         expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,primVars.shape[3]-1]
#         expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,primVars.shape[3]-1]
#     else: #if the BC is periodic
#         #If the BC is periodic, copy the frontmost primitive variables into
#         #the additional columns at the back.
#         expandedPrimVars[:,:,:,0] = primVars[:,:,:,primVars.shape[3]-2]
#         expandedPrimVars[:,:,:,1] = primVars[:,:,:,primVars.shape[3]-1]
#         #Copy the farthest back primitive variables into the additional
#         #columns at the front.
#         expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-1] = primVars[:,:,:,1]
#         expandedPrimVars[:,:,:,expandedPrimVars.shape[3]-2] = primVars[:,:,:,0]
#
#     #Using our expanded primitive variable matrix, we will create matrices
#     #for back, forward, and centre cells. Calculating the differences between
#     #these cells will allow us to calculate the slopes required by PPM
#     #reconstruction.
#     centPrimVars = expandedPrimVars[:,:,:,1:expandedPrimVars.shape[3]-1]
#     backPrimVars = expandedPrimVars[:,:,:,0:expandedPrimVars.shape[3]-2]
#     forwPrimVars = expandedPrimVars[:,:,:,2:expandedPrimVars.shape[3]]
#
#     #Calculate the eigenvalues and eigenmatrices for the central cells
#     (eigenVals, leftEigenmatrix, rightEigenmatrix) = eig.getEigenmatricesZ_hydro(centPrimVars, gamma)
#
#     #Calculate the primitive variable difference between the forward and backward cells
#     centPrimVarDiff = forwPrimVars - backPrimVars
#     #Calculate the primitive variable difference between the centre and backward cells
#     backPrimVarDiff = centPrimVars - backPrimVars
#     #Calculate the primitive variable difference between the forward and centre cells
#     forwPrimVarDiff = forwPrimVars - centPrimVars
#
#     #Compute weight values for positions where the back and forward differences
#     #have the same sign (i.e., backPrimVarDiff and forwPrimVarDiff are both
#     #positive or both negative).
#     weight = np.zeros(shape=centPrimVars.shape)
#     weightIndices = backPrimVarDiff*forwPrimVarDiff > 0.0
#     weight[weightIndices] = (2.0*backPrimVarDiff*forwPrimVarDiff)[weightIndices] \
#                             /(backPrimVarDiff + forwPrimVarDiff)[weightIndices]
#
#     #Before using the left eigenmatriceses to project these
#     #difference values onto characteristic variables,
#     #we need to change the variable order from
#     #(density, vx, vy, vz, pressure) to
#     #(density, vz, vx, vy, pressure).
#     centPrimVarDiffCopy = np.copy(centPrimVarDiff)
#     centPrimVarDiff[1] = centPrimVarDiffCopy[3]
#     centPrimVarDiff[2] = centPrimVarDiffCopy[1]
#     centPrimVarDiff[3] = centPrimVarDiffCopy[2]
#     backPrimVarDiffCopy = np.copy(backPrimVarDiff)
#     backPrimVarDiff[1] = backPrimVarDiffCopy[3]
#     backPrimVarDiff[2] = backPrimVarDiffCopy[1]
#     backPrimVarDiff[3] = backPrimVarDiffCopy[2]
#     forwPrimVarDiffCopy = np.copy(forwPrimVarDiff)
#     forwPrimVarDiff[1] = forwPrimVarDiffCopy[3]
#     forwPrimVarDiff[2] = forwPrimVarDiffCopy[1]
#     forwPrimVarDiff[3] = forwPrimVarDiffCopy[2]
#     weightCopy = np.copy(weight)
#     weight[1] = weightCopy[3]
#     weight[2] = weightCopy[1]
#     weight[3] = weightCopy[2]
#
#     #Now we will use the left eigenmatrices to project the
#     #difference values onto characteristic variables
#     centCharVarDiff = np.zeros(shape=centPrimVarDiff.shape)
#     backCharVarDiff = np.zeros(shape=backPrimVarDiff.shape)
#     forwCharVarDiff = np.zeros(shape=forwPrimVarDiff.shape)
#     weightChar = np.zeros(shape=weight.shape)
#     for i in range(primVars.shape[0]):
#         for j in range(primVars.shape[0]):
#             centCharVarDiff[i,:] = centCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*centPrimVarDiff[j,:]
#             backCharVarDiff[i,:] = backCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*backPrimVarDiff[j,:]
#             forwCharVarDiff[i,:] = forwCharVarDiff[i,:] + leftEigenmatrix[i,j,:]*forwPrimVarDiff[j,:]
#             weightChar[i,:] = weightChar[i,:] + leftEigenmatrix[i,j,:]*weight[j,:]
#
#     #Calculate the monotonized slopes for the characteristic difference values
#     #(ensures that the scheme is total variation diminishing (TVD))
#     charMonSlopes = np.zeros(shape=centCharVarDiff.shape)
#     slopeLimitIndices = backCharVarDiff*forwCharVarDiff > 0.0
#     limSlope1 = np.minimum(np.abs(backCharVarDiff), np.abs(forwCharVarDiff))
#     limSlope2 = np.minimum(0.5*np.abs(centCharVarDiff), np.abs(weightChar))
#     charMonSlopes[slopeLimitIndices] = (np.sign(centCharVarDiff)*np.minimum(2.0*limSlope1, limSlope2))[
#         slopeLimitIndices]
#
#     #Use the right eigenmatrix to convert the monotonized slopes
#     #back into primitive variables
#     primMonSlopes = np.zeros(shape=charMonSlopes.shape)
#     for i in range(primVars.shape[0]):
#         for j in range(primVars.shape[0]):
#             primMonSlopes[i,:] = primMonSlopes[i,:] + charMonSlopes[j,:]*rightEigenmatrix[i,j,:]
#     #Now we switch back to the original
#     #(density, vx, vy, vz, pressure)
#     #variable order
#     primMonSlopesCopy = np.copy(primMonSlopes)
#     primMonSlopes[1] = primMonSlopesCopy[2]
#     primMonSlopes[2] = primMonSlopesCopy[3]
#     primMonSlopes[3] = primMonSlopesCopy[1]
#     #For each cell in our original primitive variables grid, we need to know its primitive monotonized
#     #slope vector, the slope vector behind it, and the slope vector in front of it.
#     centPrimMonSlopes = primMonSlopes[:,:,:,1:primMonSlopes.shape[3]-1]
#     backPrimMonSlopes = primMonSlopes[:,:,:,0:primMonSlopes.shape[3]-2]
#     forwPrimMonSlopes = primMonSlopes[:,:,:,2:primMonSlopes.shape[3]]
#     #Remove the outermost columns from centPrimVars, backPrimVars, and forwPrimVars
#     #(in order to match the dimensions of our primitive slope matrices).
#     centPrimVars = centPrimVars[:,:,:,1:centPrimVars.shape[3]-1]
#     backPrimVars = backPrimVars[:,:,:,1:backPrimVars.shape[3]-1]
#     forwPrimVars = forwPrimVars[:,:,:,1:forwPrimVars.shape[3]-1]
#
#     #Calculate an interpolated state at the back edge every cell
#     backInterfaceAvg = 0.5*(centPrimVars + backPrimVars) \
#                        - (1.0/6.0)*(centPrimMonSlopes - backPrimMonSlopes)
#     #Calculate an interpolated state at the front edge of every cell
#     forwInterfaceAvg = 0.5*(forwPrimVars + centPrimVars) \
#                         - (1.0/6.0)*(forwPrimMonSlopes - centPrimMonSlopes)
#
#     #Next we will calculate a number of values from the 2017 version of Athena
#     #that will help us refine these interpolated states
#
#     #Calculate the product between the primitive variable changes over the back and front halves of the cell
#     diffProd = (forwInterfaceAvg - centPrimVars)*(centPrimVars - backInterfaceAvg)
#     #Calculate the difference between the back and front interface states
#     interfaceDiff = forwInterfaceAvg - backInterfaceAvg
#     #Calculate a value that is proportional to the difference between the actual
#     #cell-centred variables and the average of the back and front interpolated states.
#     avgDiff = 6.0*(centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
#     #Apply monotonicity constraints
#     backInterfaceAvg[diffProd <= 0.0] = centPrimVars[diffProd <= 0.0]
#     forwInterfaceAvg[diffProd <= 0.0] = centPrimVars[diffProd <= 0.0]
#     backInterfaceAvg[(interfaceDiff*avgDiff) > np.square(interfaceDiff)] \
#         = ((6.0*centPrimVars - 4.0*forwInterfaceAvg) / 2.0)[
#         (interfaceDiff*avgDiff) > np.square(interfaceDiff)]
#     forwInterfaceAvg[(interfaceDiff*avgDiff) < (-1.0 * np.square(interfaceDiff))] \
#         = ((6.0*centPrimVars - 4.0*backInterfaceAvg) / 2.0)[
#         (interfaceDiff*avgDiff) < (-1.0*np.square(interfaceDiff))]
#     #Apply additional monotonicity constraints
#     backInterfaceAvg = np.maximum(np.minimum(centPrimVars, backPrimVars), backInterfaceAvg)
#     backInterfaceAvg = np.minimum(np.maximum(centPrimVars, backPrimVars), backInterfaceAvg)
#     forwInterfaceAvg = np.maximum(np.minimum(centPrimVars, forwPrimVars), forwInterfaceAvg)
#     forwInterfaceAvg = np.minimum(np.maximum(centPrimVars, forwPrimVars), forwInterfaceAvg)
#
#     #Calculate coefficients that will allow us to evolve our interpolated values
#     #by half a timestep
#     coeff1 = forwInterfaceAvg - backInterfaceAvg
#     coeff2 = 6.0*(centPrimVars - 0.5*(backInterfaceAvg + forwInterfaceAvg))
#     coeff3 = 0.5*np.maximum(np.max(eigenVals[4]),0.0)*dt/dz
#     coeff4 = -0.5*np.minimum(np.min(eigenVals[0]),0.0)*dt/dz
#
#     #Evolve the back interpolated state by half a timestep
#     backInterfaceAvg = backInterfaceAvg + coeff4*(coeff1 + (1.0 - (4.0/3.0)*coeff4)*coeff2)
#     #Evolve the forward interpolated state by half a timestep
#     forwInterfaceAvg = forwInterfaceAvg - coeff3*(coeff1 - (1.0 - (4.0/3.0)*coeff3)*coeff2)
#
#     #Our last calculation assumed that every wave reaches the cell interface in half a timestep.
#     #Using Athena's characteristic tracing formulas, we will now subtract all of the
#     #wave contributions that do not reach the interface in dt/2.
#
#     #Condense the eigenvalues and eigenmatricies (we don't need the ghost cells anymore)
#     leftEigenmatrix = leftEigenmatrix[:,:,:,:,1:leftEigenmatrix.shape[4]-1]
#     rightEigenmatrix = rightEigenmatrix[:,:,:,:,1:rightEigenmatrix.shape[4]-1]
#     eigenVals = eigenVals[:,:,:,1:eigenVals.shape[3]-1]
#
#     #We need to put coeff1 and coeff2 into the
#     #(density, vz, vx, vy, pressure) variable order,
#     #because we will use the left eigenmatrix
#     #to project them onto characteristic variables.
#     coeff1Copy = np.copy(coeff1)
#     coeff1[1] = coeff1Copy[3]
#     coeff1[2] = coeff1Copy[1]
#     coeff1[3] = coeff1Copy[2]
#     coeff2Copy = np.copy(coeff2)
#     coeff2[1] = coeff2Copy[3]
#     coeff2[2] = coeff2Copy[1]
#     coeff2[3] = coeff2Copy[2]
#
#     #Subtract invalid wave contributions from the back interpolated state.
#     for i in range(eigenVals.shape[0]):
#         backOvershootIndices = eigenVals[i] <= 0.0
#         backOvershootFactor = np.zeros(shape=backOvershootIndices.shape)
#         backOvershootVal1 = 0.5*(dt/dz)*eigenVals[0]
#         backOvershootVal2 = 0.5*(dt/dz)*eigenVals[i]
#         backOvershootVal3 = backOvershootVal1 - backOvershootVal2
#         backOvershootVal4 = (4.0/3.0)*(np.square(backOvershootVal1) - np.square(backOvershootVal2))
#         for j in range(eigenVals.shape[0]):
#             backOvershootFactor += backOvershootIndices*leftEigenmatrix[i,j,:] \
#                                     *(backOvershootVal3*(coeff1[j] + coeff2[j])
#                                        + backOvershootVal4*coeff2[j])
#         backOvershootCorr = np.zeros(shape=backInterfaceAvg.shape)
#         for j in range(eigenVals.shape[0]):
#             backOvershootCorr[j] = backOvershootFactor*rightEigenmatrix[j,i,:]
#         #Put the correction vector into the
#         #(density, vx, vy, vz, pressure)
#         #variable order
#         backOvershootCorrCopy = np.copy(backOvershootCorr)
#         backOvershootCorr[1] = backOvershootCorrCopy[2]
#         backOvershootCorr[2] = backOvershootCorrCopy[3]
#         backOvershootCorr[3] = backOvershootCorrCopy[1]
#         #Add the correction values to the back interpolated state
#         backInterfaceAvg += backOvershootCorr
#
#     #Subtract invalid wave contributions from the forward interpolated state.
#     for i in range(eigenVals.shape[0]):
#         forwOvershootIndices = eigenVals[i] >= 0.0
#         forwOvershootFactor = np.zeros(shape=forwOvershootIndices.shape)
#         forwOvershootVal1 = 0.5*(dt/dz)*eigenVals[4]
#         forwOvershootVal2 = 0.5*(dt/dz)*eigenVals[i]
#         forwOvershootVal3 = forwOvershootVal1 - forwOvershootVal2
#         forwOvershootVal4 = (4.0/3.0)*(np.square(forwOvershootVal1) - np.square(forwOvershootVal2))
#         for j in range(eigenVals.shape[0]):
#             forwOvershootFactor += forwOvershootIndices*leftEigenmatrix[i,j,:] \
#                                    *(forwOvershootVal3*(coeff1[j] - coeff2[j])
#                                       + forwOvershootVal4*coeff2[j])
#         forwOvershootCorr = np.zeros(shape=forwInterfaceAvg.shape)
#         for j in range(eigenVals.shape[0]):
#             forwOvershootCorr[j] = forwOvershootFactor*rightEigenmatrix[j,i,:]
#         #Put the correction vector into the
#         #(density, vx, vy, vz, pressure)
#         #variable order
#         forwOvershootCorrCopy = np.copy(forwOvershootCorr)
#         forwOvershootCorr[1] = forwOvershootCorrCopy[2]
#         forwOvershootCorr[2] = forwOvershootCorrCopy[3]
#         forwOvershootCorr[3] = forwOvershootCorrCopy[1]
#         #Add the correction values to the forward interpolated state
#         forwInterfaceAvg += forwOvershootCorr
#
#     #Lastly, we will apply our boundary conditions to obtain the back and forward PPM reconstructed
#     #states for every intercell boundary in the z-direction.
#     if BcZ == 0: #if the boundary condition is outflow
#         backPrimVarState = np.append(backInterfaceAvg[:,:,:,0].reshape(backInterfaceAvg.shape[0],
#                                                                        backInterfaceAvg.shape[1],-1,1),
#                                      forwInterfaceAvg,axis=3)
#         forwPrimVarState = np.append(backInterfaceAvg,
#                                      forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(
#                                                                            forwInterfaceAvg.shape[0],
#                                                                            forwInterfaceAvg.shape[1],-1,1),
#                                        axis=3)
#     else: #if the boundary condition is periodic
#         backPrimVarState = np.append(forwInterfaceAvg[:,:,:,forwInterfaceAvg.shape[3]-1].reshape(
#                                                                                         forwInterfaceAvg.shape[0],
#                                                                                         forwInterfaceAvg.shape[1],-1,1),
#                                      forwInterfaceAvg,axis=3)
#         forwPrimVarState = np.append(backInterfaceAvg,
#                                      backInterfaceAvg[:,:,:,0].reshape(backInterfaceAvg.shape[0],
#                                                                        backInterfaceAvg.shape[1],-1,1),
#                                      axis=3)
#
#     #Return the reconstructed top and bottom states
#     return backPrimVarState, forwPrimVarState
