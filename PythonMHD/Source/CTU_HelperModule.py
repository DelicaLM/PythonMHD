#CTU_HelperModule.py
#By Delica Leboe-McGowan, PhD Student, University of Manitoba
#Last Updated: January 1, 2024
#Purpose: Provides functions for calculating the half-timestep updates to the reconstructed
#         conservative variable states that are required for the MHD version of Colella's
#         Corner Transport Upwind (CTU) method [1].
#Additional Information: The functions in this script are designed to generate half-timestep
#                        corrections that are numerically identical (within ) to those
#                        generated by Athena [2]. The Athena methods paper (Stone et al., 2008) [3]
#                        provides the formulas that allow us to evolve the reconstructed MHD
#                        states in 2D and 3D by half a timestep.
#                        2D Half-Timestep Update Formulas
#                        X-Direction
#                         _ _ __G_j-1/2,i-1,k _ _ _ _ _ _G_j-1/2,i,k _ _ _
#                        |                       |                       |
#                        |                       |                       |
#                        |         S_i-1      U_L|U_R       S_i          |
#                        |                       |                       |
#                        |                       |                       |
#                        | _ _ _G_j+1/2,i-1,k_ _ | _ _ _G_j+1/2,i,k _ _ _|
#                        G_j-1/2,i-1,k = upper-left y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i-1,k = lower-left y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j-1/2,i,k = upper-right y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i,k = lower-right y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        S_i-1 = left source vector = [0,
#                                                      0.5*dt*Bx_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0.5*dt*By_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0.5*dt*Bz_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0,
#                                                      0.5*dt*Vz_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0.5*dt*Bz_(j,i-1,k)*Vz_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx]
#                        S_i = right source vector = [0,
#                                                     0.5*dt*Bx_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                     0.5*dt*By_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                     0.5*dt*Bz_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                     0,
#                                                     0.5*dt*Vz_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                     0.5*dt*Bz_(j,i,k)*Vz_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx]
#                        Formulas:
#                        Left Conservative Variables: U_L_(j,i-1/2,k) += -0.5*(dt/dy)*(G_j+1/2,i-1,k - G_j-1/2,i-1,k)
#                                                                        + S_(j,i-1,k)
#                        Right Conservative Variables: U_R_(j,i-1/2,k) += -0.5*(dt/dy)*(G_j+1/2,i,k - G_j-1/2,i,k)
#                                                                         + S_(j,i,k)
#                        Y-Direction
#                         _ _ _ _ _ _ _ _ _ _ _ _
#                        |                       |
#                        |                       |
#                        |                       |
#                   F_j-1,i-1/2,k   S_j-1    F_j-1,i+1/2,k
#                        |                       |
#                        |                       |
#                        |     U_T_(j-1/2,i,k)   |
#                        |- - - - - - - - - - - -|
#                        |     U_B_(j-1/2,i,k)   |
#                        |                       |
#                        |                       |
#                   F_j,i-1/2,k     S_j      F_j,i+1/2,k
#                        |                       |
#                        |                       |
#                        |_ _ _ _ _ _ _ _ _ _ _ _|
#                        F_j-1,i-1/2,k = upper-left x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j-1,i+1/2,k = upper-right x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i-1/2,k = lower-left x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i+1/2,k = lower-right x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        S_j-1 = top source vector = [0,
#                                                     0.5*dt*Bx_(j,i-1,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0.5*dt*By_(j,i-1,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0.5*dt*Bz_(j,i-1,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0.5*dt*Vz_(j,i-1,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0,
#                                                     0.5*dt*Bz_(j,i-1,k)*Vz_(j,i-1,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy]
#                        S_j = bottom source vector = [0,
#                                                      0.5*dt*Bx_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0.5*dt*By_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0.5*dt*Bz_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0.5*dt*Vz_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0,
#                                                      0.5*dt*Bz_(j,i,k)*Vz_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy]
#                        Formulas:
#                        Top Conservative Variables: U_T_(j-1/2,i,k) += -0.5*(dt/dx)*(F_j-1,i+1/2,k - F_j-1,i-1/2,k)
#                                                                       + S_(j-1,i,k)
#                        Bottom Conservative Variables: U_B_(j-1/2,i,k) += -0.5*(dt/dx)*(F_j,i+1/2,k - F_j,i-1/2,k)
#                                                                       + S_(j,i,k)
#                        3D Half-Timestep Update Formulas
#                        [Visualizations are not provided for the 3D updates because it is difficult to clearly
#                         present all six sides of the cell in this format. Instead, please refer to PythonMHD's
#                         user guide if you would like to see visualizations of the 3D CTU updates.]
#                        X-Direction
#                        G_j-1/2,i-1,k = upper-left y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i-1,k = lower-left y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j-1/2,i,k = upper-right y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i,k = lower-right y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        H_j,i-1,k-1/2 = back-left z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j,i-1,k+1/2 = forward-left z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j,i,k-1/2 = back-right z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j,i,k+1/2 = forward-right z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        S_i-1 = left source vector = [0,
#                                                      0.5*dt*Bx_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0.5*dt*By_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      0.5*dt*Bz_(j,i-1,k)*(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx,
#                                                      -0.5*dt*Vy_(j,i-1,k)*minmod(Bz_(j,i-1,k+1/2)-Bz_(j,i-1,k-1/2))/dz,
#                                                                                  -(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx),
#                                                      -0.5*dt*Vz_(j,i-1,k)*minmod(By_(j+1/2,i-1,k)-By_(j-1/2,i-1,k))/dy,
#                                                                                  -(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx),
#                                                      -0.5*dt*By_(j,i-1,k)*Vy_(j,i-1,k)*minmod(Bz_(j,i-1,k+1/2)-Bz_(j,i-1,k-1/2))/dz,
#                                                                                               -(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx)
#                                                      -0.5*dt*Bz_(j,i-1,k)*Vz_(j,i-1,k)*minmod(By_(j+1/2,i-1,k)-By_(j-1/2,i-1,k))/dy,
#                                                                                               -(Bx_(j,i-1/2,k)-Bx_(j,i-3/2,k))/dx)]
#                        S_i = left source vector = [0,
#                                                      0.5*dt*Bx_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                      0.5*dt*By_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                      0.5*dt*Bz_(j,i,k)*(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                      -0.5*dt*Vy_(j,i,k)*minmod(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                                                -(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx),
#                                                      -0.5*dt*Vz_(j,i,k)*minmod(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy),
#                                                                                -(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx),
#                                                      -0.5*dt*By_(j,i,k)*Vy_(j,i,k)*minmod(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                                                               -(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx)
#                                                      -0.5*dt*Bz_(j,i,k)*Vz_(j,i,k)*minmod(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                                                           -(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx]
#                        E_i-1 = EMF source vector = [0,
#                                                     0,
#                                                     0,
#                                                     0,
#                                                     -0.25*(dt/dz)*(emf_x_(j-1/2,i-3/2,k+1/2) - emf_x_(j-1/2,i-3/2,k-1/2)
#                                                                    + emf_x_(j+1/2,i-3/2,k+1/2) - emf_x_(j+1/2,i-3/2,k-1/2)),
#                                                     0.25*(dt/dy)*(emf_x_(j+1/2,i-3/2,k-1/2) - emf_x_(j-1/2,i-3/2,k-1/2)
#                                                                   + emf_x_(j+1/2,i-3/2,k+1/2) - emf_x_(j-1/2,i-3/2,k+1/2)),
#                                                     0]
#                        E_i = EMF source vector = [0,
#                                                   0,
#                                                   0,
#                                                   0,
#                                                  -0.25*(dt/dz)*(emf_x_(j-1/2,i-1/2,k+1/2) - emf_x_(j-1/2,i-1/2,k-1/2)
#                                                                 + emf_x_(j+1/2,i-1/2,k+1/2) - emf_x_(j+1/2,i-1/2,k-1/2)),
#                                                   0.25*(dt/dy)*(emf_x_(j+1/2,i-1/2,k-1/2) - emf_x_(j-1/2,i-1/2,k-1/2)
#                                                                 + emf_x_(j+1/2,i-1/2,k+1/2) - emf_x_(j-1/2,i-1/2,k+1/2)),
#                                                   0]
#                        Left Conservative Variables: U_L_(j,i-1/2,k) += -0.5*(dt/dy)*(G_j+1/2,i-1,k - G_j-1/2,i-1,k)
#                                                                        -0.5*(dt/dz)*(H_j,i-1,k+1/2 - H_j,i-1,k-1/2)
#                                                                        + S_(j,i-1,k) + E_(j,i-1,k)
#                        Right Conservative Variables: U_R_(j,i-1/2,k) += -0.5*(dt/dy)*(G_j+1/2,i,k - G_j-1/2,i,k)
#                                                                        -0.5*(dt/dz)*(H_j,i,k+1/2 - H_j,i,k-1/2)
#                                                                         + S_(j,i,k) + E_(j,i,k)
#
#                        Y-Direction
#                        F_j-1,i-1/2,k = upper-left x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j-1,i+1/2,k = upper-right x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i-1/2,k = lower-left x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i+1/2,k = lower-right x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        H_j-1,i,k-1/2 = upper-back z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j-1,i,k+1/2 = upper-forward z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j,i,k-1/2 = upper-back z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        H_j,i,k+1/2 = upper-forward z-direction intercell flux (with Bx and By fluxes set to zero!!!)
#                        S_j-1 = top source vector = [0,
#                                                     0.5*dt*Bx_(j-1,i,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0.5*dt*By_(j-1,i,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     0.5*dt*Bz_(j-1,i,k)*(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy,
#                                                     -0.5*dt*Vz_(j-1,i,k)*minmod(Bx_(j-1,i+1/2,k)-Bx_(j-1,i-1/2,k))/dx,
#                                                                                 -(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy),
#                                                     -0.5*dt*Vx_(j-1,i,k)*minmod(Bz_(j-1,i,k+1/2)-Bz_(j-1,i,k-1/2))/dz,
#                                                                                 -(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy),
#                                                     -0.5*dt*Bz_(j-1,i,k)*Vz_(j-1,i,k)*minmod(Bx_(j-1,i+1/2,k)-Bx_(j-1,i-1/2,k))/dx,
#                                                                                              -(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy)
#                                                     -0.5*dt*Bx_(j-1,i,k)*Vx_(j-1,i,k)*minmod(Bz_(j-1,i,k+1/2)-Bz_(j-1,i,k-1/2))/dz,
#                                                                                              -(By_(j-1/2,i,k)-By_(j-3/2,i,k))/dy)]
#                        S_j = bottom source vector = [0,
#                                                      0.5*dt*Bx_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0.5*dt*By_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      0.5*dt*Bz_(j,i,k)*(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                      -0.5*dt*Vz_(j,i,k)*minmod(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                                                 -(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy),
#                                                      -0.5*dt*Vx_(j,i,k)*minmod(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                                                 -(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy),
#                                                      -0.5*dt*Bz_(j,i,k)*Vz_(j,i,k)*minmod(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                                                              -(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy)
#                                                      -0.5*dt*Bx_(j,i,k)*Vx_(j,i,k)*minmod(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                                                              -(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy)]
#                        E_j-1 = EMF source vector = [0,
#                                                   0,
#                                                   0,
#                                                   0,
#                                                   -0.25*(dt/dx)*(emf_y_(j-3/2,i+1/2,k-1/2) - emf_y_(j-3/2,i-1/2,k-1/2)
#                                                                  + emf_y_(j-3/2,i+1/2,k+1/2) - emf_y_(j-3/2,i-1/2,k+1/2)),
#                                                   0.25*(dt/dz)*(emf_y_(j-3/2,i-1/2,k+1/2) - emf_y_(j-3/2,i-1/2,k-1/2)
#                                                                 + emf_y_(j-3/2,i+1/2,k+1/2) - emf_y_(j-3/2,i+1/2,k-1/2)),
#                                                   0]
#                        E_j = EMF source vector = [0,
#                                                   0,
#                                                   0,
#                                                   0,
#                                                   -0.25*(dt/dx)*(emf_y_(j-1/2,i+1/2,k-1/2) - emf_y_(j-1/2,i-1/2,k-1/2)
#                                                                  + emf_y_(j-1/2,i+1/2,k+1/2) - emf_y_(j-1/2,i-1/2,k+1/2)),
#                                                   0.25*(dt/dz)*(emf_y_(j-1/2,i-1/2,k+1/2) - emf_y_(j-1/2,i-1/2,k-1/2)
#                                                                 + emf_y_(j-1/2,i+1/2,k+1/2) - emf_y_(j-1/2,i+1/2,k-1/2)),
#                                                   0]
#                        Formulas:
#                        Top Conservative Variables: U_T_(j-1/2,i,k) += -0.5*(dt/dx)*(F_j-1,i+1/2,k - F_j-1,i-1/2,k)
#                                                                       -0.5*(dt/dz)*(H_j-1,i,k+1/2 - H_j-1,i,k-1/2)
#                                                                       + S_(j-1,i,k) + E_(j-1,i,k)
#                        Bottom Conservative Variables: U_B_(j-1/2,i,k) += -0.5*(dt/dx)*(F_j,i+1/2,k - F_j,i-1/2,k)
#                                                                          -0.5*(dt/dz)*(H_j-1,i,k+1/2 - H_j-1,i,k-1/2)
#                                                                          + S_(j,i,k) + E_(j,i,k)
#
#                        Z-Direction
#                        G_j-1/2,i,k-1 = upper-back y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i,k-1 = lower-back y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j-1/2,i,k = upper-forward y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        G_j+1/2,i,k = lower-forward y-direction intercell flux (with Bz and Bx fluxes set to zero!!!)
#                        F_j,i-1/2,k-1 = left-back x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i+1/2,k-1 = right-back x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i-1/2,k = left-forward x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        F_j,i+1/2,k = right-forward x-direction intercell flux (with By and Bz fluxes set to zero!!!)
#                        S_k-1 = back source vector = [0,
#                                                      0.5*dt*Bx_(j,i,k-1)*(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz,
#                                                      0.5*dt*By_(j,i,k-1)*(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz,
#                                                      0.5*dt*Bz_(j,i,k-1)*(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz,
#                                                      -0.5*dt*Vx_(j,i,k-1)*minmod(By_(j+1/2,i,k-1)-By_(j-1/2,i,k-1))/dy,
#                                                                                  -(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz),
#                                                      -0.5*dt*Vy_(j,i,k-1)*minmod(Bx_(j,i+1/2,k-1)-Bx_(j,i-1/2,k-1))/dx,
#                                                                                  -(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz),
#                                                      -0.5*dt*Bx_(j,i,k-1)*Vx_(j,i,k-1)*minmod(By_(j+1/2,i,k-1)-By_(j-1/2,i,k-1))/dy,
#                                                                                               -(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz)
#                                                      -0.5*dt*By_(j,i,k-1)*Vy_(j,i,k-1)*minmod(Bx_(j,i+1/2,k-1)-Bx_(j,i-1/2,k-1))/dx,
#                                                                                              -(Bz_(j,i,k-1/2)-Bz_(j,i,k-3/2))/dz)]
#                        S_k = forward source vector = [0,
#                                                       0.5*dt*Bx_(j,i,k)*(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                       0.5*dt*By_(j,i,k)*(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                       0.5*dt*Bz_(j,i,k)*(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz,
#                                                       -0.5*dt*Vx_(j,i,k)*minmod(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                                                 -(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz),
#                                                       -0.5*dt*Vy_(j,i,k)*minmod(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                                                 -(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz),
#                                                       -0.5*dt*Bx_(j,i,k)*Vx_(j,i,k)*minmod(By_(j+1/2,i,k)-By_(j-1/2,i,k))/dy,
#                                                                                            -(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz)
#                                                       -0.5*dt*By_(j,i,k)*Vy_(j,i,k)*minmod(Bx_(j,i+1/2,k)-Bx_(j,i-1/2,k))/dx,
#                                                                                            -(Bz_(j,i,k+1/2)-Bz_(j,i,k-1/2))/dz)]
#                        E_i-1 = EMF source vector = [0,
#                                                     0,
#                                                     0,
#                                                     0,
#                                                     -0.25*(dt/dy)*(emf_z_(j+1/2,i-1/2,k-3/2) - emf_z_(j-1/2,i-1/2,k-3/2)
#                                                                    + emf_z_(j+1/2,i+1/2,k-3/2) - emf_z_(j-1/2,i+1/2,k-3/2)),
#                                                     0.25*(dt/dx)*(emf_z_(j-1/2,i+1/2,k-3/2) - emf_z_(j-1/2,i-1/2,k-3/2)
#                                                                   + emf_z_(j+1/2,i+1/2,k-3/2) - emf_z_(j+1/2,i-1/2,k-3/2)),
#                                                     0]
#                        E_i = EMF source vector = [0,
#                                                   0,
#                                                   0,
#                                                   0,
#                                                  -0.25*(dt/dy)*(emf_z_(j+1/2,i-1/2,k-1/2) - emf_z_(j-1/2,i-1/2,k-1/2)
#                                                                 + emf_z_(j+1/2,i+1/2,k-1/2) - emf_z_(j-1/2,i+1/2,k-1/2)),
#                                                   0.25*(dt/dx)*(emf_z_(j-1/2,i+1/2,k-1/2) - emf_z_(j-1/2,i-1/2,k-1/2)
#                                                                  + emf_z_(j+1/2,i+1/2,k-1/2) - emf_z_(j+1/2,i-1/2,k-1/2)),
#                                                   0]
#                        Back Conservative Variables: U_B_(j,i,k-1/2) += -0.5*(dt/dx)*(F_j,i+1/2,i,k-1 - F_j,i-1/2,k-1)
#                                                                        -0.5*(dt/dy)*(G_j+1/2,i,k-1 - G_j-1/2,i,k-1)
#                                                                        + S_(j,i,k-1) + E_(j,i,k-1)
#                        Forward Conservative Variables: U_F_(j,i,k-1/2) += -0.5*(dt/dx)*(F_j,i+1/2,i,k - F_j,i-1/2,k)
#                                                                           -0.5*(dt/dy)*(G_j+1/2,i,k - G_j-1/2,i,k)
#                                                                           + S_(j,i,k) + E_(j,i,k)
#
#References:
# 1. Colella, P. (1990). Multidimensional upwind methods for hyperbolic conservation laws. Journal
#    of Computational Physics, 87(1), 171-200. https://doi.org/10.1016/0021-9991(90)90233-Q.
# 2. https://github.com/PrincetonUniversity/Athena-Cversion
# 3. Stone, J. M., Gardiner, T. A., Teuben, P., Hawley, J. F., & Simon, J. B. (2008).
#    Athena: A new code for astrophysical MHD. The Astrophysical Journal Supplemental Series,
#    178(1), 137-177. https://iopscience.iop.org/article/10.1086/588755/pdf.

#####IMPORT STATEMENTS######
#Import NumPy for matrix operations
import numpy as np

#Import PythonMHD constants
import Source.PythonMHD_Constants as constants

#Function:
#Purpose:
#Input Parameters:
#Outputs:
def getXTransverseUpdates_2D(primVarsX,primVarsY,intercellFluxY,faceBx,dt,dx,dy,BcX):
    invDx = 1.0/dx
    dtdy = dt/dy
    halfDtDy = 0.5*dtdy
    halfDt = 0.5*dt
    centBx = primVarsY[5]
    centBy = primVarsX[4]
    centBz = primVarsX[5]
    centVz = primVarsX[3]
    topIntercellFlux = intercellFluxY[:,0:intercellFluxY.shape[1]-1,:]
    bottomIntercellFlux = intercellFluxY[:,1:intercellFluxY.shape[1],:]
    if BcX == constants.OUTFLOW:
        leftBx = np.append(faceBx[:,0].reshape(-1,1),faceBx,axis=1)
        rightBx = np.append(faceBx,faceBx[:,faceBx.shape[1]-1].reshape(-1,1),axis=1)
        centBx = np.append(centBx[:,0].reshape(-1,1),centBx,axis=1)
        centBx = np.append(centBx,centBx[:,centBx.shape[1]-1].reshape(-1,1),axis=1)
        centBy = np.append(centBy[:,0].reshape(-1,1),centBy,axis=1)
        centBy = np.append(centBy,centBy[:,centBy.shape[1]-1].reshape(-1,1),axis=1)
        centBz = np.append(centBz[:,0].reshape(-1,1),centBz,axis=1)
        centBz = np.append(centBz,centBz[:,centBz.shape[1]-1].reshape(-1,1),axis=1)
        centVz = np.append(centVz[:,0].reshape(-1,1),centVz,axis=1)
        centVz = np.append(centVz,centVz[:,centVz.shape[1]-1].reshape(-1,1),axis=1)
        topIntercellFlux_forLeft = np.append(topIntercellFlux[:,:,0].reshape(7,-1,1),
                                             topIntercellFlux,axis=2)
        bottomIntercellFlux_forLeft = np.append(bottomIntercellFlux[:,:,0].reshape(7,-1,1),
                                                bottomIntercellFlux,axis=2)
        topIntercellFlux_forRight = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,topIntercellFlux.shape[2]-1].reshape(7,-1,1),
                                              axis=2)
        bottomIntercellFlux_forRight = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,bottomIntercellFlux.shape[2]-1].reshape(7,-1,1),
                                                 axis=2)
    else:
        leftBx = np.append(faceBx[:,faceBx.shape[1]-2].reshape(-1,1),faceBx,axis=1)
        rightBx = np.append(faceBx,faceBx[:,1].reshape(-1,1),axis=1)
        centBx = np.append(centBx[:,centBx.shape[1]-1].reshape(-1,1),centBx,axis=1)
        centBx = np.append(centBx,centBx[:,1].reshape(-1,1),axis=1)
        centBy = np.append(centBy[:,centBy.shape[1]-1].reshape(-1,1),centBy,axis=1)
        centBy = np.append(centBy,centBy[:,1].reshape(-1,1),axis=1)
        centBz = np.append(centBz[:,centBz.shape[1]-1].reshape(-1,1),centBz,axis=1)
        centBz = np.append(centBz,centBz[:,1].reshape(-1,1),axis=1)
        centVz = np.append(centVz[:,centVz.shape[1]-1].reshape(-1,1),centVz,axis=1)
        centVz = np.append(centVz,centVz[:,1].reshape(-1,1),axis=1)
        topIntercellFlux_forLeft = np.append(topIntercellFlux[:,:,topIntercellFlux.shape[2]-1].reshape(7,-1,1),
                                             topIntercellFlux,axis=2)
        bottomIntercellFlux_forLeft = np.append(bottomIntercellFlux[:,:,bottomIntercellFlux.shape[2]-1].reshape(7,-1,1),
                                                bottomIntercellFlux,axis=2)
        topIntercellFlux_forRight = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,0].reshape(7,-1,1),axis=2)
        bottomIntercellFlux_forRight = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,0].reshape(7,-1,1),axis=2)
    topIntercellFlux_forLeft[5] = topIntercellFlux_forLeft[4]
    topIntercellFlux_forLeft[4] = 0.0
    topIntercellFlux_forRight[5] = topIntercellFlux_forRight[4]
    topIntercellFlux_forRight[4] = 0.0
    bottomIntercellFlux_forLeft[5] = bottomIntercellFlux_forLeft[4]
    bottomIntercellFlux_forLeft[4] = 0.0
    bottomIntercellFlux_forRight[5] = bottomIntercellFlux_forRight[4]
    bottomIntercellFlux_forRight[4] = 0.0
    horizSourceTermVx = centBx*(rightBx-leftBx)*invDx
    horizSourceTermVy = centBy*(rightBx-leftBx)*invDx
    horizSourceTermVz = centBz*(rightBx-leftBx)*invDx
    horizSourceTermE = centBz*centVz*(rightBx-leftBx)*invDx
    horizSourceTermBz = centVz*(rightBx-leftBx)*invDx
    sourceVector = np.array([np.zeros(shape=(primVarsX.shape[1],primVarsX.shape[2]+2)),
                            horizSourceTermVx,
                            horizSourceTermVy,
                            horizSourceTermVz,
                            np.zeros(shape=(primVarsX.shape[1],primVarsX.shape[2]+2)),
                            horizSourceTermBz,
                            horizSourceTermE])
    leftSourceVector = sourceVector[:,:,0:sourceVector.shape[2]-1]
    rightSourceVector = sourceVector[:,:,1:sourceVector.shape[2]]
    transverseCorrections = np.zeros(shape=(2,7,primVarsX.shape[1],primVarsX.shape[2]+1))
    transverseCorrections[0] = -halfDtDy*(bottomIntercellFlux_forLeft - topIntercellFlux_forLeft) \
                               + halfDt*leftSourceVector
    transverseCorrections[1] = -halfDtDy*(bottomIntercellFlux_forRight - topIntercellFlux_forRight) \
                               + halfDt*rightSourceVector
    return transverseCorrections

#Function:
#Purpose:
#Input Parameters:
#Outputs:
def getYTransverseUpdates_2D(primVarsX,primVarsY,intercellFluxX,faceBy,dt,dx,dy,BcY):
    invDy = 1.0/dy
    dtdx = dt/dx
    halfDtDx = 0.5*dtdx
    halfDt = 0.5*dt
    centBx = primVarsY[5]
    centBy = primVarsX[4]
    centBz = primVarsX[5]
    centVz = primVarsX[3]
    leftIntercellFlux = intercellFluxX[:,:,0:intercellFluxX.shape[2]-1]
    rightIntercellFlux = intercellFluxX[:,:,1:intercellFluxX.shape[2]]
    if BcY == constants.OUTFLOW:
        topBy = np.append(faceBy[1,:].reshape(1,-1),faceBy,axis=0)
        bottomBy = np.append(faceBy,faceBy[faceBy.shape[0]-2,:].reshape(1,-1),axis=0)
        centBx = np.append(centBx[1,:].reshape(1,-1),centBx,axis=0)
        centBx = np.append(centBx,centBx[centBx.shape[0]-1,:].reshape(1,-1),axis=0)
        centBy = np.append(centBy[1,:].reshape(1,-1),centBy,axis=0)
        centBy = np.append(centBy,centBy[centBy.shape[0]-1,:].reshape(1,-1),axis=0)
        centBz = np.append(centBz[1,:].reshape(1,-1),centBz,axis=0)
        centBz = np.append(centBz,centBz[centBz.shape[0]-1,:].reshape(1,-1),axis=0)
        centVz = np.append(centVz[1,:].reshape(1,-1),centVz,axis=0)
        centVz = np.append(centVz,centVz[centVz.shape[0]-1,:].reshape(1,-1),axis=0)
        leftIntercellFlux_forTop = np.append(leftIntercellFlux[:,0,:].reshape(7,1,-1),
                                             leftIntercellFlux,axis=1)
        rightIntercellFlux_forTop = np.append(rightIntercellFlux[:,0,:].reshape(7,1,-1),
                                                rightIntercellFlux,axis=1)
        leftIntercellFlux_forBottom = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,leftIntercellFlux.shape[1]-1,:].reshape(7,1,-1),
                                              axis=1)
        rightIntercellFlux_forBottom = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,rightIntercellFlux.shape[1]-1,:].reshape(7,1,-1),
                                                 axis=1)
    else:
        topBy = np.append(faceBy[faceBy.shape[0]-2,:].reshape(1,-1),faceBy,axis=0)
        bottomBy = np.append(faceBy,faceBy[1,:].reshape(1,-1),axis=0)
        centBx = np.append(centBx[centBx.shape[0]-1,:].reshape(1,-1),centBx,axis=0)
        centBx = np.append(centBx,centBx[1,:].reshape(1,-1),axis=0)
        centBy = np.append(centBy[centBy.shape[0]-1,:].reshape(1,-1),centBy,axis=0)
        centBy = np.append(centBy,centBy[1,:].reshape(1,-1),axis=0)
        centBz = np.append(centBz[centBz.shape[0]-1,:].reshape(1,-1),centBz,axis=0)
        centBz = np.append(centBz,centBz[1,:].reshape(1,-1),axis=0)
        centVz = np.append(centVz[centVz.shape[0]-1,:].reshape(1,-1),centVz,axis=0)
        centVz = np.append(centVz,centVz[1,:].reshape(1,-1),axis=0)
        leftIntercellFlux_forTop = np.append(leftIntercellFlux[:,leftIntercellFlux.shape[1]-1,:].reshape(7,1,-1),
                                             leftIntercellFlux,axis=1)
        rightIntercellFlux_forTop = np.append(rightIntercellFlux[:,rightIntercellFlux.shape[1]-1,:].reshape(7,1,-1),
                                                rightIntercellFlux,axis=1)
        leftIntercellFlux_forBottom = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,0,:].reshape(7,1,-1),axis=1)
        rightIntercellFlux_forBottom = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,0,:].reshape(7,1,-1),axis=1)
    leftIntercellFlux_forTop[4] = leftIntercellFlux_forTop[5]
    leftIntercellFlux_forTop[5] = 0.0
    leftIntercellFlux_forBottom[4] = leftIntercellFlux_forBottom[5]
    leftIntercellFlux_forBottom[5] = 0.0
    rightIntercellFlux_forTop[4] = rightIntercellFlux_forTop[5]
    rightIntercellFlux_forTop[5] = 0.0
    rightIntercellFlux_forBottom[4] = rightIntercellFlux_forBottom[5]
    rightIntercellFlux_forBottom[5] = 0.0
    vertSourceTermVx = centBx*(bottomBy-topBy)*invDy
    vertSourceTermVy = centBy*(bottomBy-topBy)*invDy
    vertSourceTermVz = centBz*(bottomBy-topBy)*invDy
    vertSourceTermE = (centBz*centVz)*(bottomBy-topBy)*invDy
    vertSourceTermBz = centVz*(bottomBy-topBy)*invDy
    sourceVector = np.array([np.zeros(shape=(primVarsY.shape[1]+2,primVarsY.shape[2])),
                            vertSourceTermVx,
                            vertSourceTermVy,
                            vertSourceTermVz,
                            vertSourceTermBz,
                            np.zeros(shape=(primVarsY.shape[1]+2,primVarsY.shape[2])),
                            vertSourceTermE])
    topSourceVector = sourceVector[:,0:sourceVector.shape[1]-1,:]
    bottomSourceVector = sourceVector[:,1:sourceVector.shape[1],:]
    transverseCorrections = np.zeros(shape=(2,7,primVarsX.shape[1]+1,primVarsX.shape[2]))
    transverseCorrections[0] = -halfDtDx*(rightIntercellFlux_forTop - leftIntercellFlux_forTop) \
                               + halfDt*topSourceVector
    transverseCorrections[1] = -halfDtDx*(rightIntercellFlux_forBottom - leftIntercellFlux_forBottom) \
                               + halfDt*bottomSourceVector
    return transverseCorrections


#Function:
#Purpose:
#Input Parameters:
#Outputs:
def getXTransverseUpdates_3D(leftConsVars,rightConsVars,primVarsX,primVarsY,intercellFluxY,intercellFluxZ,faceBx,faceBy,faceBz,cornerEMF_x,dt,dx,dy,dz,BcX):
    newLeftConsVars = np.copy(leftConsVars)
    newRightConsVars = np.copy(rightConsVars)
    transverseCorrections = np.zeros(shape=(2, 7, primVarsX.shape[1], primVarsX.shape[2] + 1, primVarsX.shape[3]))
    dtdy = np.longdouble(dt)/np.longdouble(dy)
    halfDtDy = 0.5*dtdy
    dtdz = dt/dz
    halfDtDz = 0.5*dtdz
    halfDt = 0.5*dt
    invDx = 1.0/dx
    invDy = 1.0/dy
    invDz = 1.0/dz
    centBx = primVarsY[5]
    centBy = primVarsX[4]
    centBz = primVarsX[5]
    centVy = primVarsX[2]
    centVz = primVarsX[3]
    topIntercellFlux = intercellFluxY[:,0:intercellFluxY.shape[1]-1,:]
    bottomIntercellFlux = intercellFluxY[:,1:intercellFluxY.shape[1],:]
    backIntercellFlux = intercellFluxZ[:,:,:,0:intercellFluxZ.shape[3]-1]
    forwIntercellFlux = intercellFluxZ[:,:,:,1:intercellFluxZ.shape[3]]
    topBy = faceBy[0:faceBy.shape[0]-1,:,:]
    bottomBy = faceBy[1:faceBy.shape[0],:,:]
    backBz = faceBz[:,:,0:faceBz.shape[2]-1]
    forwBz = faceBz[:,:,1:faceBz.shape[2]]
    if BcX == constants.OUTFLOW:
        leftBx = np.append(faceBx[:,0,:].reshape(faceBx.shape[0],1,-1),
                                   faceBx[:,0:faceBx.shape[1],:],axis=1)
        rightBx = np.append(faceBx[:,0:faceBx.shape[1],:],
                                     faceBx[:,faceBx.shape[1]-1,:].reshape(faceBx.shape[0],1,-1),
                                     axis=1)
        topBy = np.append(topBy[:,0,:].reshape(topBy.shape[0],1,-1),
                                  topBy[:,0:topBy.shape[1],:],axis=1)
        topBy = np.append(topBy,
                                   topBy[:,topBy.shape[1]-1,:].reshape(topBy.shape[0],1,-1),axis=1)
        bottomBy = np.append(bottomBy[:,0,:].reshape(bottomBy.shape[0],1,-1),
                                     bottomBy[:,0:bottomBy.shape[1],:],axis=1)
        bottomBy = np.append(bottomBy,
                                   bottomBy[:,bottomBy.shape[1]-1,:].reshape(bottomBy.shape[0],1,-1),axis=1)
        backBz = np.append(backBz[:,0,:].reshape(backBz.shape[0],1,-1),
                                  backBz[:,0:backBz.shape[1],:],axis=1)
        backBz = np.append(backBz,
                                   backBz[:,backBz.shape[1]-1,:].reshape(backBz.shape[0],1,-1),axis=1)
        forwBz = np.append(forwBz[:,0,:].reshape(forwBz.shape[0],1,-1),
                                  forwBz[:,0:forwBz.shape[1],:],axis=1)
        forwBz = np.append(forwBz,
                                   forwBz[:,forwBz.shape[1]-1,:].reshape(forwBz.shape[0],1,-1),axis=1)
        centBx = np.append(centBx[:,0,:].reshape(centBx.shape[0],1,-1),centBx,axis=1)
        centBx = np.append(centBx,centBx[:,centBx.shape[1]-1,:].reshape(centBx.shape[0],1,-1),axis=1)
        centBy = np.append(centBy[:,0,:].reshape(centBy.shape[0],1,-1),centBy,axis=1)
        centBy = np.append(centBy,centBy[:,centBy.shape[1]-1,:].reshape(centBy.shape[0],1,-1),axis=1)
        centBz = np.append(centBz[:,0,:].reshape(centBz.shape[0],1,-1),centBz,axis=1)
        centBz = np.append(centBz,centBz[:,centBz.shape[1]-1,:].reshape(centBz.shape[0],1,-1),axis=1)
        centVy = np.append(centVy[:,0,:].reshape(centVy.shape[0],1,-1),centVy,axis=1)
        centVy = np.append(centVy,centVy[:,centVy.shape[1]-1,:].reshape(centVy.shape[0],1,-1),axis=1)
        centVz = np.append(centVz[:,0,:].reshape(centVz.shape[0],1,-1),centVz,axis=1)
        centVz = np.append(centVz,centVz[:,centVz.shape[1]-1,:].reshape(centVz.shape[0],1,-1),axis=1)
        topIntercellFlux_forLeft = np.append(topIntercellFlux[:,:,0,:].reshape(7,topIntercellFlux.shape[1],1,-1),
                                             topIntercellFlux,axis=2)
        bottomIntercellFlux_forLeft = np.append(bottomIntercellFlux[:,:,0,:].reshape(7,bottomIntercellFlux.shape[1],1,-1),
                                                bottomIntercellFlux,axis=2)
        topIntercellFlux_forRight = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,topIntercellFlux.shape[2]-1,:].reshape(7,topIntercellFlux.shape[1],1,-1),
                                              axis=2)
        bottomIntercellFlux_forRight = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,bottomIntercellFlux.shape[2]-1,:].reshape(7,bottomIntercellFlux.shape[1],1,-1),
                                                 axis=2)
        backIntercellFlux_forLeft = np.append(backIntercellFlux[:,:,0,:].reshape(7,backIntercellFlux.shape[1],1,-1),
                                             backIntercellFlux,axis=2)
        forwIntercellFlux_forLeft = np.append(forwIntercellFlux[:,:,0,:].reshape(7,forwIntercellFlux.shape[1],1,-1),
                                                forwIntercellFlux,axis=2)
        backIntercellFlux_forRight = np.append(backIntercellFlux,
                                              backIntercellFlux[:,:,backIntercellFlux.shape[2]-1,:].reshape(7,backIntercellFlux.shape[1],1,-1),
                                              axis=2)
        forwIntercellFlux_forRight = np.append(forwIntercellFlux,
                                                 forwIntercellFlux[:,:,forwIntercellFlux.shape[2]-1,:].reshape(7,forwIntercellFlux.shape[1],1,-1),
                                                 axis=2)
        leftCornerEMF_x = np.append(cornerEMF_x[:,0,:].reshape(-1,1,cornerEMF_x.shape[2]),
                                    cornerEMF_x[:,0:cornerEMF_x.shape[1]-1,:],axis=1)
    else:
        leftBx = np.append(faceBx[:,faceBx.shape[1]-2,:].reshape(faceBx.shape[0],1,-1),
                                   faceBx[:,0:faceBx.shape[1]],axis=1)
        rightBx = np.append(faceBx,
                             faceBx[:,1,:].reshape(faceBx.shape[0],1,-1),
                             axis=1)
        topBy = np.append(topBy[:,topBy.shape[1]-1,:].reshape(topBy.shape[0],1,-1),
                                  topBy[:,0:topBy.shape[1],:],axis=1)
        topBy = np.append(topBy,topBy[:,1,:].reshape(topBy.shape[0],1,-1),axis=1)
        bottomBy = np.append(bottomBy[:,bottomBy.shape[1]-1,:].reshape(bottomBy.shape[0],1,-1),
                                     bottomBy[:,0:bottomBy.shape[1],:],axis=1)
        bottomBy = np.append(bottomBy,
                                   bottomBy[:,1,:].reshape(bottomBy.shape[0],1,-1),axis=1)
        backBz = np.append(backBz[:,backBz.shape[1]-1,:].reshape(backBz.shape[0],1,-1),
                                  backBz[:,0:backBz.shape[1],:],axis=1)
        backBz = np.append(backBz,
                                    backBz[:,1,:].reshape(backBz.shape[0],1,-1),axis=1)
        forwBz = np.append(forwBz[:,forwBz.shape[1]-1,:].reshape(forwBz.shape[0],1,-1),
                                  forwBz[:,0:forwBz.shape[1],:],axis=1)
        forwBz = np.append(forwBz,
                                   forwBz[:,1,:].reshape(forwBz.shape[0],1,-1),axis=1)
        centBx = np.append(centBx[:,centBx.shape[1]-1,:].reshape(centBx.shape[0],1,-1),centBx,axis=1)
        centBx = np.append(centBx,centBx[:,1,:].reshape(centBx.shape[0],1,-1),axis=1)
        centBy = np.append(centBy[:,centBy.shape[1]-1,:].reshape(centBy.shape[0],1,-1),centBy,axis=1)
        centBy = np.append(centBy,centBy[:,1,:].reshape(centBy.shape[0],1,-1),axis=1)
        centBz = np.append(centBz[:,centBz.shape[1]-1,:].reshape(centBz.shape[0],1,-1),centBz,axis=1)
        centBz = np.append(centBz,centBz[:,1,:].reshape(centBz.shape[0],1,-1),axis=1)
        centVy = np.append(centVy[:,centVy.shape[1]-1,:].reshape(centVy.shape[0],1,-1),centVy,axis=1)
        centVy = np.append(centVy,centVy[:,1,:].reshape(centVy.shape[0],1,-1),axis=1)
        centVz = np.append(centVz[:,centVz.shape[1]-1,:].reshape(centVz.shape[0],1,-1),centVz,axis=1)
        centVz = np.append(centVz,centVz[:,1,:].reshape(centVz.shape[0],1,-1),axis=1)
        topIntercellFlux_forLeft = np.append(topIntercellFlux[:,:,topIntercellFlux.shape[2]-1,:].reshape(7,topIntercellFlux.shape[1],1,-1),
                                             topIntercellFlux,axis=2)
        bottomIntercellFlux_forLeft = np.append(bottomIntercellFlux[:,:,bottomIntercellFlux.shape[2]-1,:].reshape(7,bottomIntercellFlux.shape[1],1,-1),
                                                bottomIntercellFlux,axis=2)
        topIntercellFlux_forRight = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,0,:].reshape(7,topIntercellFlux.shape[1],1,-1),
                                              axis=2)
        bottomIntercellFlux_forRight = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,0,:].reshape(7,bottomIntercellFlux.shape[1],1,-1),
                                                 axis=2)
        backIntercellFlux_forLeft = np.append(backIntercellFlux[:,:,backIntercellFlux.shape[2]-1,:].reshape(7,backIntercellFlux.shape[1],1,-1),
                                             backIntercellFlux,axis=2)
        forwIntercellFlux_forLeft = np.append(forwIntercellFlux[:,:,forwIntercellFlux.shape[2]-1,:].reshape(7,forwIntercellFlux.shape[1],1,-1),
                                                forwIntercellFlux,axis=2)
        backIntercellFlux_forRight = np.append(backIntercellFlux,
                                              backIntercellFlux[:,:,0,:].reshape(7,backIntercellFlux.shape[1],1,-1),
                                              axis=2)
        forwIntercellFlux_forRight = np.append(forwIntercellFlux,
                                                 forwIntercellFlux[:,:,0,:].reshape(7,forwIntercellFlux.shape[1],1,-1),
                                                 axis=2)
        leftCornerEMF_x = np.append(cornerEMF_x[:,cornerEMF_x.shape[1]-2,:].reshape(-1,1,cornerEMF_x.shape[2]),
                                    cornerEMF_x[:,0:cornerEMF_x.shape[1]-1,:],axis=1)
    lowerCornerEMF_x = cornerEMF_x[1:cornerEMF_x.shape[0],:,:]
    lowerLeftCornerEMF_x = leftCornerEMF_x[1:leftCornerEMF_x.shape[0],:,:]
    leftCornerEMF_x = leftCornerEMF_x[0:leftCornerEMF_x.shape[0]-1,:,:]
    forwCornerEMF_x = cornerEMF_x[0:cornerEMF_x.shape[0]-1,:,1:cornerEMF_x.shape[2]]
    forwLeftCornerEMF_x = leftCornerEMF_x[:,:,1:leftCornerEMF_x.shape[2]]
    forwLowerCornerEMF_x = lowerCornerEMF_x[:,:,1:lowerCornerEMF_x.shape[2]]
    forwLowerLeftCornerEMF_x = lowerLeftCornerEMF_x[:,:,1:lowerLeftCornerEMF_x.shape[2]]
    leftCornerEMF_x = leftCornerEMF_x[:,:,0:leftCornerEMF_x.shape[2]-1]
    lowerCornerEMF_x = lowerCornerEMF_x[:,:,0:lowerCornerEMF_x.shape[2]-1]
    lowerLeftCornerEMF_x = lowerLeftCornerEMF_x[:,:,0:lowerLeftCornerEMF_x.shape[2]-1]
    rightCornerEMF_x = np.copy(cornerEMF_x)
    rightCornerEMF_x = rightCornerEMF_x[0:rightCornerEMF_x.shape[0]-1,:,0:rightCornerEMF_x.shape[2]-1]
    topIntercellFlux_forLeft[5] = 0.0
    topIntercellFlux_forLeft[4] = 0.0
    topIntercellFlux_forRight[5] = 0.0
    topIntercellFlux_forRight[4] = 0.0
    bottomIntercellFlux_forLeft[5] = 0.0
    bottomIntercellFlux_forLeft[4] = 0.0
    bottomIntercellFlux_forRight[5] = 0.0
    bottomIntercellFlux_forRight[4] = 0.0
    backIntercellFlux_forLeft[5] = 0.0
    backIntercellFlux_forLeft[4] = 0.0
    backIntercellFlux_forRight[5] = 0.0
    backIntercellFlux_forRight[4] = 0.0
    forwIntercellFlux_forLeft[5] = 0.0
    forwIntercellFlux_forLeft[4] = 0.0
    forwIntercellFlux_forRight[5] = 0.0
    forwIntercellFlux_forRight[4] = 0.0
    newLeftConsVars -= halfDtDy*(bottomIntercellFlux_forLeft - topIntercellFlux_forLeft)
    newRightConsVars -= halfDtDy*(bottomIntercellFlux_forRight - topIntercellFlux_forRight)
    newLeftConsVars[5] += halfDtDy*0.5*(lowerLeftCornerEMF_x-leftCornerEMF_x
                                                + forwLowerLeftCornerEMF_x - forwLeftCornerEMF_x)
    newRightConsVars[5] += halfDtDy*0.5*(lowerCornerEMF_x - rightCornerEMF_x
                                  + forwLowerCornerEMF_x - forwCornerEMF_x)

    newLeftConsVars -= halfDtDz*(forwIntercellFlux_forLeft-backIntercellFlux_forLeft)
    newRightConsVars -= halfDtDz*(forwIntercellFlux_forRight-backIntercellFlux_forRight)
    newLeftConsVars[4] -= halfDtDz*0.5 * (forwLeftCornerEMF_x - leftCornerEMF_x
                                                       + forwLowerLeftCornerEMF_x - lowerLeftCornerEMF_x)
    newRightConsVars[4] -= halfDtDz*0.5 * (forwCornerEMF_x - rightCornerEMF_x +
                                                         forwLowerCornerEMF_x - lowerCornerEMF_x)
    BxChange = (rightBx - leftBx)*invDx
    ByChange = (bottomBy - topBy)*invDy
    BzChange = (forwBz - backBz)*invDz
    minmodY = np.zeros(shape=ByChange.shape)
    minmodY[np.logical_and(np.logical_and(BxChange > 0.0,ByChange < 0.0),ByChange > -BxChange)] = ByChange[
        np.logical_and(np.logical_and(BxChange > 0.0,ByChange < 0.0),ByChange > -BxChange)]
    minmodY[np.logical_and(np.logical_and(BxChange > 0.0,ByChange < 0.0),ByChange <= -BxChange)] = -BxChange[
        np.logical_and(np.logical_and(BxChange > 0.0,ByChange < 0.0),ByChange <= -BxChange)]
    minmodY[np.logical_and(np.logical_and(BxChange < 0.0,ByChange > 0.0),ByChange < -BxChange)] = ByChange[
        np.logical_and(np.logical_and(BxChange < 0.0,ByChange > 0.0),ByChange < -BxChange)]
    minmodY[np.logical_and(np.logical_and(BxChange < 0.0,ByChange > 0.0),ByChange >= -BxChange)] = -BxChange[
        np.logical_and(np.logical_and(BxChange < 0.0,ByChange > 0.0),ByChange >= -BxChange)]
    minmodZ = np.zeros(shape=BzChange.shape)
    minmodZ[np.logical_and(np.logical_and(BxChange > 0.0,BzChange < 0.0),BzChange > -BxChange)] = BzChange[
        np.logical_and(np.logical_and(BxChange > 0.0,BzChange < 0.0),BzChange > -BxChange)]
    minmodZ[np.logical_and(np.logical_and(BxChange > 0.0,BzChange < 0.0),BzChange <= -BxChange)] = -BxChange[
        np.logical_and(np.logical_and(BxChange > 0.0,BzChange < 0.0),BzChange <= -BxChange)]
    minmodZ[np.logical_and(np.logical_and(BxChange < 0.0,BzChange > 0.0),BzChange < -BxChange)] = BzChange[
        np.logical_and(np.logical_and(BxChange < 0.0,BzChange > 0.0),BzChange < -BxChange)]
    minmodZ[np.logical_and(np.logical_and(BxChange < 0.0,BzChange > 0.0),BzChange >= -BxChange)] = -BxChange[
        np.logical_and(np.logical_and(BxChange < 0.0,BzChange > 0.0),BzChange >= -BxChange)]
    sourceVector = np.array([np.zeros(shape=(primVarsX.shape[1],primVarsX.shape[2]+2,primVarsX.shape[3])),
                             halfDt*centBx*BxChange,
                            halfDt*centBy*BxChange,
                            halfDt*centBz*BxChange,
                            halfDt*centVy*(-minmodZ),
                            halfDt*centVz*(-minmodY),
                             halfDt*(centBy*centVy*(-minmodZ)
                            +centBz*centVz*(-minmodY))])
    leftSourceVector = sourceVector[:,:,0:sourceVector.shape[2]-1,:]
    rightSourceVector = sourceVector[:,:,1:sourceVector.shape[2],:]
    newLeftConsVars += leftSourceVector
    newRightConsVars += rightSourceVector
    return (newLeftConsVars,newRightConsVars)

#Function:
#Purpose:
#Input Parameters:
#Outputs:
def getYTransverseUpdates_3D(topConsVars,bottomConsVars,primVarsX,primVarsY,intercellFluxX,intercellFluxZ,faceBx,faceBy,faceBz,cornerEMF_y,dt,dx,dy,dz,BcY):
    newTopConsVars = np.copy(topConsVars)
    newBottomConsVars = np.copy(bottomConsVars)
    transverseCorrections = np.zeros(shape=(2, 7, primVarsX.shape[1]+1, primVarsX.shape[2], primVarsX.shape[3]))
    dtdx = dt/dx
    halfDtDx = 0.5*dtdx
    dtdz = dt/dz
    halfDtDz = 0.5*dtdz
    centBx = primVarsY[5]
    centBy = primVarsX[4]
    centBz = primVarsX[5]
    centVx = primVarsX[1]
    centVz = primVarsX[3]
    leftIntercellFlux = intercellFluxX[:,:,0:intercellFluxX.shape[2]-1,:]
    rightIntercellFlux = intercellFluxX[:,:,1:intercellFluxX.shape[2],:]
    backIntercellFlux = intercellFluxZ[:,:,:,0:intercellFluxZ.shape[3]-1]
    forwIntercellFlux = intercellFluxZ[:,:,:,1:intercellFluxZ.shape[3]]
    leftBx = faceBx[:,0:faceBx.shape[1]-1,:]
    rightBx = faceBx[:,1:faceBx.shape[1],:]
    backBz = faceBz[:,:,0:faceBz.shape[2]-1]
    forwBz = faceBz[:,:,1:faceBz.shape[2]]
    if BcY == constants.OUTFLOW:
        topBy = np.append(faceBy[0,:,].reshape(1,faceBy.shape[1],-1),
                                   faceBy[0:faceBy.shape[0],:,],axis=0)
        bottomBy = np.append(faceBy[0:faceBy.shape[0],:,],
                                     faceBy[faceBy.shape[0]-1,:,:].reshape(1,faceBy.shape[1],-1),
                                     axis=0)
        leftBx = np.append(leftBx[0,:,].reshape(1,leftBx.shape[1],-1),
                                  leftBx,axis=0)
        leftBx = np.append(leftBx,
                                   leftBx[leftBx.shape[0]-1,:,].reshape(1,leftBx.shape[1],-1),axis=0)
        rightBx = np.append(rightBx[0,:,:].reshape(1,rightBx.shape[1],-1),
                                     rightBx,axis=0)
        rightBx = np.append(rightBx,
                                   rightBx[rightBx.shape[0]-1,:,].reshape(1,rightBx.shape[1],-1),axis=0)
        backBz = np.append(backBz[0,:,].reshape(1,backBz.shape[1],-1),
                                  backBz,axis=0)
        backBz = np.append(backBz,
                                   backBz[backBz.shape[0]-1,:,:].reshape(1,backBz.shape[1],-1),axis=0)
        forwBz = np.append(forwBz[0,:,:].reshape(1,forwBz.shape[1],-1),
                                  forwBz,axis=0)
        forwBz = np.append(forwBz,
                                   forwBz[forwBz.shape[0]-1,:,:].reshape(1,forwBz.shape[1],-1),axis=0)
        centBx = np.append(centBx[0,:,:].reshape(1,centBx.shape[1],-1),centBx,axis=0)
        centBx = np.append(centBx,centBx[centBx.shape[0]-1,:,:].reshape(1,centBx.shape[1],-1),axis=0)
        centBy = np.append(centBy[0,:,:].reshape(1,centBy.shape[1],-1),centBy,axis=0)
        centBy = np.append(centBy,centBy[centBy.shape[0]-1,:,:].reshape(1,centBy.shape[1],-1),axis=0)
        centBz = np.append(centBz[0,:,:].reshape(1,centBz.shape[1],-1),centBz,axis=0)
        centBz = np.append(centBz,centBz[centBz.shape[0]-1,:,:].reshape(1,centBz.shape[1],-1),axis=0)
        centVx = np.append(centVx[0,:,:].reshape(1,centVx.shape[1],-1),centVx,axis=0)
        centVx = np.append(centVx,centVx[centVx.shape[0]-1,:,:].reshape(1,centVx.shape[1],-1),axis=0)
        centVz = np.append(centVz[0,:,:].reshape(1,centVz.shape[1],-1),centVz,axis=0)
        centVz = np.append(centVz,centVz[centVz.shape[0]-1,:,:].reshape(1,centVz.shape[1],-1),axis=0)
        leftIntercellFlux_forTop = np.append(leftIntercellFlux[:,0,:,:].reshape(7,1,leftIntercellFlux.shape[2],-1),
                                             leftIntercellFlux,axis=1)
        rightIntercellFlux_forTop = np.append(rightIntercellFlux[:,0,:,:].reshape(7,1,rightIntercellFlux.shape[2],-1),
                                                rightIntercellFlux,axis=1)
        leftIntercellFlux_forBottom = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,leftIntercellFlux.shape[1]-1,:,:].reshape(7,1,leftIntercellFlux.shape[2],-1),
                                              axis=1)
        rightIntercellFlux_forBottom = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,rightIntercellFlux.shape[2]-1,:,:].reshape(7,1,rightIntercellFlux.shape[2],-1),
                                                 axis=1)
        backIntercellFlux_forTop = np.append(backIntercellFlux[:,0,:,:].reshape(7,1,backIntercellFlux.shape[2],-1),
                                             backIntercellFlux,axis=1)
        forwIntercellFlux_forTop = np.append(forwIntercellFlux[:,0,:,:].reshape(7,1,forwIntercellFlux.shape[2],-1),
                                                forwIntercellFlux,axis=1)
        backIntercellFlux_forBottom = np.append(backIntercellFlux,
                                              backIntercellFlux[:,backIntercellFlux.shape[1]-1,:,:].reshape(7,1,backIntercellFlux.shape[2],-1),
                                              axis=1)
        forwIntercellFlux_forBottom = np.append(forwIntercellFlux,
                                                 forwIntercellFlux[:,forwIntercellFlux.shape[1]-1,:,:].reshape(7,1,forwIntercellFlux.shape[2],-1),
                                                 axis=1)
        topCornerEMF_y = np.append(cornerEMF_y[0,:,:].reshape(1,-1,cornerEMF_y.shape[2]),
                                    cornerEMF_y[0:cornerEMF_y.shape[0]-1,:,:],axis=0)
    else:
        topBy = np.append(faceBy[faceBy.shape[0]-2,:,].reshape(1,faceBy.shape[1],-1),
                                   faceBy[0:faceBy.shape[0],:,],axis=0)
        bottomBy = np.append(faceBy[0:faceBy.shape[0],:,],
                                     faceBy[1,:,:].reshape(1,faceBy.shape[1],-1),
                                     axis=0)
        leftBx = np.append(leftBx[leftBx.shape[0]-1,:,].reshape(1,leftBx.shape[1],-1),
                                  leftBx,axis=0)
        leftBx = np.append(leftBx,
                                   leftBx[1,:,].reshape(1,leftBx.shape[1],-1),axis=0)
        rightBx = np.append(rightBx[rightBx.shape[0]-1,:,:].reshape(1,rightBx.shape[1],-1),
                                     rightBx,axis=0)
        rightBx = np.append(rightBx,
                                   rightBx[1,:,].reshape(1,rightBx.shape[1],-1),axis=0)
        backBz = np.append(backBz[backBz.shape[0]-1,:,].reshape(1,backBz.shape[1],-1),
                                  backBz,axis=0)
        backBz = np.append(backBz,
                                   backBz[1,:,:].reshape(1,backBz.shape[1],-1),axis=0)
        forwBz = np.append(forwBz[forwBz.shape[0]-1,:,:].reshape(1,forwBz.shape[1],-1),
                                  forwBz,axis=0)
        forwBz = np.append(forwBz,
                                   forwBz[1,:,:].reshape(1,forwBz.shape[1],-1),axis=0)
        centBx = np.append(centBx[centBx.shape[0]-1,:,:].reshape(1,centBx.shape[1],-1),centBx,axis=0)
        centBx = np.append(centBx,centBx[1,:,:].reshape(1,centBx.shape[1],-1),axis=0)
        centBy = np.append(centBy[centBy.shape[0]-1,:,:].reshape(1,centBy.shape[1],-1),centBy,axis=0)
        centBy = np.append(centBy,centBy[1,:,:].reshape(1,centBy.shape[1],-1),axis=0)
        centBz = np.append(centBz[centBz.shape[0]-1,:,:].reshape(1,centBz.shape[1],-1),centBz,axis=0)
        centBz = np.append(centBz,centBz[1,:,:].reshape(1,centBz.shape[1],-1),axis=0)
        centVx = np.append(centVx[centVx.shape[0]-1,:,:].reshape(1,centVx.shape[1],-1),centVx,axis=0)
        centVx = np.append(centVx,centVx[1,:,:].reshape(1,centVx.shape[1],-1),axis=0)
        centVz = np.append(centVz[centVz.shape[0]-1,:,:].reshape(1,centVz.shape[1],-1),centVz,axis=0)
        centVz = np.append(centVz,centVz[1,:,:].reshape(1,centVz.shape[1],-1),axis=0)
        leftIntercellFlux_forTop = np.append(leftIntercellFlux[:,leftIntercellFlux.shape[1]-1,:,:].reshape(7,1,leftIntercellFlux.shape[2],-1),
                                             leftIntercellFlux,axis=1)
        rightIntercellFlux_forTop = np.append(rightIntercellFlux[:,rightIntercellFlux.shape[1]-1,:,:].reshape(7,1,rightIntercellFlux.shape[2],-1),
                                                rightIntercellFlux,axis=1)
        leftIntercellFlux_forBottom = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,0,:,:].reshape(7,1,leftIntercellFlux.shape[2],-1),
                                              axis=1)
        rightIntercellFlux_forBottom = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,0,:,:].reshape(7,1,rightIntercellFlux.shape[2],-1),
                                                 axis=1)
        backIntercellFlux_forTop = np.append(backIntercellFlux[:,backIntercellFlux.shape[1]-1,:,:].reshape(7,1,backIntercellFlux.shape[2],-1),
                                             backIntercellFlux,axis=1)
        forwIntercellFlux_forTop = np.append(forwIntercellFlux[:,forwIntercellFlux.shape[1]-1,:,:].reshape(7,1,forwIntercellFlux.shape[2],-1),
                                                forwIntercellFlux,axis=1)
        backIntercellFlux_forBottom = np.append(backIntercellFlux,
                                              backIntercellFlux[:,0,:,:].reshape(7,1,backIntercellFlux.shape[2],-1),
                                              axis=1)
        forwIntercellFlux_forBottom = np.append(forwIntercellFlux,
                                                 forwIntercellFlux[:,0,:,:].reshape(7,1,forwIntercellFlux.shape[2],-1),
                                                 axis=1)
        topCornerEMF_y = np.append(cornerEMF_y[cornerEMF_y.shape[0]-2,:,:].reshape(1,-1,cornerEMF_y.shape[2]),
                                    cornerEMF_y[0:cornerEMF_y.shape[0]-1,:,:],axis=0)
    rightCornerEMF_y = cornerEMF_y[:,1:cornerEMF_y.shape[1],:]
    rightTopCornerEMF_y = topCornerEMF_y[:,1:topCornerEMF_y.shape[1],:]
    topCornerEMF_y = topCornerEMF_y[:,0:topCornerEMF_y.shape[1]-1,:]
    forwCornerEMF_y = cornerEMF_y[:,0:cornerEMF_y.shape[1]-1,1:cornerEMF_y.shape[2]]
    forwTopCornerEMF_y = topCornerEMF_y[:,:,1:topCornerEMF_y.shape[2]]
    forwRightCornerEMF_y = rightCornerEMF_y[:,:,1:rightCornerEMF_y.shape[2]]
    forwRightTopCornerEMF_y = rightTopCornerEMF_y[:,:,1:rightTopCornerEMF_y.shape[2]]
    topCornerEMF_y = topCornerEMF_y[:,:,0:topCornerEMF_y.shape[2]-1]
    rightCornerEMF_y = rightCornerEMF_y[:,:,0:rightCornerEMF_y.shape[2]-1]
    rightTopCornerEMF_y = rightTopCornerEMF_y[:,:,0:rightTopCornerEMF_y.shape[2]-1]
    bottomCornerEMF_y = np.copy(cornerEMF_y)
    bottomCornerEMF_y = bottomCornerEMF_y[:,0:bottomCornerEMF_y.shape[1]-1,0:bottomCornerEMF_y.shape[2]-1]
    leftIntercellFlux_forTop[5] = 0.0
    leftIntercellFlux_forTop[4] = 0.0
    leftIntercellFlux_forBottom[5] = 0.0
    leftIntercellFlux_forBottom[4] = 0.0
    rightIntercellFlux_forTop[5] = 0.0
    rightIntercellFlux_forTop[4] = 0.0
    rightIntercellFlux_forBottom[5] = 0.0
    rightIntercellFlux_forBottom[4] = 0.0
    backIntercellFlux_forTop[5] = 0.0
    backIntercellFlux_forTop[4] = 0.0
    backIntercellFlux_forBottom[5] = 0.0
    backIntercellFlux_forBottom[4] = 0.0
    forwIntercellFlux_forTop[5] = 0.0
    forwIntercellFlux_forTop[4] = 0.0
    forwIntercellFlux_forBottom[5] = 0.0
    forwIntercellFlux_forBottom[4] = 0.0
    newTopConsVars -= halfDtDx*(rightIntercellFlux_forTop - leftIntercellFlux_forTop)
    newBottomConsVars -= halfDtDx*(rightIntercellFlux_forBottom - leftIntercellFlux_forBottom)
    newTopConsVars[4] -= halfDtDx*0.5 * (rightTopCornerEMF_y - topCornerEMF_y
                                                      +  forwRightTopCornerEMF_y - forwTopCornerEMF_y)
    newBottomConsVars[4] -= halfDtDx*0.5 * (rightCornerEMF_y - bottomCornerEMF_y
                                                         + forwRightCornerEMF_y - forwCornerEMF_y)

    newTopConsVars -= halfDtDz*(forwIntercellFlux_forTop-backIntercellFlux_forTop)
    newBottomConsVars -= halfDtDz*(forwIntercellFlux_forBottom-backIntercellFlux_forBottom)
    newTopConsVars[5] += halfDtDz*0.5 * (forwTopCornerEMF_y - topCornerEMF_y
                                                      + forwRightTopCornerEMF_y - rightTopCornerEMF_y)
    newBottomConsVars[5] += halfDtDz*0.5 * (forwCornerEMF_y - bottomCornerEMF_y
                                                         + forwRightCornerEMF_y - rightCornerEMF_y)
    BxChange = (rightBx - leftBx) / dx
    ByChange = (bottomBy - topBy) / dy
    BzChange = (forwBz - backBz) / dz
    minmodX = np.zeros(shape=BxChange.shape)
    minmodX[np.logical_and(np.logical_and(ByChange > 0.0,BxChange < 0.0),BxChange > -ByChange)] = BxChange[
        np.logical_and(np.logical_and(ByChange > 0.0, BxChange < 0.0),BxChange > -ByChange)]
    minmodX[np.logical_and(np.logical_and(ByChange > 0.0,BxChange < 0.0),BxChange <= -ByChange)] = -ByChange[
        np.logical_and(np.logical_and(ByChange > 0.0,BxChange < 0.0),BxChange <= -ByChange)]
    minmodX[np.logical_and(np.logical_and(ByChange < 0.0,BxChange > 0.0),BxChange < -ByChange)] = BxChange[
        np.logical_and(np.logical_and(ByChange < 0.0,BxChange > 0.0),BxChange < -ByChange)]
    minmodX[np.logical_and(np.logical_and(ByChange < 0.0,BxChange > 0.0),BxChange >= -ByChange)] = -ByChange[
        np.logical_and(np.logical_and(ByChange < 0.0,BxChange > 0.0),BxChange >= -ByChange)]
    minmodZ = np.zeros(shape=BzChange.shape)
    minmodZ[np.logical_and(np.logical_and(ByChange > 0.0,BzChange < 0.0),BzChange > -ByChange)] = BzChange[
        np.logical_and(np.logical_and(ByChange > 0.0,BzChange < 0.0),BzChange > -ByChange)]
    minmodZ[np.logical_and(np.logical_and(ByChange > 0.0,BzChange < 0.0),BzChange <= -ByChange)] = -ByChange[
        np.logical_and(np.logical_and(ByChange > 0.0,BzChange < 0.0),BzChange <= -ByChange)]
    minmodZ[np.logical_and(np.logical_and(ByChange < 0.0,BzChange > 0.0),BzChange < -ByChange)] = BzChange[
        np.logical_and(np.logical_and(ByChange < 0.0,BzChange > 0.0),BzChange < -ByChange)]
    minmodZ[np.logical_and(np.logical_and(ByChange < 0.0,BzChange > 0.0),BzChange >= -ByChange)] = -ByChange[
        np.logical_and(np.logical_and(ByChange < 0.0,BzChange > 0.0),BzChange >= -ByChange)]
    halfDt = 0.5*dt
    sourceVector = np.array([np.zeros(shape=(primVarsX.shape[1]+2,primVarsX.shape[2],primVarsX.shape[3])),
                             halfDt*centBx*ByChange,
                            halfDt*centBy*ByChange,
                            halfDt*centBz*ByChange,
                            halfDt*centVz*(-minmodX),
                            halfDt*centVx*(-minmodZ),
                             halfDt*(centBz*centVz*(-minmodX)
                            +centBx*centVx*(-minmodZ))])
    topSourceVector = sourceVector[:,0:sourceVector.shape[1]-1,:,:]
    bottomSourceVector = sourceVector[:,1:sourceVector.shape[1]]
    newTopConsVars += topSourceVector
    newBottomConsVars += bottomSourceVector
    return (newTopConsVars,newBottomConsVars)

#Function:
#Purpose:
#Input Parameters:
#Outputs:
def getZTransverseUpdates_3D(backConsVars,forwConsVars,primVarsX,primVarsY,intercellFluxX,intercellFluxY,faceBx,faceBy,faceBz,cornerEMF_z,dt,dx,dy,dz,BcZ):
    newBackConsVars = np.copy(backConsVars)
    newForwConsVars = np.copy(forwConsVars)
    dtdx = dt/dx
    dtdy = dt/dy
    halfDtDx = 0.5*dtdx
    halfDtDy = 0.5*dtdy
    transverseCorrections = np.zeros(shape=(2, 7, primVarsX.shape[1], primVarsX.shape[2], primVarsX.shape[3]+1))
    centBx = primVarsY[5]
    centBy = primVarsX[4]
    centBz = primVarsX[5]
    centVx = primVarsX[1]
    centVy = primVarsX[2]
    leftIntercellFlux = intercellFluxX[:,:,0:intercellFluxX.shape[2]-1,:]
    rightIntercellFlux = intercellFluxX[:,:,1:intercellFluxX.shape[2],:]
    topIntercellFlux = intercellFluxY[:,0:intercellFluxY.shape[1]-1,:,:]
    bottomIntercellFlux = intercellFluxY[:,1:intercellFluxY.shape[1],:,:]
    leftBx = faceBx[:,0:faceBx.shape[1]-1,:]
    rightBx = faceBx[:,1:faceBx.shape[1],:]
    topBy = faceBy[0:faceBy.shape[0]-1,:,:]
    bottomBy = faceBy[1:faceBy.shape[0],:,:]
    if BcZ == constants.OUTFLOW:
        backBz = np.append(faceBz[:,:,0].reshape(-1,faceBz.shape[1],1),
                                   faceBz[:,:,0:faceBz.shape[2]],axis=2)
        forwBz = np.append(faceBz[:,:,0:faceBz.shape[2]],
                                     faceBz[:,:,faceBy.shape[2]-1].reshape(-1,faceBy.shape[1],1),
                                     axis=2)
        leftBx = np.append(leftBx[:,:,0].reshape(-1,leftBx.shape[1],1),
                                  leftBx,axis=2)
        leftBx = np.append(leftBx,
                                   leftBx[:,:,leftBx.shape[2]-1].reshape(-1,leftBx.shape[1],1),axis=2)
        rightBx = np.append(rightBx[:,:,0].reshape(-1,rightBx.shape[1],1),
                                     rightBx,axis=2)
        rightBx = np.append(rightBx,
                                   rightBx[:,:,rightBx.shape[2]-1].reshape(-1,rightBx.shape[1],1),axis=2)
        topBy = np.append(topBy[:,:,0].reshape(-1,topBy.shape[1],1),
                                  topBy,axis=2)
        topBy = np.append(topBy,
                                  topBy[:,:,topBy.shape[2]-1].reshape(-1,topBy.shape[1],1),axis=2)
        bottomBy = np.append(bottomBy[:,:,0].reshape(-1,bottomBy.shape[1],1),
                                  bottomBy,axis=2)
        bottomBy = np.append(bottomBy,
                                   bottomBy[:,:,bottomBy.shape[2]-1].reshape(-1,bottomBy.shape[0],1),axis=2)
        centBx = np.append(centBx[:,:,0].reshape(-1,centBx.shape[1],1),centBx,axis=2)
        centBx = np.append(centBx,centBx[:,:,centBx.shape[2]-1].reshape(-1,centBx.shape[1],1),axis=2)
        centBy = np.append(centBy[:,:,0].reshape(-1,centBy.shape[1],1),centBy,axis=2)
        centBy = np.append(centBy,centBy[:,:,centBy.shape[2]-1].reshape(-1,centBy.shape[1],1),axis=2)
        centBz = np.append(centBz[:,:,0].reshape(-1,centBz.shape[1],1),centBz,axis=2)
        centBz = np.append(centBz,centBz[:,:,centBz.shape[2]-1].reshape(centBz.shape[0],-1,1),axis=2)
        centVx = np.append(centVx[:,:,0].reshape(-1,centVx.shape[1],1),centVx,axis=2)
        centVx = np.append(centVx,centVx[:,:,centVx.shape[2]-1].reshape(-1,centVx.shape[1],1),axis=2)
        centVy = np.append(centVy[:,:,0].reshape(-1,centVy.shape[1],1),centVy,axis=2)
        centVy = np.append(centVy,centVy[:,:,centVy.shape[2]-1].reshape(-1,centVy.shape[1],1),axis=2)
        leftIntercellFlux_forBack = np.append(leftIntercellFlux[:,:,:,0].reshape(7,-1,leftIntercellFlux.shape[2],1),
                                             leftIntercellFlux,axis=3)
        rightIntercellFlux_forBack = np.append(rightIntercellFlux[:,:,:,0].reshape(7,-1,rightIntercellFlux.shape[2],1),
                                                rightIntercellFlux,axis=3)
        leftIntercellFlux_forForw = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,:,:,leftIntercellFlux.shape[3]-1].reshape(7,-1,leftIntercellFlux.shape[2],1),
                                              axis=3)
        rightIntercellFlux_forForw = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,:,:,rightIntercellFlux.shape[3]-1].reshape(7,-1,rightIntercellFlux.shape[2],1),
                                                 axis=3)
        topIntercellFlux_forBack = np.append(topIntercellFlux[:,:,:,0].reshape(7,-1,topIntercellFlux.shape[2],1),
                                             topIntercellFlux,axis=3)
        bottomIntercellFlux_forBack = np.append(bottomIntercellFlux[:,:,:,0].reshape(7,-1,bottomIntercellFlux.shape[2],1),
                                                bottomIntercellFlux,axis=3)
        topIntercellFlux_forForw = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,:,topIntercellFlux.shape[3]-1].reshape(7,-1,topIntercellFlux.shape[2],1),
                                              axis=3)
        bottomIntercellFlux_forForw = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,:,bottomIntercellFlux.shape[3]-1].reshape(7,-1,bottomIntercellFlux.shape[2],1),
                                                 axis=3)
        backCornerEMF_z = np.append(cornerEMF_z[:,:,0].reshape(-1,cornerEMF_z.shape[1],1),
                                    cornerEMF_z[:,:,0:cornerEMF_z.shape[2]-1],axis=2)
    else:
        backBz = np.append(faceBz[:,:,faceBz.shape[2]-2].reshape(-1,faceBz.shape[1],1),
                                   faceBz[:,:,0:faceBz.shape[2]],axis=2)
        forwBz = np.append(faceBz[:,:,0:faceBz.shape[2]],
                                     faceBz[:,:,1].reshape(-1,faceBy.shape[1],1),
                                     axis=2)
        leftBx = np.append(leftBx[:,:,leftBx.shape[2]-1].reshape(-1,leftBx.shape[1],1),
                                  leftBx,axis=2)
        leftBx = np.append(leftBx,
                                   leftBx[:,:,1].reshape(-1,leftBx.shape[1],1),axis=2)
        rightBx = np.append(rightBx[:,:,rightBx.shape[2]-1].reshape(-1,rightBx.shape[1],1),
                                     rightBx,axis=2)
        rightBx = np.append(rightBx,
                                   rightBx[:,:,1].reshape(-1,rightBx.shape[1],1),axis=2)
        topBy = np.append(topBy[:,:,topBy.shape[2]-1].reshape(-1,topBy.shape[1],1),
                                  topBy,axis=2)
        topBy = np.append(topBy,
                                  topBy[:,:,1].reshape(-1,topBy.shape[1],1),axis=2)
        bottomBy = np.append(bottomBy[:,:,bottomBy.shape[2]-1].reshape(-1,bottomBy.shape[1],1),
                                  bottomBy,axis=2)
        bottomBy= np.append(bottomBy,
                                   bottomBy[:,:,1].reshape(-1,bottomBy.shape[1],1),axis=2)
        centBx = np.append(centBx[:,:,centBx.shape[2]-1].reshape(-1,centBx.shape[1],1),centBx,axis=2)
        centBx = np.append(centBx,centBx[:,:,1].reshape(-1,centBx.shape[1],1),axis=2)
        centBy = np.append(centBy[:,:,centBy.shape[2]-1].reshape(-1,centBy.shape[1],1),centBy,axis=2)
        centBy = np.append(centBy,centBy[:,:,1].reshape(-1,centBy.shape[1],1),axis=2)
        centBz = np.append(centBz[:,:,centBz.shape[2]-1].reshape(-1,centBz.shape[1],1),centBz,axis=2)
        centBz = np.append(centBz,centBz[:,:,1].reshape(centBz.shape[0],-1,1),axis=2)
        centVx = np.append(centVx[:,:,centVx.shape[2]-1].reshape(-1,centVx.shape[1],1),centVx,axis=2)
        centVx = np.append(centVx,centVx[:,:,1].reshape(-1,centVx.shape[1],1),axis=2)
        centVy = np.append(centVy[:,:,centVy.shape[2]-1].reshape(-1,centVy.shape[1],1),centVy,axis=2)
        centVy = np.append(centVy,centVy[:,:,1].reshape(-1,centVy.shape[1],1),axis=2)
        leftIntercellFlux_forBack = np.append(leftIntercellFlux[:,:,:,leftIntercellFlux.shape[3]-1].reshape(7,-1,leftIntercellFlux.shape[2],1),
                                             leftIntercellFlux,axis=3)
        rightIntercellFlux_forBack = np.append(rightIntercellFlux[:,:,:,rightIntercellFlux.shape[3]-1].reshape(7,-1,rightIntercellFlux.shape[2],1),
                                                rightIntercellFlux,axis=3)
        leftIntercellFlux_forForw = np.append(leftIntercellFlux,
                                              leftIntercellFlux[:,:,:,0].reshape(7,-1,leftIntercellFlux.shape[2],1),
                                              axis=3)
        rightIntercellFlux_forForw = np.append(rightIntercellFlux,
                                                 rightIntercellFlux[:,:,:,0].reshape(7,-1,rightIntercellFlux.shape[2],1),
                                                 axis=3)
        topIntercellFlux_forBack = np.append(topIntercellFlux[:,:,:,topIntercellFlux.shape[3]-1].reshape(7,-1,topIntercellFlux.shape[2],1),
                                             topIntercellFlux,axis=3)
        bottomIntercellFlux_forBack = np.append(bottomIntercellFlux[:,:,:,bottomIntercellFlux.shape[3]-1].reshape(7,-1,bottomIntercellFlux.shape[2],1),
                                                bottomIntercellFlux,axis=3)
        topIntercellFlux_forForw = np.append(topIntercellFlux,
                                              topIntercellFlux[:,:,:,0].reshape(7,-1,topIntercellFlux.shape[2],1),
                                              axis=3)
        bottomIntercellFlux_forForw = np.append(bottomIntercellFlux,
                                                 bottomIntercellFlux[:,:,:,0].reshape(7,-1,bottomIntercellFlux.shape[2],1),
                                                 axis=3)
        backCornerEMF_z = np.append(cornerEMF_z[:,:,cornerEMF_z.shape[2]-2].reshape(-1,cornerEMF_z.shape[1],1),
                                    cornerEMF_z[:,:,0:cornerEMF_z.shape[2]-1],axis=2)
    rightCornerEMF_z = cornerEMF_z[:,1:cornerEMF_z.shape[1],:]
    rightBackCornerEMF_z = backCornerEMF_z[:,1:backCornerEMF_z.shape[1],:]
    backCornerEMF_z = backCornerEMF_z[:,0:backCornerEMF_z.shape[1]-1,:]
    bottomCornerEMF_z = cornerEMF_z[1:cornerEMF_z.shape[0],0:cornerEMF_z.shape[1]-1,:]
    bottomBackCornerEMF_z = backCornerEMF_z[1:backCornerEMF_z.shape[0],:,:]
    bottomRightCornerEMF_z = rightCornerEMF_z[1:rightCornerEMF_z.shape[0],:,:]
    bottomRightBackCornerEMF_z = rightBackCornerEMF_z[1:rightBackCornerEMF_z.shape[0],:,:]
    backCornerEMF_z = backCornerEMF_z[0:backCornerEMF_z.shape[0]-1,:,:]
    rightCornerEMF_z = rightCornerEMF_z[0:rightCornerEMF_z.shape[0]-1,:,:]
    rightBackCornerEMF_z = rightBackCornerEMF_z[0:rightBackCornerEMF_z.shape[0]-1,:,:]
    forwCornerEMF_z = np.copy(cornerEMF_z)
    forwCornerEMF_z = forwCornerEMF_z[0:forwCornerEMF_z.shape[0]-1,0:forwCornerEMF_z.shape[1]-1,:]
    forwBz_forBack = np.copy(faceBz)
    backBz_forForw = np.copy(faceBz)
    leftIntercellFlux_forBack[5] = 0.0
    leftIntercellFlux_forBack[4] = 0.0
    leftIntercellFlux_forForw[5] = 0.0
    leftIntercellFlux_forForw[4] = 0.0
    rightIntercellFlux_forBack[5] = 0.0
    rightIntercellFlux_forBack[4] = 0.0
    rightIntercellFlux_forForw[5] = 0.0
    rightIntercellFlux_forForw[4] = 0.0
    topIntercellFlux_forBack[5] = 0.0
    topIntercellFlux_forBack[4] = 0.0
    topIntercellFlux_forForw[5] = 0.0
    topIntercellFlux_forForw[4] = 0.0
    bottomIntercellFlux_forBack[5] = 0.0
    bottomIntercellFlux_forBack[4] = 0.0
    bottomIntercellFlux_forForw[5] = 0.0
    bottomIntercellFlux_forForw[4] = 0.0
    newBackConsVars -= halfDtDx*(rightIntercellFlux_forBack - leftIntercellFlux_forBack)
    newForwConsVars -= halfDtDx*(rightIntercellFlux_forForw - leftIntercellFlux_forForw)
    newBackConsVars[5] += halfDtDx*0.5 * (rightBackCornerEMF_z - backCornerEMF_z
                                                             + bottomRightBackCornerEMF_z - bottomBackCornerEMF_z)
    newForwConsVars[5] += halfDtDx*0.5 * (rightCornerEMF_z - forwCornerEMF_z
                                                             + bottomRightCornerEMF_z - bottomCornerEMF_z)

    newBackConsVars -= halfDtDy*(bottomIntercellFlux_forBack-topIntercellFlux_forBack)
    newForwConsVars -= halfDtDy*(bottomIntercellFlux_forForw-topIntercellFlux_forForw)
    newBackConsVars[4] -= halfDtDy*0.5 * (bottomBackCornerEMF_z - backCornerEMF_z
                                                    + bottomRightBackCornerEMF_z - rightBackCornerEMF_z)
    newForwConsVars[4] -= halfDtDy*0.5 * (bottomCornerEMF_z - forwCornerEMF_z
                                                    + bottomRightCornerEMF_z - rightCornerEMF_z)
    BxChange = (rightBx - leftBx) / dx
    ByChange = (bottomBy - topBy) / dy
    BzChange = (forwBz - backBz) / dz
    minmodX = np.zeros(shape=BxChange.shape)
    minmodX[np.logical_and(np.logical_and(BzChange > 0.0,BxChange < 0.0),BxChange > -BzChange)] = BxChange[
        np.logical_and(np.logical_and(BzChange > 0.0,BxChange < 0.0),BxChange > -BzChange)]
    minmodX[np.logical_and(np.logical_and(BzChange > 0.0,BxChange < 0.0),BxChange <= -BzChange)] = -BzChange[
        np.logical_and(np.logical_and(BzChange > 0.0,BxChange < 0.0),BxChange <= -BzChange)]
    minmodX[np.logical_and(np.logical_and(BzChange < 0.0,BxChange > 0.0),BxChange < -BzChange)] = BxChange[
        np.logical_and(np.logical_and(BzChange < 0.0,BxChange > 0.0),BxChange < -BzChange)]
    minmodX[np.logical_and(np.logical_and(BzChange < 0.0,BxChange > 0.0),BxChange >= -BzChange)] = -BzChange[
        np.logical_and(np.logical_and(BzChange < 0.0,BxChange > 0.0),BxChange >= -BzChange)]
    minmodY = np.zeros(shape=ByChange.shape)
    minmodY[np.logical_and(np.logical_and(BzChange > 0.0,ByChange < 0.0),ByChange > -BzChange)] = ByChange[
        np.logical_and(np.logical_and(BzChange > 0.0,ByChange < 0.0),ByChange > -BzChange)]
    minmodY[np.logical_and(np.logical_and(BzChange > 0.0,ByChange < 0.0),ByChange <= -BzChange)] = -BzChange[
        np.logical_and(np.logical_and(BzChange > 0.0,ByChange < 0.0),ByChange <= -BzChange)]
    minmodY[np.logical_and(np.logical_and(BzChange < 0.0,ByChange > 0.0),ByChange < -BzChange)] = ByChange[
        np.logical_and(np.logical_and(BzChange < 0.0,ByChange > 0.0),ByChange < -BzChange)]
    minmodY[np.logical_and(np.logical_and(BzChange < 0.0,ByChange > 0.0),ByChange >= -BzChange)] = -BzChange[
        np.logical_and(np.logical_and(BzChange < 0.0,ByChange > 0.0),ByChange >= -BzChange)]
    halfDt = 0.5*dt
    sourceVector = np.array([np.zeros(shape=(primVarsX.shape[1],primVarsX.shape[2],primVarsX.shape[3]+2)),
                            halfDt*centBx*BzChange,
                            halfDt*centBy*BzChange,
                            halfDt*centBz*BzChange,
                            halfDt*centVx*(-minmodY),
                            halfDt*centVy*(-minmodX),
                            halfDt*(centBx*centVx*(-minmodY)
                            +centBy*centVy*(-minmodX))])
    backSourceVector = sourceVector[:,:,:,0:sourceVector.shape[3]-1]
    forwSourceVector = sourceVector[:,:,:,1:sourceVector.shape[3]]
    newBackConsVars += backSourceVector
    newForwConsVars += forwSourceVector
    return (newBackConsVars,newForwConsVars)